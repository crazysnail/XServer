// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Scott.proto

#ifndef PROTOBUF_Scott_2eproto__INCLUDED
#define PROTOBUF_Scott_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Scott {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Scott_2eproto();
void protobuf_AssignDesc_Scott_2eproto();
void protobuf_ShutdownFile_Scott_2eproto();

class LoginRequest;
class LoginReply;
class ChatRequest;
class ChatReply;
class Gladiatus;
class Gladiatus_PartProperty;
class Player;
class Arena;
class ArenaOperations;
class ArenaOperations_Operation;
class ArenaResult;

enum Gladiatus_Type {
  Gladiatus_Type_WARRIOR = 0
};
bool Gladiatus_Type_IsValid(int value);
const Gladiatus_Type Gladiatus_Type_Type_MIN = Gladiatus_Type_WARRIOR;
const Gladiatus_Type Gladiatus_Type_Type_MAX = Gladiatus_Type_WARRIOR;
const int Gladiatus_Type_Type_ARRAYSIZE = Gladiatus_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Gladiatus_Type_descriptor();
inline const ::std::string& Gladiatus_Type_Name(Gladiatus_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Gladiatus_Type_descriptor(), value);
}
inline bool Gladiatus_Type_Parse(
    const ::std::string& name, Gladiatus_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Gladiatus_Type>(
    Gladiatus_Type_descriptor(), name, value);
}
enum Gladiatus_PartType {
  Gladiatus_PartType_BODY = 0,
  Gladiatus_PartType_HEAD = 1,
  Gladiatus_PartType_ARM = 2,
  Gladiatus_PartType_LEG = 3
};
bool Gladiatus_PartType_IsValid(int value);
const Gladiatus_PartType Gladiatus_PartType_PartType_MIN = Gladiatus_PartType_BODY;
const Gladiatus_PartType Gladiatus_PartType_PartType_MAX = Gladiatus_PartType_LEG;
const int Gladiatus_PartType_PartType_ARRAYSIZE = Gladiatus_PartType_PartType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Gladiatus_PartType_descriptor();
inline const ::std::string& Gladiatus_PartType_Name(Gladiatus_PartType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Gladiatus_PartType_descriptor(), value);
}
inline bool Gladiatus_PartType_Parse(
    const ::std::string& name, Gladiatus_PartType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Gladiatus_PartType>(
    Gladiatus_PartType_descriptor(), name, value);
}
enum Arena_AiType {
  Arena_AiType_SIMPLE = 0
};
bool Arena_AiType_IsValid(int value);
const Arena_AiType Arena_AiType_AiType_MIN = Arena_AiType_SIMPLE;
const Arena_AiType Arena_AiType_AiType_MAX = Arena_AiType_SIMPLE;
const int Arena_AiType_AiType_ARRAYSIZE = Arena_AiType_AiType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Arena_AiType_descriptor();
inline const ::std::string& Arena_AiType_Name(Arena_AiType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Arena_AiType_descriptor(), value);
}
inline bool Arena_AiType_Parse(
    const ::std::string& name, Arena_AiType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Arena_AiType>(
    Arena_AiType_descriptor(), name, value);
}
enum Version {
  MAJOR = 0,
  MINOR = 1
};
bool Version_IsValid(int value);
const Version Version_MIN = MAJOR;
const Version Version_MAX = MINOR;
const int Version_ARRAYSIZE = Version_MAX + 1;

const ::google::protobuf::EnumDescriptor* Version_descriptor();
inline const ::std::string& Version_Name(Version value) {
  return ::google::protobuf::internal::NameOfEnum(
    Version_descriptor(), value);
}
inline bool Version_Parse(
    const ::std::string& name, Version* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Version>(
    Version_descriptor(), name, value);
}
// ===================================================================

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // required string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:Scott.LoginRequest)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;
  ::std::string* account_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Scott_2eproto();
  friend void protobuf_AssignDesc_Scott_2eproto();
  friend void protobuf_ShutdownFile_Scott_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginReply : public ::google::protobuf::Message {
 public:
  LoginReply();
  virtual ~LoginReply();

  LoginReply(const LoginReply& from);

  inline LoginReply& operator=(const LoginReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReply& default_instance();

  void Swap(LoginReply* other);

  // implements Message ----------------------------------------------

  LoginReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginReply& from);
  void MergeFrom(const LoginReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Scott.LoginReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Scott_2eproto();
  friend void protobuf_AssignDesc_Scott_2eproto();
  friend void protobuf_ShutdownFile_Scott_2eproto();

  void InitAsDefaultInstance();
  static LoginReply* default_instance_;
};
// -------------------------------------------------------------------

class ChatRequest : public ::google::protobuf::Message {
 public:
  ChatRequest();
  virtual ~ChatRequest();

  ChatRequest(const ChatRequest& from);

  inline ChatRequest& operator=(const ChatRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatRequest& default_instance();

  void Swap(ChatRequest* other);

  // implements Message ----------------------------------------------

  ChatRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatRequest& from);
  void MergeFrom(const ChatRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string msg = 3;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 3;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // optional string target = 4;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 4;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  inline void set_allocated_target(::std::string* target);

  // @@protoc_insertion_point(class_scope:Scott.ChatRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_target();
  inline void clear_has_target();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* msg_;
  ::std::string* target_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Scott_2eproto();
  friend void protobuf_AssignDesc_Scott_2eproto();
  friend void protobuf_ShutdownFile_Scott_2eproto();

  void InitAsDefaultInstance();
  static ChatRequest* default_instance_;
};
// -------------------------------------------------------------------

class ChatReply : public ::google::protobuf::Message {
 public:
  ChatReply();
  virtual ~ChatReply();

  ChatReply(const ChatReply& from);

  inline ChatReply& operator=(const ChatReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatReply& default_instance();

  void Swap(ChatReply* other);

  // implements Message ----------------------------------------------

  ChatReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatReply& from);
  void MergeFrom(const ChatReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string msg = 3;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 3;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:Scott.ChatReply)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* msg_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Scott_2eproto();
  friend void protobuf_AssignDesc_Scott_2eproto();
  friend void protobuf_ShutdownFile_Scott_2eproto();

  void InitAsDefaultInstance();
  static ChatReply* default_instance_;
};
// -------------------------------------------------------------------

class Gladiatus_PartProperty : public ::google::protobuf::Message {
 public:
  Gladiatus_PartProperty();
  virtual ~Gladiatus_PartProperty();

  Gladiatus_PartProperty(const Gladiatus_PartProperty& from);

  inline Gladiatus_PartProperty& operator=(const Gladiatus_PartProperty& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Gladiatus_PartProperty& default_instance();

  void Swap(Gladiatus_PartProperty* other);

  // implements Message ----------------------------------------------

  Gladiatus_PartProperty* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Gladiatus_PartProperty& from);
  void MergeFrom(const Gladiatus_PartProperty& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 def = 1;
  inline bool has_def() const;
  inline void clear_def();
  static const int kDefFieldNumber = 1;
  inline ::google::protobuf::int32 def() const;
  inline void set_def(::google::protobuf::int32 value);

  // required int32 hp = 2;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 2;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Scott.Gladiatus.PartProperty)
 private:
  inline void set_has_def();
  inline void clear_has_def();
  inline void set_has_hp();
  inline void clear_has_hp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 def_;
  ::google::protobuf::int32 hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Scott_2eproto();
  friend void protobuf_AssignDesc_Scott_2eproto();
  friend void protobuf_ShutdownFile_Scott_2eproto();

  void InitAsDefaultInstance();
  static Gladiatus_PartProperty* default_instance_;
};
// -------------------------------------------------------------------

class Gladiatus : public ::google::protobuf::Message {
 public:
  Gladiatus();
  virtual ~Gladiatus();

  Gladiatus(const Gladiatus& from);

  inline Gladiatus& operator=(const Gladiatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Gladiatus& default_instance();

  void Swap(Gladiatus* other);

  // implements Message ----------------------------------------------

  Gladiatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Gladiatus& from);
  void MergeFrom(const Gladiatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Gladiatus_PartProperty PartProperty;

  typedef Gladiatus_Type Type;
  static const Type WARRIOR = Gladiatus_Type_WARRIOR;
  static inline bool Type_IsValid(int value) {
    return Gladiatus_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Gladiatus_Type_Type_MIN;
  static const Type Type_MAX =
    Gladiatus_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Gladiatus_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Gladiatus_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Gladiatus_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Gladiatus_Type_Parse(name, value);
  }

  typedef Gladiatus_PartType PartType;
  static const PartType BODY = Gladiatus_PartType_BODY;
  static const PartType HEAD = Gladiatus_PartType_HEAD;
  static const PartType ARM = Gladiatus_PartType_ARM;
  static const PartType LEG = Gladiatus_PartType_LEG;
  static inline bool PartType_IsValid(int value) {
    return Gladiatus_PartType_IsValid(value);
  }
  static const PartType PartType_MIN =
    Gladiatus_PartType_PartType_MIN;
  static const PartType PartType_MAX =
    Gladiatus_PartType_PartType_MAX;
  static const int PartType_ARRAYSIZE =
    Gladiatus_PartType_PartType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PartType_descriptor() {
    return Gladiatus_PartType_descriptor();
  }
  static inline const ::std::string& PartType_Name(PartType value) {
    return Gladiatus_PartType_Name(value);
  }
  static inline bool PartType_Parse(const ::std::string& name,
      PartType* value) {
    return Gladiatus_PartType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string guid = 1;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 1;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  inline void set_allocated_guid(::std::string* guid);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 speed = 3;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 3;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);

  // required int32 attack = 4;
  inline bool has_attack() const;
  inline void clear_attack();
  static const int kAttackFieldNumber = 4;
  inline ::google::protobuf::int32 attack() const;
  inline void set_attack(::google::protobuf::int32 value);

  // required .Scott.Gladiatus.Type type = 5 [default = WARRIOR];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::Scott::Gladiatus_Type type() const;
  inline void set_type(::Scott::Gladiatus_Type value);

  // repeated .Scott.Gladiatus.PartProperty parts = 6;
  inline int parts_size() const;
  inline void clear_parts();
  static const int kPartsFieldNumber = 6;
  inline const ::Scott::Gladiatus_PartProperty& parts(int index) const;
  inline ::Scott::Gladiatus_PartProperty* mutable_parts(int index);
  inline ::Scott::Gladiatus_PartProperty* add_parts();
  inline const ::google::protobuf::RepeatedPtrField< ::Scott::Gladiatus_PartProperty >&
      parts() const;
  inline ::google::protobuf::RepeatedPtrField< ::Scott::Gladiatus_PartProperty >*
      mutable_parts();

  // @@protoc_insertion_point(class_scope:Scott.Gladiatus)
 private:
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_attack();
  inline void clear_has_attack();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* guid_;
  ::std::string* name_;
  ::google::protobuf::int32 speed_;
  ::google::protobuf::int32 attack_;
  ::google::protobuf::RepeatedPtrField< ::Scott::Gladiatus_PartProperty > parts_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Scott_2eproto();
  friend void protobuf_AssignDesc_Scott_2eproto();
  friend void protobuf_ShutdownFile_Scott_2eproto();

  void InitAsDefaultInstance();
  static Gladiatus* default_instance_;
};
// -------------------------------------------------------------------

class Player : public ::google::protobuf::Message {
 public:
  Player();
  virtual ~Player();

  Player(const Player& from);

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Player& default_instance();

  void Swap(Player* other);

  // implements Message ----------------------------------------------

  Player* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string guid = 1;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 1;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  inline void set_allocated_guid(::std::string* guid);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .Scott.Gladiatus gladiatus = 3;
  inline int gladiatus_size() const;
  inline void clear_gladiatus();
  static const int kGladiatusFieldNumber = 3;
  inline const ::Scott::Gladiatus& gladiatus(int index) const;
  inline ::Scott::Gladiatus* mutable_gladiatus(int index);
  inline ::Scott::Gladiatus* add_gladiatus();
  inline const ::google::protobuf::RepeatedPtrField< ::Scott::Gladiatus >&
      gladiatus() const;
  inline ::google::protobuf::RepeatedPtrField< ::Scott::Gladiatus >*
      mutable_gladiatus();

  // @@protoc_insertion_point(class_scope:Scott.Player)
 private:
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* guid_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::Scott::Gladiatus > gladiatus_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Scott_2eproto();
  friend void protobuf_AssignDesc_Scott_2eproto();
  friend void protobuf_ShutdownFile_Scott_2eproto();

  void InitAsDefaultInstance();
  static Player* default_instance_;
};
// -------------------------------------------------------------------

class Arena : public ::google::protobuf::Message {
 public:
  Arena();
  virtual ~Arena();

  Arena(const Arena& from);

  inline Arena& operator=(const Arena& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Arena& default_instance();

  void Swap(Arena* other);

  // implements Message ----------------------------------------------

  Arena* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Arena& from);
  void MergeFrom(const Arena& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Arena_AiType AiType;
  static const AiType SIMPLE = Arena_AiType_SIMPLE;
  static inline bool AiType_IsValid(int value) {
    return Arena_AiType_IsValid(value);
  }
  static const AiType AiType_MIN =
    Arena_AiType_AiType_MIN;
  static const AiType AiType_MAX =
    Arena_AiType_AiType_MAX;
  static const int AiType_ARRAYSIZE =
    Arena_AiType_AiType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AiType_descriptor() {
    return Arena_AiType_descriptor();
  }
  static inline const ::std::string& AiType_Name(AiType value) {
    return Arena_AiType_Name(value);
  }
  static inline bool AiType_Parse(const ::std::string& name,
      AiType* value) {
    return Arena_AiType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string guid = 1;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 1;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  inline void set_allocated_guid(::std::string* guid);

  // repeated string gladiatus = 2;
  inline int gladiatus_size() const;
  inline void clear_gladiatus();
  static const int kGladiatusFieldNumber = 2;
  inline const ::std::string& gladiatus(int index) const;
  inline ::std::string* mutable_gladiatus(int index);
  inline void set_gladiatus(int index, const ::std::string& value);
  inline void set_gladiatus(int index, const char* value);
  inline void set_gladiatus(int index, const char* value, size_t size);
  inline ::std::string* add_gladiatus();
  inline void add_gladiatus(const ::std::string& value);
  inline void add_gladiatus(const char* value);
  inline void add_gladiatus(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& gladiatus() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_gladiatus();

  // repeated .Scott.Gladiatus enemies = 3;
  inline int enemies_size() const;
  inline void clear_enemies();
  static const int kEnemiesFieldNumber = 3;
  inline const ::Scott::Gladiatus& enemies(int index) const;
  inline ::Scott::Gladiatus* mutable_enemies(int index);
  inline ::Scott::Gladiatus* add_enemies();
  inline const ::google::protobuf::RepeatedPtrField< ::Scott::Gladiatus >&
      enemies() const;
  inline ::google::protobuf::RepeatedPtrField< ::Scott::Gladiatus >*
      mutable_enemies();

  // required .Scott.Arena.AiType ai_type = 4;
  inline bool has_ai_type() const;
  inline void clear_ai_type();
  static const int kAiTypeFieldNumber = 4;
  inline ::Scott::Arena_AiType ai_type() const;
  inline void set_ai_type(::Scott::Arena_AiType value);

  // required bytes ai_data = 5;
  inline bool has_ai_data() const;
  inline void clear_ai_data();
  static const int kAiDataFieldNumber = 5;
  inline const ::std::string& ai_data() const;
  inline void set_ai_data(const ::std::string& value);
  inline void set_ai_data(const char* value);
  inline void set_ai_data(const void* value, size_t size);
  inline ::std::string* mutable_ai_data();
  inline ::std::string* release_ai_data();
  inline void set_allocated_ai_data(::std::string* ai_data);

  // @@protoc_insertion_point(class_scope:Scott.Arena)
 private:
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_ai_type();
  inline void clear_has_ai_type();
  inline void set_has_ai_data();
  inline void clear_has_ai_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* guid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> gladiatus_;
  ::google::protobuf::RepeatedPtrField< ::Scott::Gladiatus > enemies_;
  ::std::string* ai_data_;
  int ai_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Scott_2eproto();
  friend void protobuf_AssignDesc_Scott_2eproto();
  friend void protobuf_ShutdownFile_Scott_2eproto();

  void InitAsDefaultInstance();
  static Arena* default_instance_;
};
// -------------------------------------------------------------------

class ArenaOperations_Operation : public ::google::protobuf::Message {
 public:
  ArenaOperations_Operation();
  virtual ~ArenaOperations_Operation();

  ArenaOperations_Operation(const ArenaOperations_Operation& from);

  inline ArenaOperations_Operation& operator=(const ArenaOperations_Operation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArenaOperations_Operation& default_instance();

  void Swap(ArenaOperations_Operation* other);

  // implements Message ----------------------------------------------

  ArenaOperations_Operation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArenaOperations_Operation& from);
  void MergeFrom(const ArenaOperations_Operation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 op_index = 1;
  inline bool has_op_index() const;
  inline void clear_op_index();
  static const int kOpIndexFieldNumber = 1;
  inline ::google::protobuf::int32 op_index() const;
  inline void set_op_index(::google::protobuf::int32 value);

  // required int32 target_index = 2;
  inline bool has_target_index() const;
  inline void clear_target_index();
  static const int kTargetIndexFieldNumber = 2;
  inline ::google::protobuf::int32 target_index() const;
  inline void set_target_index(::google::protobuf::int32 value);

  // required .Scott.Gladiatus.PartType part = 3;
  inline bool has_part() const;
  inline void clear_part();
  static const int kPartFieldNumber = 3;
  inline ::Scott::Gladiatus_PartType part() const;
  inline void set_part(::Scott::Gladiatus_PartType value);

  // @@protoc_insertion_point(class_scope:Scott.ArenaOperations.Operation)
 private:
  inline void set_has_op_index();
  inline void clear_has_op_index();
  inline void set_has_target_index();
  inline void clear_has_target_index();
  inline void set_has_part();
  inline void clear_has_part();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 op_index_;
  ::google::protobuf::int32 target_index_;
  int part_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Scott_2eproto();
  friend void protobuf_AssignDesc_Scott_2eproto();
  friend void protobuf_ShutdownFile_Scott_2eproto();

  void InitAsDefaultInstance();
  static ArenaOperations_Operation* default_instance_;
};
// -------------------------------------------------------------------

class ArenaOperations : public ::google::protobuf::Message {
 public:
  ArenaOperations();
  virtual ~ArenaOperations();

  ArenaOperations(const ArenaOperations& from);

  inline ArenaOperations& operator=(const ArenaOperations& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArenaOperations& default_instance();

  void Swap(ArenaOperations* other);

  // implements Message ----------------------------------------------

  ArenaOperations* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArenaOperations& from);
  void MergeFrom(const ArenaOperations& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ArenaOperations_Operation Operation;

  // accessors -------------------------------------------------------

  // required string guid = 1;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 1;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  inline void set_allocated_guid(::std::string* guid);

  // repeated .Scott.ArenaOperations.Operation operations = 2;
  inline int operations_size() const;
  inline void clear_operations();
  static const int kOperationsFieldNumber = 2;
  inline const ::Scott::ArenaOperations_Operation& operations(int index) const;
  inline ::Scott::ArenaOperations_Operation* mutable_operations(int index);
  inline ::Scott::ArenaOperations_Operation* add_operations();
  inline const ::google::protobuf::RepeatedPtrField< ::Scott::ArenaOperations_Operation >&
      operations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Scott::ArenaOperations_Operation >*
      mutable_operations();

  // @@protoc_insertion_point(class_scope:Scott.ArenaOperations)
 private:
  inline void set_has_guid();
  inline void clear_has_guid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* guid_;
  ::google::protobuf::RepeatedPtrField< ::Scott::ArenaOperations_Operation > operations_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Scott_2eproto();
  friend void protobuf_AssignDesc_Scott_2eproto();
  friend void protobuf_ShutdownFile_Scott_2eproto();

  void InitAsDefaultInstance();
  static ArenaOperations* default_instance_;
};
// -------------------------------------------------------------------

class ArenaResult : public ::google::protobuf::Message {
 public:
  ArenaResult();
  virtual ~ArenaResult();

  ArenaResult(const ArenaResult& from);

  inline ArenaResult& operator=(const ArenaResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArenaResult& default_instance();

  void Swap(ArenaResult* other);

  // implements Message ----------------------------------------------

  ArenaResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArenaResult& from);
  void MergeFrom(const ArenaResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Scott.ArenaResult)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Scott_2eproto();
  friend void protobuf_AssignDesc_Scott_2eproto();
  friend void protobuf_ShutdownFile_Scott_2eproto();

  void InitAsDefaultInstance();
  static ArenaResult* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// required string version = 1;
inline bool LoginRequest::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& LoginRequest::version() const {
  return *version_;
}
inline void LoginRequest::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginRequest::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginRequest::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* LoginRequest::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string account = 2;
inline bool LoginRequest::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& LoginRequest::account() const {
  return *account_;
}
inline void LoginRequest::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void LoginRequest::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void LoginRequest::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* LoginRequest::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 3;
inline bool LoginRequest::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginRequest::password() const {
  return *password_;
}
inline void LoginRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginReply

// required int32 result = 1;
inline bool LoginReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReply::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 LoginReply::result() const {
  return result_;
}
inline void LoginReply::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// ChatRequest

// required int32 type = 1;
inline bool ChatRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ChatRequest::type() const {
  return type_;
}
inline void ChatRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string name = 2;
inline bool ChatRequest::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatRequest::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ChatRequest::name() const {
  return *name_;
}
inline void ChatRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ChatRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ChatRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ChatRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string msg = 3;
inline bool ChatRequest::has_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatRequest::set_has_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatRequest::clear_has_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatRequest::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& ChatRequest::msg() const {
  return *msg_;
}
inline void ChatRequest::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ChatRequest::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ChatRequest::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatRequest::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* ChatRequest::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatRequest::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string target = 4;
inline bool ChatRequest::has_target() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChatRequest::set_has_target() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChatRequest::clear_has_target() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChatRequest::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& ChatRequest::target() const {
  return *target_;
}
inline void ChatRequest::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void ChatRequest::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void ChatRequest::set_target(const char* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatRequest::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* ChatRequest::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatRequest::set_allocated_target(::std::string* target) {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (target) {
    set_has_target();
    target_ = target;
  } else {
    clear_has_target();
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChatReply

// required int32 type = 1;
inline bool ChatReply::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatReply::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatReply::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatReply::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ChatReply::type() const {
  return type_;
}
inline void ChatReply::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string name = 2;
inline bool ChatReply::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatReply::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatReply::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatReply::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ChatReply::name() const {
  return *name_;
}
inline void ChatReply::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ChatReply::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ChatReply::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatReply::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ChatReply::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatReply::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string msg = 3;
inline bool ChatReply::has_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatReply::set_has_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatReply::clear_has_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatReply::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& ChatReply::msg() const {
  return *msg_;
}
inline void ChatReply::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ChatReply::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ChatReply::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatReply::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* ChatReply::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatReply::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Gladiatus_PartProperty

// required int32 def = 1;
inline bool Gladiatus_PartProperty::has_def() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Gladiatus_PartProperty::set_has_def() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Gladiatus_PartProperty::clear_has_def() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Gladiatus_PartProperty::clear_def() {
  def_ = 0;
  clear_has_def();
}
inline ::google::protobuf::int32 Gladiatus_PartProperty::def() const {
  return def_;
}
inline void Gladiatus_PartProperty::set_def(::google::protobuf::int32 value) {
  set_has_def();
  def_ = value;
}

// required int32 hp = 2;
inline bool Gladiatus_PartProperty::has_hp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Gladiatus_PartProperty::set_has_hp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Gladiatus_PartProperty::clear_has_hp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Gladiatus_PartProperty::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 Gladiatus_PartProperty::hp() const {
  return hp_;
}
inline void Gladiatus_PartProperty::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// -------------------------------------------------------------------

// Gladiatus

// required string guid = 1;
inline bool Gladiatus::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Gladiatus::set_has_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Gladiatus::clear_has_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Gladiatus::clear_guid() {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    guid_->clear();
  }
  clear_has_guid();
}
inline const ::std::string& Gladiatus::guid() const {
  return *guid_;
}
inline void Gladiatus::set_guid(const ::std::string& value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void Gladiatus::set_guid(const char* value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void Gladiatus::set_guid(const char* value, size_t size) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Gladiatus::mutable_guid() {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  return guid_;
}
inline ::std::string* Gladiatus::release_guid() {
  clear_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guid_;
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Gladiatus::set_allocated_guid(::std::string* guid) {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    delete guid_;
  }
  if (guid) {
    set_has_guid();
    guid_ = guid;
  } else {
    clear_has_guid();
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 2;
inline bool Gladiatus::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Gladiatus::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Gladiatus::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Gladiatus::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Gladiatus::name() const {
  return *name_;
}
inline void Gladiatus::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Gladiatus::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Gladiatus::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Gladiatus::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Gladiatus::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Gladiatus::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 speed = 3;
inline bool Gladiatus::has_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Gladiatus::set_has_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Gladiatus::clear_has_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Gladiatus::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline ::google::protobuf::int32 Gladiatus::speed() const {
  return speed_;
}
inline void Gladiatus::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
}

// required int32 attack = 4;
inline bool Gladiatus::has_attack() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Gladiatus::set_has_attack() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Gladiatus::clear_has_attack() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Gladiatus::clear_attack() {
  attack_ = 0;
  clear_has_attack();
}
inline ::google::protobuf::int32 Gladiatus::attack() const {
  return attack_;
}
inline void Gladiatus::set_attack(::google::protobuf::int32 value) {
  set_has_attack();
  attack_ = value;
}

// required .Scott.Gladiatus.Type type = 5 [default = WARRIOR];
inline bool Gladiatus::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Gladiatus::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Gladiatus::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Gladiatus::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Scott::Gladiatus_Type Gladiatus::type() const {
  return static_cast< ::Scott::Gladiatus_Type >(type_);
}
inline void Gladiatus::set_type(::Scott::Gladiatus_Type value) {
  assert(::Scott::Gladiatus_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .Scott.Gladiatus.PartProperty parts = 6;
inline int Gladiatus::parts_size() const {
  return parts_.size();
}
inline void Gladiatus::clear_parts() {
  parts_.Clear();
}
inline const ::Scott::Gladiatus_PartProperty& Gladiatus::parts(int index) const {
  return parts_.Get(index);
}
inline ::Scott::Gladiatus_PartProperty* Gladiatus::mutable_parts(int index) {
  return parts_.Mutable(index);
}
inline ::Scott::Gladiatus_PartProperty* Gladiatus::add_parts() {
  return parts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Scott::Gladiatus_PartProperty >&
Gladiatus::parts() const {
  return parts_;
}
inline ::google::protobuf::RepeatedPtrField< ::Scott::Gladiatus_PartProperty >*
Gladiatus::mutable_parts() {
  return &parts_;
}

// -------------------------------------------------------------------

// Player

// required string guid = 1;
inline bool Player::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Player::set_has_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Player::clear_has_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Player::clear_guid() {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    guid_->clear();
  }
  clear_has_guid();
}
inline const ::std::string& Player::guid() const {
  return *guid_;
}
inline void Player::set_guid(const ::std::string& value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void Player::set_guid(const char* value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void Player::set_guid(const char* value, size_t size) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Player::mutable_guid() {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  return guid_;
}
inline ::std::string* Player::release_guid() {
  clear_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guid_;
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Player::set_allocated_guid(::std::string* guid) {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    delete guid_;
  }
  if (guid) {
    set_has_guid();
    guid_ = guid;
  } else {
    clear_has_guid();
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 2;
inline bool Player::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Player::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Player::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Player::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Player::name() const {
  return *name_;
}
inline void Player::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Player::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Player::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Player::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Player::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Player::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Scott.Gladiatus gladiatus = 3;
inline int Player::gladiatus_size() const {
  return gladiatus_.size();
}
inline void Player::clear_gladiatus() {
  gladiatus_.Clear();
}
inline const ::Scott::Gladiatus& Player::gladiatus(int index) const {
  return gladiatus_.Get(index);
}
inline ::Scott::Gladiatus* Player::mutable_gladiatus(int index) {
  return gladiatus_.Mutable(index);
}
inline ::Scott::Gladiatus* Player::add_gladiatus() {
  return gladiatus_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Scott::Gladiatus >&
Player::gladiatus() const {
  return gladiatus_;
}
inline ::google::protobuf::RepeatedPtrField< ::Scott::Gladiatus >*
Player::mutable_gladiatus() {
  return &gladiatus_;
}

// -------------------------------------------------------------------

// Arena

// required string guid = 1;
inline bool Arena::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Arena::set_has_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Arena::clear_has_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Arena::clear_guid() {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    guid_->clear();
  }
  clear_has_guid();
}
inline const ::std::string& Arena::guid() const {
  return *guid_;
}
inline void Arena::set_guid(const ::std::string& value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void Arena::set_guid(const char* value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void Arena::set_guid(const char* value, size_t size) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Arena::mutable_guid() {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  return guid_;
}
inline ::std::string* Arena::release_guid() {
  clear_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guid_;
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Arena::set_allocated_guid(::std::string* guid) {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    delete guid_;
  }
  if (guid) {
    set_has_guid();
    guid_ = guid;
  } else {
    clear_has_guid();
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string gladiatus = 2;
inline int Arena::gladiatus_size() const {
  return gladiatus_.size();
}
inline void Arena::clear_gladiatus() {
  gladiatus_.Clear();
}
inline const ::std::string& Arena::gladiatus(int index) const {
  return gladiatus_.Get(index);
}
inline ::std::string* Arena::mutable_gladiatus(int index) {
  return gladiatus_.Mutable(index);
}
inline void Arena::set_gladiatus(int index, const ::std::string& value) {
  gladiatus_.Mutable(index)->assign(value);
}
inline void Arena::set_gladiatus(int index, const char* value) {
  gladiatus_.Mutable(index)->assign(value);
}
inline void Arena::set_gladiatus(int index, const char* value, size_t size) {
  gladiatus_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Arena::add_gladiatus() {
  return gladiatus_.Add();
}
inline void Arena::add_gladiatus(const ::std::string& value) {
  gladiatus_.Add()->assign(value);
}
inline void Arena::add_gladiatus(const char* value) {
  gladiatus_.Add()->assign(value);
}
inline void Arena::add_gladiatus(const char* value, size_t size) {
  gladiatus_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Arena::gladiatus() const {
  return gladiatus_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Arena::mutable_gladiatus() {
  return &gladiatus_;
}

// repeated .Scott.Gladiatus enemies = 3;
inline int Arena::enemies_size() const {
  return enemies_.size();
}
inline void Arena::clear_enemies() {
  enemies_.Clear();
}
inline const ::Scott::Gladiatus& Arena::enemies(int index) const {
  return enemies_.Get(index);
}
inline ::Scott::Gladiatus* Arena::mutable_enemies(int index) {
  return enemies_.Mutable(index);
}
inline ::Scott::Gladiatus* Arena::add_enemies() {
  return enemies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Scott::Gladiatus >&
Arena::enemies() const {
  return enemies_;
}
inline ::google::protobuf::RepeatedPtrField< ::Scott::Gladiatus >*
Arena::mutable_enemies() {
  return &enemies_;
}

// required .Scott.Arena.AiType ai_type = 4;
inline bool Arena::has_ai_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Arena::set_has_ai_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Arena::clear_has_ai_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Arena::clear_ai_type() {
  ai_type_ = 0;
  clear_has_ai_type();
}
inline ::Scott::Arena_AiType Arena::ai_type() const {
  return static_cast< ::Scott::Arena_AiType >(ai_type_);
}
inline void Arena::set_ai_type(::Scott::Arena_AiType value) {
  assert(::Scott::Arena_AiType_IsValid(value));
  set_has_ai_type();
  ai_type_ = value;
}

// required bytes ai_data = 5;
inline bool Arena::has_ai_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Arena::set_has_ai_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Arena::clear_has_ai_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Arena::clear_ai_data() {
  if (ai_data_ != &::google::protobuf::internal::kEmptyString) {
    ai_data_->clear();
  }
  clear_has_ai_data();
}
inline const ::std::string& Arena::ai_data() const {
  return *ai_data_;
}
inline void Arena::set_ai_data(const ::std::string& value) {
  set_has_ai_data();
  if (ai_data_ == &::google::protobuf::internal::kEmptyString) {
    ai_data_ = new ::std::string;
  }
  ai_data_->assign(value);
}
inline void Arena::set_ai_data(const char* value) {
  set_has_ai_data();
  if (ai_data_ == &::google::protobuf::internal::kEmptyString) {
    ai_data_ = new ::std::string;
  }
  ai_data_->assign(value);
}
inline void Arena::set_ai_data(const void* value, size_t size) {
  set_has_ai_data();
  if (ai_data_ == &::google::protobuf::internal::kEmptyString) {
    ai_data_ = new ::std::string;
  }
  ai_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Arena::mutable_ai_data() {
  set_has_ai_data();
  if (ai_data_ == &::google::protobuf::internal::kEmptyString) {
    ai_data_ = new ::std::string;
  }
  return ai_data_;
}
inline ::std::string* Arena::release_ai_data() {
  clear_has_ai_data();
  if (ai_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ai_data_;
    ai_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Arena::set_allocated_ai_data(::std::string* ai_data) {
  if (ai_data_ != &::google::protobuf::internal::kEmptyString) {
    delete ai_data_;
  }
  if (ai_data) {
    set_has_ai_data();
    ai_data_ = ai_data;
  } else {
    clear_has_ai_data();
    ai_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ArenaOperations_Operation

// required int32 op_index = 1;
inline bool ArenaOperations_Operation::has_op_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaOperations_Operation::set_has_op_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaOperations_Operation::clear_has_op_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaOperations_Operation::clear_op_index() {
  op_index_ = 0;
  clear_has_op_index();
}
inline ::google::protobuf::int32 ArenaOperations_Operation::op_index() const {
  return op_index_;
}
inline void ArenaOperations_Operation::set_op_index(::google::protobuf::int32 value) {
  set_has_op_index();
  op_index_ = value;
}

// required int32 target_index = 2;
inline bool ArenaOperations_Operation::has_target_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArenaOperations_Operation::set_has_target_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArenaOperations_Operation::clear_has_target_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArenaOperations_Operation::clear_target_index() {
  target_index_ = 0;
  clear_has_target_index();
}
inline ::google::protobuf::int32 ArenaOperations_Operation::target_index() const {
  return target_index_;
}
inline void ArenaOperations_Operation::set_target_index(::google::protobuf::int32 value) {
  set_has_target_index();
  target_index_ = value;
}

// required .Scott.Gladiatus.PartType part = 3;
inline bool ArenaOperations_Operation::has_part() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArenaOperations_Operation::set_has_part() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArenaOperations_Operation::clear_has_part() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArenaOperations_Operation::clear_part() {
  part_ = 0;
  clear_has_part();
}
inline ::Scott::Gladiatus_PartType ArenaOperations_Operation::part() const {
  return static_cast< ::Scott::Gladiatus_PartType >(part_);
}
inline void ArenaOperations_Operation::set_part(::Scott::Gladiatus_PartType value) {
  assert(::Scott::Gladiatus_PartType_IsValid(value));
  set_has_part();
  part_ = value;
}

// -------------------------------------------------------------------

// ArenaOperations

// required string guid = 1;
inline bool ArenaOperations::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaOperations::set_has_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaOperations::clear_has_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaOperations::clear_guid() {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    guid_->clear();
  }
  clear_has_guid();
}
inline const ::std::string& ArenaOperations::guid() const {
  return *guid_;
}
inline void ArenaOperations::set_guid(const ::std::string& value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void ArenaOperations::set_guid(const char* value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void ArenaOperations::set_guid(const char* value, size_t size) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ArenaOperations::mutable_guid() {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  return guid_;
}
inline ::std::string* ArenaOperations::release_guid() {
  clear_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guid_;
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ArenaOperations::set_allocated_guid(::std::string* guid) {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    delete guid_;
  }
  if (guid) {
    set_has_guid();
    guid_ = guid;
  } else {
    clear_has_guid();
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Scott.ArenaOperations.Operation operations = 2;
inline int ArenaOperations::operations_size() const {
  return operations_.size();
}
inline void ArenaOperations::clear_operations() {
  operations_.Clear();
}
inline const ::Scott::ArenaOperations_Operation& ArenaOperations::operations(int index) const {
  return operations_.Get(index);
}
inline ::Scott::ArenaOperations_Operation* ArenaOperations::mutable_operations(int index) {
  return operations_.Mutable(index);
}
inline ::Scott::ArenaOperations_Operation* ArenaOperations::add_operations() {
  return operations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Scott::ArenaOperations_Operation >&
ArenaOperations::operations() const {
  return operations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Scott::ArenaOperations_Operation >*
ArenaOperations::mutable_operations() {
  return &operations_;
}

// -------------------------------------------------------------------

// ArenaResult

// required int32 result = 1;
inline bool ArenaResult::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaResult::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaResult::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ArenaResult::result() const {
  return result_;
}
inline void ArenaResult::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Scott

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Scott::Gladiatus_Type>() {
  return ::Scott::Gladiatus_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Scott::Gladiatus_PartType>() {
  return ::Scott::Gladiatus_PartType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Scott::Arena_AiType>() {
  return ::Scott::Arena_AiType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Scott::Version>() {
  return ::Scott::Version_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Scott_2eproto__INCLUDED
