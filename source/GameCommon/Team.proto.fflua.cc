// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Team.proto
#include "Team.pb.h"
#include "Team.proto.fflua.h"
namespace Packet {
bool PurposeInfo_fflua_reg(lua_State* state)
{
//for decltype
	PurposeInfo* message(nullptr);
	message;
	ff::fflua_register_t<PurposeInfo, ctor()>(state, "PurposeInfo", "google::protobuf::Message")
		// required int32 purpose = 1;
		.def(&PurposeInfo::purpose, "purpose")
		.def(&PurposeInfo::set_purpose, "set_purpose")
		// required int32 level_limt_min = 2;
		.def(&PurposeInfo::level_limt_min, "level_limt_min")
		.def(&PurposeInfo::set_level_limt_min, "set_level_limt_min")
		// required int32 level_limt_max = 3;
		.def(&PurposeInfo::level_limt_max, "level_limt_max")
		.def(&PurposeInfo::set_level_limt_max, "set_level_limt_max")
		.def(&PurposeInfo::ByteSize, "ByteSize")
		.def(&PurposeInfo::SetInitialized, "SetInitialized")
		;
	return true;
}
bool TeamPlayerBasicInfo_fflua_reg(lua_State* state)
{
//for decltype
	TeamPlayerBasicInfo* message(nullptr);
	message;
	ff::fflua_register_t<TeamPlayerBasicInfo, ctor()>(state, "TeamPlayerBasicInfo", "google::protobuf::Message")
		// required .Packet.PlayerTeamStatus playerstatus = 1;
		.def(&TeamPlayerBasicInfo::playerstatus, "playerstatus")
		.def(&TeamPlayerBasicInfo::set_playerstatus, "set_playerstatus")
		// required int32 position_index = 2;
		.def(&TeamPlayerBasicInfo::position_index, "position_index")
		.def(&TeamPlayerBasicInfo::set_position_index, "set_position_index")
		// required int32 hero_position = 3;
		.def(&TeamPlayerBasicInfo::hero_position, "hero_position")
		.def(&TeamPlayerBasicInfo::set_hero_position, "set_hero_position")
		.def(&TeamPlayerBasicInfo::ByteSize, "ByteSize")
		.def(&TeamPlayerBasicInfo::SetInitialized, "SetInitialized")
		;
	return true;
}
bool TeamPlayerInfo_fflua_reg(lua_State* state)
{
//for decltype
	TeamPlayerInfo* message(nullptr);
	message;
	ff::fflua_register_t<TeamPlayerInfo, ctor()>(state, "TeamPlayerInfo", "google::protobuf::Message")
		// required fixed64 playerguid = 1;
		.def(&TeamPlayerInfo::playerguid, "playerguid")
		.def(&TeamPlayerInfo::set_playerguid, "set_playerguid")
		// required .Packet.TeamPlayerBasicInfo teambaseinfo = 2;
		.def(&TeamPlayerInfo::teambaseinfo, "teambaseinfo")
		.def(&TeamPlayerInfo::mutable_teambaseinfo, "mutable_teambaseinfo")
		// optional .Packet.PlayerBasicInfo basic_info = 3;
		.def(&TeamPlayerInfo::basic_info, "basic_info")
		.def(&TeamPlayerInfo::mutable_basic_info, "mutable_basic_info")
		.def(&TeamPlayerInfo::has_basic_info, "has_basic_info")
		// optional bool is_robot = 4;
		.def(&TeamPlayerInfo::is_robot, "is_robot")
		.def(&TeamPlayerInfo::set_is_robot, "set_is_robot")
		.def(&TeamPlayerInfo::has_is_robot, "has_is_robot")
		.def(&TeamPlayerInfo::ByteSize, "ByteSize")
		.def(&TeamPlayerInfo::SetInitialized, "SetInitialized")
		;
	return true;
}
bool SetTeamHeroPositionReq_fflua_reg(lua_State* state)
{
//for decltype
	SetTeamHeroPositionReq* message(nullptr);
	message;
	ff::fflua_register_t<SetTeamHeroPositionReq, ctor()>(state, "SetTeamHeroPositionReq", "google::protobuf::Message")
		// required int32 position_index = 1;
		.def(&SetTeamHeroPositionReq::position_index, "position_index")
		.def(&SetTeamHeroPositionReq::set_position_index, "set_position_index")
		// required int32 hero_position = 2;
		.def(&SetTeamHeroPositionReq::hero_position, "hero_position")
		.def(&SetTeamHeroPositionReq::set_hero_position, "set_hero_position")
		.def(&SetTeamHeroPositionReq::ByteSize, "ByteSize")
		.def(&SetTeamHeroPositionReq::SetInitialized, "SetInitialized")
		;
	return true;
}
bool SetTeamHeroPositionReply_fflua_reg(lua_State* state)
{
//for decltype
	SetTeamHeroPositionReply* message(nullptr);
	message;
	ff::fflua_register_t<SetTeamHeroPositionReply, ctor()>(state, "SetTeamHeroPositionReply", "google::protobuf::Message")
		// required int32 position_index = 1;
		.def(&SetTeamHeroPositionReply::position_index, "position_index")
		.def(&SetTeamHeroPositionReply::set_position_index, "set_position_index")
		// required int32 hero_position = 2;
		.def(&SetTeamHeroPositionReply::hero_position, "hero_position")
		.def(&SetTeamHeroPositionReply::set_hero_position, "set_hero_position")
		.def(&SetTeamHeroPositionReply::ByteSize, "ByteSize")
		.def(&SetTeamHeroPositionReply::SetInitialized, "SetInitialized")
		;
	return true;
}
bool TeamInfo_fflua_reg(lua_State* state)
{
//for decltype
	TeamInfo* message(nullptr);
	message;
	ff::fflua_register_t<TeamInfo, ctor()>(state, "TeamInfo", "google::protobuf::Message")
		// required fixed64 guid = 1;
		.def(&TeamInfo::guid, "guid")
		.def(&TeamInfo::set_guid, "set_guid")
		// repeated .Packet.TeamPlayerInfo member = 2;
		.def(&TeamInfo::member_size, "member_size")
		.def<decltype(message->member(0)) (TeamInfo::*)(int) const>(&TeamInfo::member, "member")
		.def<decltype(message->mutable_member(0)) (TeamInfo::*)(int)>(&TeamInfo::mutable_member, "mutable_member")
		.def(&TeamInfo::add_member, "add_member")
		// required bool group = 3;
		.def(&TeamInfo::group, "group")
		.def(&TeamInfo::set_group, "set_group")
		// required .Packet.ArrangeType arrangetype = 4;
		.def(&TeamInfo::arrangetype, "arrangetype")
		.def(&TeamInfo::set_arrangetype, "set_arrangetype")
		// required fixed64 leader = 5;
		.def(&TeamInfo::leader, "leader")
		.def(&TeamInfo::set_leader, "set_leader")
		// required fixed64 applyleader = 6;
		.def(&TeamInfo::applyleader, "applyleader")
		.def(&TeamInfo::set_applyleader, "set_applyleader")
		// required bool agreeapplyleader = 7;
		.def(&TeamInfo::agreeapplyleader, "agreeapplyleader")
		.def(&TeamInfo::set_agreeapplyleader, "set_agreeapplyleader")
		// required int32 agreeapplytime = 8;
		.def(&TeamInfo::agreeapplytime, "agreeapplytime")
		.def(&TeamInfo::set_agreeapplytime, "set_agreeapplytime")
		// required bool auto_match = 9;
		.def(&TeamInfo::auto_match, "auto_match")
		.def(&TeamInfo::set_auto_match, "set_auto_match")
		// repeated fixed64 applylist = 10;
		.def(&TeamInfo::applylist_size, "applylist_size")
		.def<decltype(message->applylist(0)) (TeamInfo::*)(int) const>(&TeamInfo::applylist, "applylist")
		.def<void(TeamInfo::*)(int, const decltype(message->applylist(0)))>(&TeamInfo::set_applylist, "set_applylist")
		.def(&TeamInfo::add_applylist, "add_applylist")
		// required .Packet.PurposeInfo purpose = 11;
		.def(&TeamInfo::purpose, "purpose")
		.def(&TeamInfo::mutable_purpose, "mutable_purpose")
		// required bool setposition = 12;
		.def(&TeamInfo::setposition, "setposition")
		.def(&TeamInfo::set_setposition, "set_setposition")
		// optional bool robot_team = 13;
		.def(&TeamInfo::robot_team, "robot_team")
		.def(&TeamInfo::set_robot_team, "set_robot_team")
		.def(&TeamInfo::has_robot_team, "has_robot_team")
		.def(&TeamInfo::ByteSize, "ByteSize")
		.def(&TeamInfo::SetInitialized, "SetInitialized")
		;
	return true;
}
bool CreateTeam_fflua_reg(lua_State* state)
{
//for decltype
	CreateTeam* message(nullptr);
	message;
	ff::fflua_register_t<CreateTeam, ctor()>(state, "CreateTeam", "google::protobuf::Message");
	return true;
}
bool CreateRobotTeam_fflua_reg(lua_State* state)
{
//for decltype
	CreateRobotTeam* message(nullptr);
	message;
	ff::fflua_register_t<CreateRobotTeam, ctor()>(state, "CreateRobotTeam", "google::protobuf::Message")
		// repeated .Packet.PlayerBasicInfo basic_info = 1;
		.def(&CreateRobotTeam::basic_info_size, "basic_info_size")
		.def<decltype(message->basic_info(0)) (CreateRobotTeam::*)(int) const>(&CreateRobotTeam::basic_info, "basic_info")
		.def<decltype(message->mutable_basic_info(0)) (CreateRobotTeam::*)(int)>(&CreateRobotTeam::mutable_basic_info, "mutable_basic_info")
		.def(&CreateRobotTeam::add_basic_info, "add_basic_info")
		// repeated int32 one_key_id = 2;
		.def(&CreateRobotTeam::one_key_id_size, "one_key_id_size")
		.def<decltype(message->one_key_id(0)) (CreateRobotTeam::*)(int) const>(&CreateRobotTeam::one_key_id, "one_key_id")
		.def<void(CreateRobotTeam::*)(int, const decltype(message->one_key_id(0)))>(&CreateRobotTeam::set_one_key_id, "set_one_key_id")
		.def(&CreateRobotTeam::add_one_key_id, "add_one_key_id")
		.def(&CreateRobotTeam::ByteSize, "ByteSize")
		.def(&CreateRobotTeam::SetInitialized, "SetInitialized")
		;
	return true;
}
bool DelTeam_fflua_reg(lua_State* state)
{
//for decltype
	DelTeam* message(nullptr);
	message;
	ff::fflua_register_t<DelTeam, ctor()>(state, "DelTeam", "google::protobuf::Message");
	return true;
}
bool ChangeTeamTypeReq_fflua_reg(lua_State* state)
{
//for decltype
	ChangeTeamTypeReq* message(nullptr);
	message;
	ff::fflua_register_t<ChangeTeamTypeReq, ctor()>(state, "ChangeTeamTypeReq", "google::protobuf::Message")
		// required bool group = 1;
		.def(&ChangeTeamTypeReq::group, "group")
		.def(&ChangeTeamTypeReq::set_group, "set_group")
		.def(&ChangeTeamTypeReq::ByteSize, "ByteSize")
		.def(&ChangeTeamTypeReq::SetInitialized, "SetInitialized")
		;
	return true;
}
bool UpdateTeamTypeReply_fflua_reg(lua_State* state)
{
//for decltype
	UpdateTeamTypeReply* message(nullptr);
	message;
	ff::fflua_register_t<UpdateTeamTypeReply, ctor()>(state, "UpdateTeamTypeReply", "google::protobuf::Message")
		// required bool group = 1;
		.def(&UpdateTeamTypeReply::group, "group")
		.def(&UpdateTeamTypeReply::set_group, "set_group")
		.def(&UpdateTeamTypeReply::ByteSize, "ByteSize")
		.def(&UpdateTeamTypeReply::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ChangeTeamArrangeTypeReq_fflua_reg(lua_State* state)
{
//for decltype
	ChangeTeamArrangeTypeReq* message(nullptr);
	message;
	ff::fflua_register_t<ChangeTeamArrangeTypeReq, ctor()>(state, "ChangeTeamArrangeTypeReq", "google::protobuf::Message")
		// required .Packet.ArrangeType type = 1;
		.def(&ChangeTeamArrangeTypeReq::type, "type")
		.def(&ChangeTeamArrangeTypeReq::set_type, "set_type")
		.def(&ChangeTeamArrangeTypeReq::ByteSize, "ByteSize")
		.def(&ChangeTeamArrangeTypeReq::SetInitialized, "SetInitialized")
		;
	return true;
}
bool UpdateTeamArrangeTypeReply_fflua_reg(lua_State* state)
{
//for decltype
	UpdateTeamArrangeTypeReply* message(nullptr);
	message;
	ff::fflua_register_t<UpdateTeamArrangeTypeReply, ctor()>(state, "UpdateTeamArrangeTypeReply", "google::protobuf::Message")
		// required .Packet.ArrangeType type = 1;
		.def(&UpdateTeamArrangeTypeReply::type, "type")
		.def(&UpdateTeamArrangeTypeReply::set_type, "set_type")
		.def(&UpdateTeamArrangeTypeReply::ByteSize, "ByteSize")
		.def(&UpdateTeamArrangeTypeReply::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ApplyTeamReq_fflua_reg(lua_State* state)
{
//for decltype
	ApplyTeamReq* message(nullptr);
	message;
	ff::fflua_register_t<ApplyTeamReq, ctor()>(state, "ApplyTeamReq", "google::protobuf::Message")
		// required fixed64 guid = 1;
		.def(&ApplyTeamReq::guid, "guid")
		.def(&ApplyTeamReq::set_guid, "set_guid")
		.def(&ApplyTeamReq::ByteSize, "ByteSize")
		.def(&ApplyTeamReq::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ApplyMissionTeamReq_fflua_reg(lua_State* state)
{
//for decltype
	ApplyMissionTeamReq* message(nullptr);
	message;
	ff::fflua_register_t<ApplyMissionTeamReq, ctor()>(state, "ApplyMissionTeamReq", "google::protobuf::Message")
		// required fixed64 srcplayer_guid = 1;
		.def(&ApplyMissionTeamReq::srcplayer_guid, "srcplayer_guid")
		.def(&ApplyMissionTeamReq::set_srcplayer_guid, "set_srcplayer_guid")
		// required int32 missionid = 2;
		.def(&ApplyMissionTeamReq::missionid, "missionid")
		.def(&ApplyMissionTeamReq::set_missionid, "set_missionid")
		.def(&ApplyMissionTeamReq::ByteSize, "ByteSize")
		.def(&ApplyMissionTeamReq::SetInitialized, "SetInitialized")
		;
	return true;
}
bool LevelTeamReq_fflua_reg(lua_State* state)
{
//for decltype
	LevelTeamReq* message(nullptr);
	message;
	ff::fflua_register_t<LevelTeamReq, ctor()>(state, "LevelTeamReq", "google::protobuf::Message");
	return true;
}
bool AskLevelTeamReq_fflua_reg(lua_State* state)
{
//for decltype
	AskLevelTeamReq* message(nullptr);
	message;
	ff::fflua_register_t<AskLevelTeamReq, ctor()>(state, "AskLevelTeamReq", "google::protobuf::Message")
		// required fixed64 playerguid = 1;
		.def(&AskLevelTeamReq::playerguid, "playerguid")
		.def(&AskLevelTeamReq::set_playerguid, "set_playerguid")
		.def(&AskLevelTeamReq::ByteSize, "ByteSize")
		.def(&AskLevelTeamReq::SetInitialized, "SetInitialized")
		;
	return true;
}
bool AgreeApplyTeamReq_fflua_reg(lua_State* state)
{
//for decltype
	AgreeApplyTeamReq* message(nullptr);
	message;
	ff::fflua_register_t<AgreeApplyTeamReq, ctor()>(state, "AgreeApplyTeamReq", "google::protobuf::Message")
		// required fixed64 playerguid = 1;
		.def(&AgreeApplyTeamReq::playerguid, "playerguid")
		.def(&AgreeApplyTeamReq::set_playerguid, "set_playerguid")
		.def(&AgreeApplyTeamReq::ByteSize, "ByteSize")
		.def(&AgreeApplyTeamReq::SetInitialized, "SetInitialized")
		;
	return true;
}
bool InviteyAddTeamReq_fflua_reg(lua_State* state)
{
//for decltype
	InviteyAddTeamReq* message(nullptr);
	message;
	ff::fflua_register_t<InviteyAddTeamReq, ctor()>(state, "InviteyAddTeamReq", "google::protobuf::Message")
		// required fixed64 playerguid = 1;
		.def(&InviteyAddTeamReq::playerguid, "playerguid")
		.def(&InviteyAddTeamReq::set_playerguid, "set_playerguid")
		.def(&InviteyAddTeamReq::ByteSize, "ByteSize")
		.def(&InviteyAddTeamReq::SetInitialized, "SetInitialized")
		;
	return true;
}
bool AskInviteyAgreeTeamReply_fflua_reg(lua_State* state)
{
//for decltype
	AskInviteyAgreeTeamReply* message(nullptr);
	message;
	ff::fflua_register_t<AskInviteyAgreeTeamReply, ctor()>(state, "AskInviteyAgreeTeamReply", "google::protobuf::Message")
		// required fixed64 teamid = 1;
		.def(&AskInviteyAgreeTeamReply::teamid, "teamid")
		.def(&AskInviteyAgreeTeamReply::set_teamid, "set_teamid")
		// required string teaminvitename = 2;
		.def(&AskInviteyAgreeTeamReply::teaminvitename, "teaminvitename")
		.def<void (AskInviteyAgreeTeamReply::*)(const std::string&)>(&AskInviteyAgreeTeamReply::set_teaminvitename, "set_teaminvitename")
		// required fixed64 teaminviteguid = 3;
		.def(&AskInviteyAgreeTeamReply::teaminviteguid, "teaminviteguid")
		.def(&AskInviteyAgreeTeamReply::set_teaminviteguid, "set_teaminviteguid")
		// required int32 purpose = 4;
		.def(&AskInviteyAgreeTeamReply::purpose, "purpose")
		.def(&AskInviteyAgreeTeamReply::set_purpose, "set_purpose")
		.def(&AskInviteyAgreeTeamReply::ByteSize, "ByteSize")
		.def(&AskInviteyAgreeTeamReply::SetInitialized, "SetInitialized")
		;
	return true;
}
bool InviteyAgreeTeamReq_fflua_reg(lua_State* state)
{
//for decltype
	InviteyAgreeTeamReq* message(nullptr);
	message;
	ff::fflua_register_t<InviteyAgreeTeamReq, ctor()>(state, "InviteyAgreeTeamReq", "google::protobuf::Message")
		// required fixed64 teamid = 1;
		.def(&InviteyAgreeTeamReq::teamid, "teamid")
		.def(&InviteyAgreeTeamReq::set_teamid, "set_teamid")
		// required bool agree = 2;
		.def(&InviteyAgreeTeamReq::agree, "agree")
		.def(&InviteyAgreeTeamReq::set_agree, "set_agree")
		// required fixed64 teaminviteguid = 3;
		.def(&InviteyAgreeTeamReq::teaminviteguid, "teaminviteguid")
		.def(&InviteyAgreeTeamReq::set_teaminviteguid, "set_teaminviteguid")
		.def(&InviteyAgreeTeamReq::ByteSize, "ByteSize")
		.def(&InviteyAgreeTeamReq::SetInitialized, "SetInitialized")
		;
	return true;
}
bool AddTeamReply_fflua_reg(lua_State* state)
{
//for decltype
	AddTeamReply* message(nullptr);
	message;
	ff::fflua_register_t<AddTeamReply, ctor()>(state, "AddTeamReply", "google::protobuf::Message")
		// required fixed64 playerguid = 1;
		.def(&AddTeamReply::playerguid, "playerguid")
		.def(&AddTeamReply::set_playerguid, "set_playerguid")
		// required string playername = 2;
		.def(&AddTeamReply::playername, "playername")
		.def<void (AddTeamReply::*)(const std::string&)>(&AddTeamReply::set_playername, "set_playername")
		.def(&AddTeamReply::ByteSize, "ByteSize")
		.def(&AddTeamReply::SetInitialized, "SetInitialized")
		;
	return true;
}
bool LeaveTeamReply_fflua_reg(lua_State* state)
{
//for decltype
	LeaveTeamReply* message(nullptr);
	message;
	ff::fflua_register_t<LeaveTeamReply, ctor()>(state, "LeaveTeamReply", "google::protobuf::Message")
		// required fixed64 playerguid = 1;
		.def(&LeaveTeamReply::playerguid, "playerguid")
		.def(&LeaveTeamReply::set_playerguid, "set_playerguid")
		// required string playername = 2;
		.def(&LeaveTeamReply::playername, "playername")
		.def<void (LeaveTeamReply::*)(const std::string&)>(&LeaveTeamReply::set_playername, "set_playername")
		.def(&LeaveTeamReply::ByteSize, "ByteSize")
		.def(&LeaveTeamReply::SetInitialized, "SetInitialized")
		;
	return true;
}
bool SetPurposeInfoReq_fflua_reg(lua_State* state)
{
//for decltype
	SetPurposeInfoReq* message(nullptr);
	message;
	ff::fflua_register_t<SetPurposeInfoReq, ctor()>(state, "SetPurposeInfoReq", "google::protobuf::Message")
		// required .Packet.PurposeInfo purpose = 1;
		.def(&SetPurposeInfoReq::purpose, "purpose")
		.def(&SetPurposeInfoReq::mutable_purpose, "mutable_purpose")
		.def(&SetPurposeInfoReq::ByteSize, "ByteSize")
		.def(&SetPurposeInfoReq::SetInitialized, "SetInitialized")
		;
	return true;
}
bool PurposeInfoUpdate_fflua_reg(lua_State* state)
{
//for decltype
	PurposeInfoUpdate* message(nullptr);
	message;
	ff::fflua_register_t<PurposeInfoUpdate, ctor()>(state, "PurposeInfoUpdate", "google::protobuf::Message")
		// required .Packet.PurposeInfo purpose = 1;
		.def(&PurposeInfoUpdate::purpose, "purpose")
		.def(&PurposeInfoUpdate::mutable_purpose, "mutable_purpose")
		.def(&PurposeInfoUpdate::ByteSize, "ByteSize")
		.def(&PurposeInfoUpdate::SetInitialized, "SetInitialized")
		;
	return true;
}
bool SetTeamAutoMatchReq_fflua_reg(lua_State* state)
{
//for decltype
	SetTeamAutoMatchReq* message(nullptr);
	message;
	ff::fflua_register_t<SetTeamAutoMatchReq, ctor()>(state, "SetTeamAutoMatchReq", "google::protobuf::Message")
		// required bool auto_match = 1;
		.def(&SetTeamAutoMatchReq::auto_match, "auto_match")
		.def(&SetTeamAutoMatchReq::set_auto_match, "set_auto_match")
		.def(&SetTeamAutoMatchReq::ByteSize, "ByteSize")
		.def(&SetTeamAutoMatchReq::SetInitialized, "SetInitialized")
		;
	return true;
}
bool TeamAutoMatchUpdate_fflua_reg(lua_State* state)
{
//for decltype
	TeamAutoMatchUpdate* message(nullptr);
	message;
	ff::fflua_register_t<TeamAutoMatchUpdate, ctor()>(state, "TeamAutoMatchUpdate", "google::protobuf::Message")
		// required bool auto_match = 1;
		.def(&TeamAutoMatchUpdate::auto_match, "auto_match")
		.def(&TeamAutoMatchUpdate::set_auto_match, "set_auto_match")
		.def(&TeamAutoMatchUpdate::ByteSize, "ByteSize")
		.def(&TeamAutoMatchUpdate::SetInitialized, "SetInitialized")
		;
	return true;
}
bool TeamFullPlayerInfo_fflua_reg(lua_State* state)
{
//for decltype
	TeamFullPlayerInfo* message(nullptr);
	message;
	ff::fflua_register_t<TeamFullPlayerInfo, ctor()>(state, "TeamFullPlayerInfo", "google::protobuf::Message")
		// optional .Packet.PlayerBasicInfo playerbase = 1;
		.def(&TeamFullPlayerInfo::playerbase, "playerbase")
		.def(&TeamFullPlayerInfo::mutable_playerbase, "mutable_playerbase")
		.def(&TeamFullPlayerInfo::has_playerbase, "has_playerbase")
		// required .Packet.TeamPlayerBasicInfo teambaseinfo = 2;
		.def(&TeamFullPlayerInfo::teambaseinfo, "teambaseinfo")
		.def(&TeamFullPlayerInfo::mutable_teambaseinfo, "mutable_teambaseinfo")
		.def(&TeamFullPlayerInfo::ByteSize, "ByteSize")
		.def(&TeamFullPlayerInfo::SetInitialized, "SetInitialized")
		;
	return true;
}
bool TeamListInfo_fflua_reg(lua_State* state)
{
//for decltype
	TeamListInfo* message(nullptr);
	message;
	ff::fflua_register_t<TeamListInfo, ctor()>(state, "TeamListInfo", "google::protobuf::Message")
		// required fixed64 guid = 1;
		.def(&TeamListInfo::guid, "guid")
		.def(&TeamListInfo::set_guid, "set_guid")
		// required int32 purpose = 2;
		.def(&TeamListInfo::purpose, "purpose")
		.def(&TeamListInfo::set_purpose, "set_purpose")
		// required int32 membersize = 3;
		.def(&TeamListInfo::membersize, "membersize")
		.def(&TeamListInfo::set_membersize, "set_membersize")
		// required string leadername = 4;
		.def(&TeamListInfo::leadername, "leadername")
		.def<void (TeamListInfo::*)(const std::string&)>(&TeamListInfo::set_leadername, "set_leadername")
		// required int32 leaderlevel = 5;
		.def(&TeamListInfo::leaderlevel, "leaderlevel")
		.def(&TeamListInfo::set_leaderlevel, "set_leaderlevel")
		// required int32 init_actor_id = 6;
		.def(&TeamListInfo::init_actor_id, "init_actor_id")
		.def(&TeamListInfo::set_init_actor_id, "set_init_actor_id")
		.def(&TeamListInfo::ByteSize, "ByteSize")
		.def(&TeamListInfo::SetInitialized, "SetInitialized")
		;
	return true;
}
bool TeamInfoReq_fflua_reg(lua_State* state)
{
//for decltype
	TeamInfoReq* message(nullptr);
	message;
	ff::fflua_register_t<TeamInfoReq, ctor()>(state, "TeamInfoReq", "google::protobuf::Message");
	return true;
}
bool EmptyTeamReply_fflua_reg(lua_State* state)
{
//for decltype
	EmptyTeamReply* message(nullptr);
	message;
	ff::fflua_register_t<EmptyTeamReply, ctor()>(state, "EmptyTeamReply", "google::protobuf::Message");
	return true;
}
bool TeamInfoReply_fflua_reg(lua_State* state)
{
//for decltype
	TeamInfoReply* message(nullptr);
	message;
	ff::fflua_register_t<TeamInfoReply, ctor()>(state, "TeamInfoReply", "google::protobuf::Message")
		// required fixed64 guid = 1;
		.def(&TeamInfoReply::guid, "guid")
		.def(&TeamInfoReply::set_guid, "set_guid")
		// repeated .Packet.TeamFullPlayerInfo member = 2;
		.def(&TeamInfoReply::member_size, "member_size")
		.def<decltype(message->member(0)) (TeamInfoReply::*)(int) const>(&TeamInfoReply::member, "member")
		.def<decltype(message->mutable_member(0)) (TeamInfoReply::*)(int)>(&TeamInfoReply::mutable_member, "mutable_member")
		.def(&TeamInfoReply::add_member, "add_member")
		// required fixed64 leader = 3;
		.def(&TeamInfoReply::leader, "leader")
		.def(&TeamInfoReply::set_leader, "set_leader")
		// required bool group = 4;
		.def(&TeamInfoReply::group, "group")
		.def(&TeamInfoReply::set_group, "set_group")
		// required .Packet.ArrangeType arrangetype = 5;
		.def(&TeamInfoReply::arrangetype, "arrangetype")
		.def(&TeamInfoReply::set_arrangetype, "set_arrangetype")
		// required .Packet.PurposeInfo purpose = 6;
		.def(&TeamInfoReply::purpose, "purpose")
		.def(&TeamInfoReply::mutable_purpose, "mutable_purpose")
		// required bool auto_match = 7;
		.def(&TeamInfoReply::auto_match, "auto_match")
		.def(&TeamInfoReply::set_auto_match, "set_auto_match")
		// repeated .Packet.PlayerBasicInfo applylist = 8;
		.def(&TeamInfoReply::applylist_size, "applylist_size")
		.def<decltype(message->applylist(0)) (TeamInfoReply::*)(int) const>(&TeamInfoReply::applylist, "applylist")
		.def<decltype(message->mutable_applylist(0)) (TeamInfoReply::*)(int)>(&TeamInfoReply::mutable_applylist, "mutable_applylist")
		.def(&TeamInfoReply::add_applylist, "add_applylist")
		.def(&TeamInfoReply::ByteSize, "ByteSize")
		.def(&TeamInfoReply::SetInitialized, "SetInitialized")
		;
	return true;
}
bool FindTeamListReq_fflua_reg(lua_State* state)
{
//for decltype
	FindTeamListReq* message(nullptr);
	message;
	ff::fflua_register_t<FindTeamListReq, ctor()>(state, "FindTeamListReq", "google::protobuf::Message");
	return true;
}
bool TeamListReply_fflua_reg(lua_State* state)
{
//for decltype
	TeamListReply* message(nullptr);
	message;
	ff::fflua_register_t<TeamListReply, ctor()>(state, "TeamListReply", "google::protobuf::Message")
		// repeated .Packet.TeamListInfo teams = 1;
		.def(&TeamListReply::teams_size, "teams_size")
		.def<decltype(message->teams(0)) (TeamListReply::*)(int) const>(&TeamListReply::teams, "teams")
		.def<decltype(message->mutable_teams(0)) (TeamListReply::*)(int)>(&TeamListReply::mutable_teams, "mutable_teams")
		.def(&TeamListReply::add_teams, "add_teams")
		.def(&TeamListReply::ByteSize, "ByteSize")
		.def(&TeamListReply::SetInitialized, "SetInitialized")
		;
	return true;
}
bool TeamApplyListReq_fflua_reg(lua_State* state)
{
//for decltype
	TeamApplyListReq* message(nullptr);
	message;
	ff::fflua_register_t<TeamApplyListReq, ctor()>(state, "TeamApplyListReq", "google::protobuf::Message");
	return true;
}
bool TeamApplyListReply_fflua_reg(lua_State* state)
{
//for decltype
	TeamApplyListReply* message(nullptr);
	message;
	ff::fflua_register_t<TeamApplyListReply, ctor()>(state, "TeamApplyListReply", "google::protobuf::Message")
		// repeated .Packet.PlayerBasicInfo applylist = 1;
		.def(&TeamApplyListReply::applylist_size, "applylist_size")
		.def<decltype(message->applylist(0)) (TeamApplyListReply::*)(int) const>(&TeamApplyListReply::applylist, "applylist")
		.def<decltype(message->mutable_applylist(0)) (TeamApplyListReply::*)(int)>(&TeamApplyListReply::mutable_applylist, "mutable_applylist")
		.def(&TeamApplyListReply::add_applylist, "add_applylist")
		.def(&TeamApplyListReply::ByteSize, "ByteSize")
		.def(&TeamApplyListReply::SetInitialized, "SetInitialized")
		;
	return true;
}
bool PlayerAutoMatchInfo_fflua_reg(lua_State* state)
{
//for decltype
	PlayerAutoMatchInfo* message(nullptr);
	message;
	ff::fflua_register_t<PlayerAutoMatchInfo, ctor()>(state, "PlayerAutoMatchInfo", "google::protobuf::Message")
		// required fixed64 playerguid = 1;
		.def(&PlayerAutoMatchInfo::playerguid, "playerguid")
		.def(&PlayerAutoMatchInfo::set_playerguid, "set_playerguid")
		// required int32 purpose = 2;
		.def(&PlayerAutoMatchInfo::purpose, "purpose")
		.def(&PlayerAutoMatchInfo::set_purpose, "set_purpose")
		// required int32 level = 3;
		.def(&PlayerAutoMatchInfo::level, "level")
		.def(&PlayerAutoMatchInfo::set_level, "set_level")
		// required int32 hero_position = 4;
		.def(&PlayerAutoMatchInfo::hero_position, "hero_position")
		.def(&PlayerAutoMatchInfo::set_hero_position, "set_hero_position")
		.def(&PlayerAutoMatchInfo::ByteSize, "ByteSize")
		.def(&PlayerAutoMatchInfo::SetInitialized, "SetInitialized")
		;
	return true;
}
bool PlayerAutoMatchReq_fflua_reg(lua_State* state)
{
//for decltype
	PlayerAutoMatchReq* message(nullptr);
	message;
	ff::fflua_register_t<PlayerAutoMatchReq, ctor()>(state, "PlayerAutoMatchReq", "google::protobuf::Message")
		// required bool auto_match = 1;
		.def(&PlayerAutoMatchReq::auto_match, "auto_match")
		.def(&PlayerAutoMatchReq::set_auto_match, "set_auto_match")
		// required int32 purpose = 2;
		.def(&PlayerAutoMatchReq::purpose, "purpose")
		.def(&PlayerAutoMatchReq::set_purpose, "set_purpose")
		.def(&PlayerAutoMatchReq::ByteSize, "ByteSize")
		.def(&PlayerAutoMatchReq::SetInitialized, "SetInitialized")
		;
	return true;
}
bool PlayerAutoMatchReply_fflua_reg(lua_State* state)
{
//for decltype
	PlayerAutoMatchReply* message(nullptr);
	message;
	ff::fflua_register_t<PlayerAutoMatchReply, ctor()>(state, "PlayerAutoMatchReply", "google::protobuf::Message")
		// required bool auto_match = 1;
		.def(&PlayerAutoMatchReply::auto_match, "auto_match")
		.def(&PlayerAutoMatchReply::set_auto_match, "set_auto_match")
		// optional int32 purpose = 2;
		.def(&PlayerAutoMatchReply::purpose, "purpose")
		.def(&PlayerAutoMatchReply::set_purpose, "set_purpose")
		.def(&PlayerAutoMatchReply::has_purpose, "has_purpose")
		.def(&PlayerAutoMatchReply::ByteSize, "ByteSize")
		.def(&PlayerAutoMatchReply::SetInitialized, "SetInitialized")
		;
	return true;
}
bool PlayerSetTeamStatusReq_fflua_reg(lua_State* state)
{
//for decltype
	PlayerSetTeamStatusReq* message(nullptr);
	message;
	ff::fflua_register_t<PlayerSetTeamStatusReq, ctor()>(state, "PlayerSetTeamStatusReq", "google::protobuf::Message")
		// required .Packet.PlayerTeamStatus status = 1;
		.def(&PlayerSetTeamStatusReq::status, "status")
		.def(&PlayerSetTeamStatusReq::set_status, "set_status")
		.def(&PlayerSetTeamStatusReq::ByteSize, "ByteSize")
		.def(&PlayerSetTeamStatusReq::SetInitialized, "SetInitialized")
		;
	return true;
}
bool TeamPlayerBasicUpdate_fflua_reg(lua_State* state)
{
//for decltype
	TeamPlayerBasicUpdate* message(nullptr);
	message;
	ff::fflua_register_t<TeamPlayerBasicUpdate, ctor()>(state, "TeamPlayerBasicUpdate", "google::protobuf::Message")
		// required .Packet.TeamFullPlayerInfo playerinfo = 1;
		.def(&TeamPlayerBasicUpdate::playerinfo, "playerinfo")
		.def(&TeamPlayerBasicUpdate::mutable_playerinfo, "mutable_playerinfo")
		.def(&TeamPlayerBasicUpdate::ByteSize, "ByteSize")
		.def(&TeamPlayerBasicUpdate::SetInitialized, "SetInitialized")
		;
	return true;
}
bool SetTeamLeaderReq_fflua_reg(lua_State* state)
{
//for decltype
	SetTeamLeaderReq* message(nullptr);
	message;
	ff::fflua_register_t<SetTeamLeaderReq, ctor()>(state, "SetTeamLeaderReq", "google::protobuf::Message")
		// required fixed64 playerguid = 1;
		.def(&SetTeamLeaderReq::playerguid, "playerguid")
		.def(&SetTeamLeaderReq::set_playerguid, "set_playerguid")
		.def(&SetTeamLeaderReq::ByteSize, "ByteSize")
		.def(&SetTeamLeaderReq::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ApplyTeamLeaderReq_fflua_reg(lua_State* state)
{
//for decltype
	ApplyTeamLeaderReq* message(nullptr);
	message;
	ff::fflua_register_t<ApplyTeamLeaderReq, ctor()>(state, "ApplyTeamLeaderReq", "google::protobuf::Message");
	return true;
}
bool AskApplyTeamLeaderReq_fflua_reg(lua_State* state)
{
//for decltype
	AskApplyTeamLeaderReq* message(nullptr);
	message;
	ff::fflua_register_t<AskApplyTeamLeaderReq, ctor()>(state, "AskApplyTeamLeaderReq", "google::protobuf::Message")
		// required fixed64 playerguid = 1;
		.def(&AskApplyTeamLeaderReq::playerguid, "playerguid")
		.def(&AskApplyTeamLeaderReq::set_playerguid, "set_playerguid")
		.def(&AskApplyTeamLeaderReq::ByteSize, "ByteSize")
		.def(&AskApplyTeamLeaderReq::SetInitialized, "SetInitialized")
		;
	return true;
}
bool AskApplyTeamLeaderReply_fflua_reg(lua_State* state)
{
//for decltype
	AskApplyTeamLeaderReply* message(nullptr);
	message;
	ff::fflua_register_t<AskApplyTeamLeaderReply, ctor()>(state, "AskApplyTeamLeaderReply", "google::protobuf::Message")
		// required bool agree = 1;
		.def(&AskApplyTeamLeaderReply::agree, "agree")
		.def(&AskApplyTeamLeaderReply::set_agree, "set_agree")
		.def(&AskApplyTeamLeaderReply::ByteSize, "ByteSize")
		.def(&AskApplyTeamLeaderReply::SetInitialized, "SetInitialized")
		;
	return true;
}
bool TeamLeaderUpdate_fflua_reg(lua_State* state)
{
//for decltype
	TeamLeaderUpdate* message(nullptr);
	message;
	ff::fflua_register_t<TeamLeaderUpdate, ctor()>(state, "TeamLeaderUpdate", "google::protobuf::Message")
		// required fixed64 playerguid = 1;
		.def(&TeamLeaderUpdate::playerguid, "playerguid")
		.def(&TeamLeaderUpdate::set_playerguid, "set_playerguid")
		// required string playername = 2;
		.def(&TeamLeaderUpdate::playername, "playername")
		.def<void (TeamLeaderUpdate::*)(const std::string&)>(&TeamLeaderUpdate::set_playername, "set_playername")
		// required fixed32 move_speed = 3;
		.def(&TeamLeaderUpdate::move_speed, "move_speed")
		.def(&TeamLeaderUpdate::set_move_speed, "set_move_speed")
		// required bool charge = 4;
		.def(&TeamLeaderUpdate::charge, "charge")
		.def(&TeamLeaderUpdate::set_charge, "set_charge")
		.def(&TeamLeaderUpdate::ByteSize, "ByteSize")
		.def(&TeamLeaderUpdate::SetInitialized, "SetInitialized")
		;
	return true;
}
bool RobotPlayerInOk_fflua_reg(lua_State* state)
{
//for decltype
	RobotPlayerInOk* message(nullptr);
	message;
	ff::fflua_register_t<RobotPlayerInOk, ctor()>(state, "RobotPlayerInOk", "google::protobuf::Message")
		// repeated .Packet.PlayerBasicInfo basic_info = 1;
		.def(&RobotPlayerInOk::basic_info_size, "basic_info_size")
		.def<decltype(message->basic_info(0)) (RobotPlayerInOk::*)(int) const>(&RobotPlayerInOk::basic_info, "basic_info")
		.def<decltype(message->mutable_basic_info(0)) (RobotPlayerInOk::*)(int)>(&RobotPlayerInOk::mutable_basic_info, "mutable_basic_info")
		.def(&RobotPlayerInOk::add_basic_info, "add_basic_info")
		// repeated int32 one_key_id = 2;
		.def(&RobotPlayerInOk::one_key_id_size, "one_key_id_size")
		.def<decltype(message->one_key_id(0)) (RobotPlayerInOk::*)(int) const>(&RobotPlayerInOk::one_key_id, "one_key_id")
		.def<void(RobotPlayerInOk::*)(int, const decltype(message->one_key_id(0)))>(&RobotPlayerInOk::set_one_key_id, "set_one_key_id")
		.def(&RobotPlayerInOk::add_one_key_id, "add_one_key_id")
		.def(&RobotPlayerInOk::ByteSize, "ByteSize")
		.def(&RobotPlayerInOk::SetInitialized, "SetInitialized")
		;
	return true;
}
bool TeamAutomatchConfig_fflua_reg(lua_State* state)
{
//for decltype
	TeamAutomatchConfig* message(nullptr);
	message;
	ff::fflua_register_t<TeamAutomatchConfig, ctor()>(state, "TeamAutomatchConfig", "google::protobuf::Message")
		// required int32 id = 1;
		.def(&TeamAutomatchConfig::id, "id")
		.def(&TeamAutomatchConfig::set_id, "set_id")
		// required int32 group = 2;
		.def(&TeamAutomatchConfig::group, "group")
		.def(&TeamAutomatchConfig::set_group, "set_group")
		// required int32 defence_count = 3;
		.def(&TeamAutomatchConfig::defence_count, "defence_count")
		.def(&TeamAutomatchConfig::set_defence_count, "set_defence_count")
		// required int32 cure_count = 4;
		.def(&TeamAutomatchConfig::cure_count, "cure_count")
		.def(&TeamAutomatchConfig::set_cure_count, "set_cure_count")
		// required int32 attack_count = 5;
		.def(&TeamAutomatchConfig::attack_count, "attack_count")
		.def(&TeamAutomatchConfig::set_attack_count, "set_attack_count")
		// required int32 need_defence_count = 6;
		.def(&TeamAutomatchConfig::need_defence_count, "need_defence_count")
		.def(&TeamAutomatchConfig::set_need_defence_count, "set_need_defence_count")
		// required int32 need_cure_count = 7;
		.def(&TeamAutomatchConfig::need_cure_count, "need_cure_count")
		.def(&TeamAutomatchConfig::set_need_cure_count, "set_need_cure_count")
		// required int32 need_attack_count = 8;
		.def(&TeamAutomatchConfig::need_attack_count, "need_attack_count")
		.def(&TeamAutomatchConfig::set_need_attack_count, "set_need_attack_count")
		.def(&TeamAutomatchConfig::ByteSize, "ByteSize")
		.def(&TeamAutomatchConfig::SetInitialized, "SetInitialized")
		;
	return true;
}
bool Team_fflua_regist_all(lua_State* state)
{
	PurposeInfo_fflua_reg(state);
	TeamPlayerBasicInfo_fflua_reg(state);
	TeamPlayerInfo_fflua_reg(state);
	SetTeamHeroPositionReq_fflua_reg(state);
	SetTeamHeroPositionReply_fflua_reg(state);
	TeamInfo_fflua_reg(state);
	CreateTeam_fflua_reg(state);
	CreateRobotTeam_fflua_reg(state);
	DelTeam_fflua_reg(state);
	ChangeTeamTypeReq_fflua_reg(state);
	UpdateTeamTypeReply_fflua_reg(state);
	ChangeTeamArrangeTypeReq_fflua_reg(state);
	UpdateTeamArrangeTypeReply_fflua_reg(state);
	ApplyTeamReq_fflua_reg(state);
	ApplyMissionTeamReq_fflua_reg(state);
	LevelTeamReq_fflua_reg(state);
	AskLevelTeamReq_fflua_reg(state);
	AgreeApplyTeamReq_fflua_reg(state);
	InviteyAddTeamReq_fflua_reg(state);
	AskInviteyAgreeTeamReply_fflua_reg(state);
	InviteyAgreeTeamReq_fflua_reg(state);
	AddTeamReply_fflua_reg(state);
	LeaveTeamReply_fflua_reg(state);
	SetPurposeInfoReq_fflua_reg(state);
	PurposeInfoUpdate_fflua_reg(state);
	SetTeamAutoMatchReq_fflua_reg(state);
	TeamAutoMatchUpdate_fflua_reg(state);
	TeamFullPlayerInfo_fflua_reg(state);
	TeamListInfo_fflua_reg(state);
	TeamInfoReq_fflua_reg(state);
	EmptyTeamReply_fflua_reg(state);
	TeamInfoReply_fflua_reg(state);
	FindTeamListReq_fflua_reg(state);
	TeamListReply_fflua_reg(state);
	TeamApplyListReq_fflua_reg(state);
	TeamApplyListReply_fflua_reg(state);
	PlayerAutoMatchInfo_fflua_reg(state);
	PlayerAutoMatchReq_fflua_reg(state);
	PlayerAutoMatchReply_fflua_reg(state);
	PlayerSetTeamStatusReq_fflua_reg(state);
	TeamPlayerBasicUpdate_fflua_reg(state);
	SetTeamLeaderReq_fflua_reg(state);
	ApplyTeamLeaderReq_fflua_reg(state);
	AskApplyTeamLeaderReq_fflua_reg(state);
	AskApplyTeamLeaderReply_fflua_reg(state);
	TeamLeaderUpdate_fflua_reg(state);
	RobotPlayerInOk_fflua_reg(state);
	TeamAutomatchConfig_fflua_reg(state);
	return true;
}
}
