// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LoginPacket.proto

#ifndef PROTOBUF_LoginPacket_2eproto__INCLUDED
#define PROTOBUF_LoginPacket_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "AllPacketEnum.pb.h"
#include "PlayerBasicInfo.pb.h"
// @@protoc_insertion_point(includes)

namespace Packet {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_LoginPacket_2eproto();
void protobuf_AssignDesc_LoginPacket_2eproto();
void protobuf_ShutdownFile_LoginPacket_2eproto();

class AccountNameVerify;
class AccountNameVerifyReply;
class AccountRegist;
class AccountRegistReply;
class LoginRequest;
class LoginReply;
class AccountPlayerList;
class AccountModel;
class AccountPlayerListReply;

enum AccountNameVerifyReply_Result {
  AccountNameVerifyReply_Result_SUCCESS = 0,
  AccountNameVerifyReply_Result_DUPLICATED = 1,
  AccountNameVerifyReply_Result_UNKNOWN = 2
};
bool AccountNameVerifyReply_Result_IsValid(int value);
const AccountNameVerifyReply_Result AccountNameVerifyReply_Result_Result_MIN = AccountNameVerifyReply_Result_SUCCESS;
const AccountNameVerifyReply_Result AccountNameVerifyReply_Result_Result_MAX = AccountNameVerifyReply_Result_UNKNOWN;
const int AccountNameVerifyReply_Result_Result_ARRAYSIZE = AccountNameVerifyReply_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccountNameVerifyReply_Result_descriptor();
inline const ::std::string& AccountNameVerifyReply_Result_Name(AccountNameVerifyReply_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccountNameVerifyReply_Result_descriptor(), value);
}
inline bool AccountNameVerifyReply_Result_Parse(
    const ::std::string& name, AccountNameVerifyReply_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccountNameVerifyReply_Result>(
    AccountNameVerifyReply_Result_descriptor(), name, value);
}
enum AccountRegistReply_Result {
  AccountRegistReply_Result_SUCCESS = 0,
  AccountRegistReply_Result_DUPLICATED = 1,
  AccountRegistReply_Result_ACCOUNT_LENGTH_INVALID = 2,
  AccountRegistReply_Result_PASSWORD_TOW_SIMPLE = 3,
  AccountRegistReply_Result_UNKNOWN = 4
};
bool AccountRegistReply_Result_IsValid(int value);
const AccountRegistReply_Result AccountRegistReply_Result_Result_MIN = AccountRegistReply_Result_SUCCESS;
const AccountRegistReply_Result AccountRegistReply_Result_Result_MAX = AccountRegistReply_Result_UNKNOWN;
const int AccountRegistReply_Result_Result_ARRAYSIZE = AccountRegistReply_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccountRegistReply_Result_descriptor();
inline const ::std::string& AccountRegistReply_Result_Name(AccountRegistReply_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccountRegistReply_Result_descriptor(), value);
}
inline bool AccountRegistReply_Result_Parse(
    const ::std::string& name, AccountRegistReply_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccountRegistReply_Result>(
    AccountRegistReply_Result_descriptor(), name, value);
}
enum LoginReply_Result {
  LoginReply_Result_SUCCESS = 0,
  LoginReply_Result_WRONG_LOGIN_TYPE = 1,
  LoginReply_Result_WRONG_PASSWORD = 2,
  LoginReply_Result_WRONG_STATUS = 3,
  LoginReply_Result_NO_SUCH_ACCOUNT = 4,
  LoginReply_Result_UNKNOWN = 5
};
bool LoginReply_Result_IsValid(int value);
const LoginReply_Result LoginReply_Result_Result_MIN = LoginReply_Result_SUCCESS;
const LoginReply_Result LoginReply_Result_Result_MAX = LoginReply_Result_UNKNOWN;
const int LoginReply_Result_Result_ARRAYSIZE = LoginReply_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginReply_Result_descriptor();
inline const ::std::string& LoginReply_Result_Name(LoginReply_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginReply_Result_descriptor(), value);
}
inline bool LoginReply_Result_Parse(
    const ::std::string& name, LoginReply_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginReply_Result>(
    LoginReply_Result_descriptor(), name, value);
}
// ===================================================================

class AccountNameVerify : public ::google::protobuf::Message {
 public:
  AccountNameVerify();
  virtual ~AccountNameVerify();

  AccountNameVerify(const AccountNameVerify& from);

  inline AccountNameVerify& operator=(const AccountNameVerify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountNameVerify& default_instance();

  void Swap(AccountNameVerify* other);

  // implements Message ----------------------------------------------

  AccountNameVerify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountNameVerify& from);
  void MergeFrom(const AccountNameVerify& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // @@protoc_insertion_point(class_scope:Packet.AccountNameVerify)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_LoginPacket_2eproto();
  friend void protobuf_AssignDesc_LoginPacket_2eproto();
  friend void protobuf_ShutdownFile_LoginPacket_2eproto();

  void InitAsDefaultInstance();
  static AccountNameVerify* default_instance_;
};
// -------------------------------------------------------------------

class AccountNameVerifyReply : public ::google::protobuf::Message {
 public:
  AccountNameVerifyReply();
  virtual ~AccountNameVerifyReply();

  AccountNameVerifyReply(const AccountNameVerifyReply& from);

  inline AccountNameVerifyReply& operator=(const AccountNameVerifyReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountNameVerifyReply& default_instance();

  void Swap(AccountNameVerifyReply* other);

  // implements Message ----------------------------------------------

  AccountNameVerifyReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountNameVerifyReply& from);
  void MergeFrom(const AccountNameVerifyReply& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AccountNameVerifyReply_Result Result;
  static const Result SUCCESS = AccountNameVerifyReply_Result_SUCCESS;
  static const Result DUPLICATED = AccountNameVerifyReply_Result_DUPLICATED;
  static const Result UNKNOWN = AccountNameVerifyReply_Result_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return AccountNameVerifyReply_Result_IsValid(value);
  }
  static const Result Result_MIN =
    AccountNameVerifyReply_Result_Result_MIN;
  static const Result Result_MAX =
    AccountNameVerifyReply_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    AccountNameVerifyReply_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return AccountNameVerifyReply_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return AccountNameVerifyReply_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return AccountNameVerifyReply_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Packet.AccountNameVerify requset = 1;
  inline bool has_requset() const;
  inline void clear_requset();
  static const int kRequsetFieldNumber = 1;
  inline const ::Packet::AccountNameVerify& requset() const;
  inline ::Packet::AccountNameVerify* mutable_requset();
  inline ::Packet::AccountNameVerify* release_requset();
  inline void set_allocated_requset(::Packet::AccountNameVerify* requset);

  // required .Packet.AccountNameVerifyReply.Result result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::Packet::AccountNameVerifyReply_Result result() const;
  inline void set_result(::Packet::AccountNameVerifyReply_Result value);

  // @@protoc_insertion_point(class_scope:Packet.AccountNameVerifyReply)
 private:
  inline void set_has_requset();
  inline void clear_has_requset();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Packet::AccountNameVerify* requset_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_LoginPacket_2eproto();
  friend void protobuf_AssignDesc_LoginPacket_2eproto();
  friend void protobuf_ShutdownFile_LoginPacket_2eproto();

  void InitAsDefaultInstance();
  static AccountNameVerifyReply* default_instance_;
};
// -------------------------------------------------------------------

class AccountRegist : public ::google::protobuf::Message {
 public:
  AccountRegist();
  virtual ~AccountRegist();

  AccountRegist(const AccountRegist& from);

  inline AccountRegist& operator=(const AccountRegist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountRegist& default_instance();

  void Swap(AccountRegist* other);

  // implements Message ----------------------------------------------

  AccountRegist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountRegist& from);
  void MergeFrom(const AccountRegist& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required string udid = 3;
  inline bool has_udid() const;
  inline void clear_udid();
  static const int kUdidFieldNumber = 3;
  inline const ::std::string& udid() const;
  inline void set_udid(const ::std::string& value);
  inline void set_udid(const char* value);
  inline void set_udid(const char* value, size_t size);
  inline ::std::string* mutable_udid();
  inline ::std::string* release_udid();
  inline void set_allocated_udid(::std::string* udid);

  // required int32 partnerid = 4;
  inline bool has_partnerid() const;
  inline void clear_partnerid();
  static const int kPartneridFieldNumber = 4;
  inline ::google::protobuf::int32 partnerid() const;
  inline void set_partnerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Packet.AccountRegist)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_udid();
  inline void clear_has_udid();
  inline void set_has_partnerid();
  inline void clear_has_partnerid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::std::string* password_;
  ::std::string* udid_;
  ::google::protobuf::int32 partnerid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_LoginPacket_2eproto();
  friend void protobuf_AssignDesc_LoginPacket_2eproto();
  friend void protobuf_ShutdownFile_LoginPacket_2eproto();

  void InitAsDefaultInstance();
  static AccountRegist* default_instance_;
};
// -------------------------------------------------------------------

class AccountRegistReply : public ::google::protobuf::Message {
 public:
  AccountRegistReply();
  virtual ~AccountRegistReply();

  AccountRegistReply(const AccountRegistReply& from);

  inline AccountRegistReply& operator=(const AccountRegistReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountRegistReply& default_instance();

  void Swap(AccountRegistReply* other);

  // implements Message ----------------------------------------------

  AccountRegistReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountRegistReply& from);
  void MergeFrom(const AccountRegistReply& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AccountRegistReply_Result Result;
  static const Result SUCCESS = AccountRegistReply_Result_SUCCESS;
  static const Result DUPLICATED = AccountRegistReply_Result_DUPLICATED;
  static const Result ACCOUNT_LENGTH_INVALID = AccountRegistReply_Result_ACCOUNT_LENGTH_INVALID;
  static const Result PASSWORD_TOW_SIMPLE = AccountRegistReply_Result_PASSWORD_TOW_SIMPLE;
  static const Result UNKNOWN = AccountRegistReply_Result_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return AccountRegistReply_Result_IsValid(value);
  }
  static const Result Result_MIN =
    AccountRegistReply_Result_Result_MIN;
  static const Result Result_MAX =
    AccountRegistReply_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    AccountRegistReply_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return AccountRegistReply_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return AccountRegistReply_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return AccountRegistReply_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Packet.AccountRegist requset = 1;
  inline bool has_requset() const;
  inline void clear_requset();
  static const int kRequsetFieldNumber = 1;
  inline const ::Packet::AccountRegist& requset() const;
  inline ::Packet::AccountRegist* mutable_requset();
  inline ::Packet::AccountRegist* release_requset();
  inline void set_allocated_requset(::Packet::AccountRegist* requset);

  // required .Packet.AccountRegistReply.Result result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::Packet::AccountRegistReply_Result result() const;
  inline void set_result(::Packet::AccountRegistReply_Result value);

  // @@protoc_insertion_point(class_scope:Packet.AccountRegistReply)
 private:
  inline void set_has_requset();
  inline void clear_has_requset();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Packet::AccountRegist* requset_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_LoginPacket_2eproto();
  friend void protobuf_AssignDesc_LoginPacket_2eproto();
  friend void protobuf_ShutdownFile_LoginPacket_2eproto();

  void InitAsDefaultInstance();
  static AccountRegistReply* default_instance_;
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // required string userid = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 2;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required .Packet.AccountType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::Packet::AccountType type() const;
  inline void set_type(::Packet::AccountType value);

  // required string loginkey = 5;
  inline bool has_loginkey() const;
  inline void clear_loginkey();
  static const int kLoginkeyFieldNumber = 5;
  inline const ::std::string& loginkey() const;
  inline void set_loginkey(const ::std::string& value);
  inline void set_loginkey(const char* value);
  inline void set_loginkey(const char* value, size_t size);
  inline ::std::string* mutable_loginkey();
  inline ::std::string* release_loginkey();
  inline void set_allocated_loginkey(::std::string* loginkey);

  // required int32 partnerid = 6;
  inline bool has_partnerid() const;
  inline void clear_partnerid();
  static const int kPartneridFieldNumber = 6;
  inline ::google::protobuf::int32 partnerid() const;
  inline void set_partnerid(::google::protobuf::int32 value);

  // required string device_type = 7;
  inline bool has_device_type() const;
  inline void clear_device_type();
  static const int kDeviceTypeFieldNumber = 7;
  inline const ::std::string& device_type() const;
  inline void set_device_type(const ::std::string& value);
  inline void set_device_type(const char* value);
  inline void set_device_type(const char* value, size_t size);
  inline ::std::string* mutable_device_type();
  inline ::std::string* release_device_type();
  inline void set_allocated_device_type(::std::string* device_type);

  // required string udid = 8;
  inline bool has_udid() const;
  inline void clear_udid();
  static const int kUdidFieldNumber = 8;
  inline const ::std::string& udid() const;
  inline void set_udid(const ::std::string& value);
  inline void set_udid(const char* value);
  inline void set_udid(const char* value, size_t size);
  inline ::std::string* mutable_udid();
  inline ::std::string* release_udid();
  inline void set_allocated_udid(::std::string* udid);

  // required string osversion = 9;
  inline bool has_osversion() const;
  inline void clear_osversion();
  static const int kOsversionFieldNumber = 9;
  inline const ::std::string& osversion() const;
  inline void set_osversion(const ::std::string& value);
  inline void set_osversion(const char* value);
  inline void set_osversion(const char* value, size_t size);
  inline ::std::string* mutable_osversion();
  inline ::std::string* release_osversion();
  inline void set_allocated_osversion(::std::string* osversion);

  // required string login_ip = 10;
  inline bool has_login_ip() const;
  inline void clear_login_ip();
  static const int kLoginIpFieldNumber = 10;
  inline const ::std::string& login_ip() const;
  inline void set_login_ip(const ::std::string& value);
  inline void set_login_ip(const char* value);
  inline void set_login_ip(const char* value, size_t size);
  inline ::std::string* mutable_login_ip();
  inline ::std::string* release_login_ip();
  inline void set_allocated_login_ip(::std::string* login_ip);

  // required int32 gameversionid = 11;
  inline bool has_gameversionid() const;
  inline void clear_gameversionid();
  static const int kGameversionidFieldNumber = 11;
  inline ::google::protobuf::int32 gameversionid() const;
  inline void set_gameversionid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Packet.LoginRequest)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_loginkey();
  inline void clear_has_loginkey();
  inline void set_has_partnerid();
  inline void clear_has_partnerid();
  inline void set_has_device_type();
  inline void clear_has_device_type();
  inline void set_has_udid();
  inline void clear_has_udid();
  inline void set_has_osversion();
  inline void clear_has_osversion();
  inline void set_has_login_ip();
  inline void clear_has_login_ip();
  inline void set_has_gameversionid();
  inline void clear_has_gameversionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;
  ::std::string* userid_;
  ::std::string* password_;
  ::std::string* loginkey_;
  int type_;
  ::google::protobuf::int32 partnerid_;
  ::std::string* device_type_;
  ::std::string* udid_;
  ::std::string* osversion_;
  ::std::string* login_ip_;
  ::google::protobuf::int32 gameversionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_LoginPacket_2eproto();
  friend void protobuf_AssignDesc_LoginPacket_2eproto();
  friend void protobuf_ShutdownFile_LoginPacket_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginReply : public ::google::protobuf::Message {
 public:
  LoginReply();
  virtual ~LoginReply();

  LoginReply(const LoginReply& from);

  inline LoginReply& operator=(const LoginReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReply& default_instance();

  void Swap(LoginReply* other);

  // implements Message ----------------------------------------------

  LoginReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginReply& from);
  void MergeFrom(const LoginReply& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LoginReply_Result Result;
  static const Result SUCCESS = LoginReply_Result_SUCCESS;
  static const Result WRONG_LOGIN_TYPE = LoginReply_Result_WRONG_LOGIN_TYPE;
  static const Result WRONG_PASSWORD = LoginReply_Result_WRONG_PASSWORD;
  static const Result WRONG_STATUS = LoginReply_Result_WRONG_STATUS;
  static const Result NO_SUCH_ACCOUNT = LoginReply_Result_NO_SUCH_ACCOUNT;
  static const Result UNKNOWN = LoginReply_Result_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return LoginReply_Result_IsValid(value);
  }
  static const Result Result_MIN =
    LoginReply_Result_Result_MIN;
  static const Result Result_MAX =
    LoginReply_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    LoginReply_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return LoginReply_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return LoginReply_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return LoginReply_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Packet.LoginReply.Result result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::Packet::LoginReply_Result result() const;
  inline void set_result(::Packet::LoginReply_Result value);

  // optional string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:Packet.LoginReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_LoginPacket_2eproto();
  friend void protobuf_AssignDesc_LoginPacket_2eproto();
  friend void protobuf_ShutdownFile_LoginPacket_2eproto();

  void InitAsDefaultInstance();
  static LoginReply* default_instance_;
};
// -------------------------------------------------------------------

class AccountPlayerList : public ::google::protobuf::Message {
 public:
  AccountPlayerList();
  virtual ~AccountPlayerList();

  AccountPlayerList(const AccountPlayerList& from);

  inline AccountPlayerList& operator=(const AccountPlayerList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountPlayerList& default_instance();

  void Swap(AccountPlayerList* other);

  // implements Message ----------------------------------------------

  AccountPlayerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountPlayerList& from);
  void MergeFrom(const AccountPlayerList& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Packet.AccountPlayerList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_LoginPacket_2eproto();
  friend void protobuf_AssignDesc_LoginPacket_2eproto();
  friend void protobuf_ShutdownFile_LoginPacket_2eproto();

  void InitAsDefaultInstance();
  static AccountPlayerList* default_instance_;
};
// -------------------------------------------------------------------

class AccountModel : public ::google::protobuf::Message {
 public:
  AccountModel();
  virtual ~AccountModel();

  AccountModel(const AccountModel& from);

  inline AccountModel& operator=(const AccountModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountModel& default_instance();

  void Swap(AccountModel* other);

  // implements Message ----------------------------------------------

  AccountModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountModel& from);
  void MergeFrom(const AccountModel& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 guid = 1;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 1;
  inline ::google::protobuf::uint64 guid() const;
  inline void set_guid(::google::protobuf::uint64 value);

  // required string userid = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 2;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required .Packet.AccountType account_type = 4;
  inline bool has_account_type() const;
  inline void clear_account_type();
  static const int kAccountTypeFieldNumber = 4;
  inline ::Packet::AccountType account_type() const;
  inline void set_account_type(::Packet::AccountType value);

  // required string udid = 5;
  inline bool has_udid() const;
  inline void clear_udid();
  static const int kUdidFieldNumber = 5;
  inline const ::std::string& udid() const;
  inline void set_udid(const ::std::string& value);
  inline void set_udid(const char* value);
  inline void set_udid(const char* value, size_t size);
  inline ::std::string* mutable_udid();
  inline ::std::string* release_udid();
  inline void set_allocated_udid(::std::string* udid);

  // required int32 partnerid = 6;
  inline bool has_partnerid() const;
  inline void clear_partnerid();
  static const int kPartneridFieldNumber = 6;
  inline ::google::protobuf::int32 partnerid() const;
  inline void set_partnerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Packet.AccountModel)
 private:
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_account_type();
  inline void clear_has_account_type();
  inline void set_has_udid();
  inline void clear_has_udid();
  inline void set_has_partnerid();
  inline void clear_has_partnerid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 guid_;
  ::std::string* userid_;
  ::std::string* password_;
  ::std::string* udid_;
  int account_type_;
  ::google::protobuf::int32 partnerid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_LoginPacket_2eproto();
  friend void protobuf_AssignDesc_LoginPacket_2eproto();
  friend void protobuf_ShutdownFile_LoginPacket_2eproto();

  void InitAsDefaultInstance();
  static AccountModel* default_instance_;
};
// -------------------------------------------------------------------

class AccountPlayerListReply : public ::google::protobuf::Message {
 public:
  AccountPlayerListReply();
  virtual ~AccountPlayerListReply();

  AccountPlayerListReply(const AccountPlayerListReply& from);

  inline AccountPlayerListReply& operator=(const AccountPlayerListReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountPlayerListReply& default_instance();

  void Swap(AccountPlayerListReply* other);

  // implements Message ----------------------------------------------

  AccountPlayerListReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountPlayerListReply& from);
  void MergeFrom(const AccountPlayerListReply& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Packet.PlayerDBInfo player_list = 1;
  inline int player_list_size() const;
  inline void clear_player_list();
  static const int kPlayerListFieldNumber = 1;
  inline const ::Packet::PlayerDBInfo& player_list(int index) const;
  inline ::Packet::PlayerDBInfo* mutable_player_list(int index);
  inline ::Packet::PlayerDBInfo* add_player_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Packet::PlayerDBInfo >&
      player_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Packet::PlayerDBInfo >*
      mutable_player_list();

  // @@protoc_insertion_point(class_scope:Packet.AccountPlayerListReply)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Packet::PlayerDBInfo > player_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_LoginPacket_2eproto();
  friend void protobuf_AssignDesc_LoginPacket_2eproto();
  friend void protobuf_ShutdownFile_LoginPacket_2eproto();

  void InitAsDefaultInstance();
  static AccountPlayerListReply* default_instance_;
};
// ===================================================================


// ===================================================================

// AccountNameVerify

// required string userid = 1;
inline bool AccountNameVerify::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountNameVerify::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountNameVerify::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountNameVerify::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
  SetDirty();
}
inline const ::std::string& AccountNameVerify::userid() const {
  return *userid_;
}
inline void AccountNameVerify::set_userid(const ::std::string& value) {
  SetDirty();
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void AccountNameVerify::set_userid(const char* value) {
  SetDirty();
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void AccountNameVerify::set_userid(const char* value, size_t size) {
  SetDirty();
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountNameVerify::mutable_userid() {
  SetDirty();
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* AccountNameVerify::release_userid() {
  SetDirty();
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountNameVerify::set_allocated_userid(::std::string* userid) {
  SetDirty();
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AccountNameVerifyReply

// required .Packet.AccountNameVerify requset = 1;
inline bool AccountNameVerifyReply::has_requset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountNameVerifyReply::set_has_requset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountNameVerifyReply::clear_has_requset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountNameVerifyReply::clear_requset() {
  if (requset_ != NULL) requset_->::Packet::AccountNameVerify::Clear();
  clear_has_requset();
  SetDirty();
}
inline const ::Packet::AccountNameVerify& AccountNameVerifyReply::requset() const {
  return requset_ != NULL ? *requset_ : *default_instance_->requset_;
}
inline ::Packet::AccountNameVerify* AccountNameVerifyReply::mutable_requset() {
  SetDirty();
  set_has_requset();
  if (requset_ == NULL) requset_ = new ::Packet::AccountNameVerify;
  return requset_;
}
inline ::Packet::AccountNameVerify* AccountNameVerifyReply::release_requset() {
  SetDirty();
  clear_has_requset();
  ::Packet::AccountNameVerify* temp = requset_;
  requset_ = NULL;
  return temp;
}
inline void AccountNameVerifyReply::set_allocated_requset(::Packet::AccountNameVerify* requset) {
  SetDirty();
  delete requset_;
  requset_ = requset;
  if (requset) {
    set_has_requset();
  } else {
    clear_has_requset();
  }
}

// required .Packet.AccountNameVerifyReply.Result result = 2;
inline bool AccountNameVerifyReply::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountNameVerifyReply::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountNameVerifyReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountNameVerifyReply::clear_result() {
  result_ = 0;
  clear_has_result();
  SetDirty();
}
inline ::Packet::AccountNameVerifyReply_Result AccountNameVerifyReply::result() const {
  return static_cast< ::Packet::AccountNameVerifyReply_Result >(result_);
}
inline void AccountNameVerifyReply::set_result(::Packet::AccountNameVerifyReply_Result value) {
  assert(::Packet::AccountNameVerifyReply_Result_IsValid(value));
  SetDirty();
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// AccountRegist

// required string userid = 1;
inline bool AccountRegist::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountRegist::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountRegist::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountRegist::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
  SetDirty();
}
inline const ::std::string& AccountRegist::userid() const {
  return *userid_;
}
inline void AccountRegist::set_userid(const ::std::string& value) {
  SetDirty();
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void AccountRegist::set_userid(const char* value) {
  SetDirty();
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void AccountRegist::set_userid(const char* value, size_t size) {
  SetDirty();
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountRegist::mutable_userid() {
  SetDirty();
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* AccountRegist::release_userid() {
  SetDirty();
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountRegist::set_allocated_userid(::std::string* userid) {
  SetDirty();
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 2;
inline bool AccountRegist::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountRegist::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountRegist::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountRegist::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
  SetDirty();
}
inline const ::std::string& AccountRegist::password() const {
  return *password_;
}
inline void AccountRegist::set_password(const ::std::string& value) {
  SetDirty();
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void AccountRegist::set_password(const char* value) {
  SetDirty();
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void AccountRegist::set_password(const char* value, size_t size) {
  SetDirty();
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountRegist::mutable_password() {
  SetDirty();
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* AccountRegist::release_password() {
  SetDirty();
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountRegist::set_allocated_password(::std::string* password) {
  SetDirty();
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string udid = 3;
inline bool AccountRegist::has_udid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountRegist::set_has_udid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountRegist::clear_has_udid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountRegist::clear_udid() {
  if (udid_ != &::google::protobuf::internal::kEmptyString) {
    udid_->clear();
  }
  clear_has_udid();
  SetDirty();
}
inline const ::std::string& AccountRegist::udid() const {
  return *udid_;
}
inline void AccountRegist::set_udid(const ::std::string& value) {
  SetDirty();
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(value);
}
inline void AccountRegist::set_udid(const char* value) {
  SetDirty();
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(value);
}
inline void AccountRegist::set_udid(const char* value, size_t size) {
  SetDirty();
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountRegist::mutable_udid() {
  SetDirty();
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  return udid_;
}
inline ::std::string* AccountRegist::release_udid() {
  SetDirty();
  clear_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = udid_;
    udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountRegist::set_allocated_udid(::std::string* udid) {
  SetDirty();
  if (udid_ != &::google::protobuf::internal::kEmptyString) {
    delete udid_;
  }
  if (udid) {
    set_has_udid();
    udid_ = udid;
  } else {
    clear_has_udid();
    udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 partnerid = 4;
inline bool AccountRegist::has_partnerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountRegist::set_has_partnerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountRegist::clear_has_partnerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountRegist::clear_partnerid() {
  partnerid_ = 0;
  clear_has_partnerid();
  SetDirty();
}
inline ::google::protobuf::int32 AccountRegist::partnerid() const {
  return partnerid_;
}
inline void AccountRegist::set_partnerid(::google::protobuf::int32 value) {
  SetDirty();
  set_has_partnerid();
  partnerid_ = value;
}

// -------------------------------------------------------------------

// AccountRegistReply

// required .Packet.AccountRegist requset = 1;
inline bool AccountRegistReply::has_requset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountRegistReply::set_has_requset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountRegistReply::clear_has_requset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountRegistReply::clear_requset() {
  if (requset_ != NULL) requset_->::Packet::AccountRegist::Clear();
  clear_has_requset();
  SetDirty();
}
inline const ::Packet::AccountRegist& AccountRegistReply::requset() const {
  return requset_ != NULL ? *requset_ : *default_instance_->requset_;
}
inline ::Packet::AccountRegist* AccountRegistReply::mutable_requset() {
  SetDirty();
  set_has_requset();
  if (requset_ == NULL) requset_ = new ::Packet::AccountRegist;
  return requset_;
}
inline ::Packet::AccountRegist* AccountRegistReply::release_requset() {
  SetDirty();
  clear_has_requset();
  ::Packet::AccountRegist* temp = requset_;
  requset_ = NULL;
  return temp;
}
inline void AccountRegistReply::set_allocated_requset(::Packet::AccountRegist* requset) {
  SetDirty();
  delete requset_;
  requset_ = requset;
  if (requset) {
    set_has_requset();
  } else {
    clear_has_requset();
  }
}

// required .Packet.AccountRegistReply.Result result = 2;
inline bool AccountRegistReply::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountRegistReply::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountRegistReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountRegistReply::clear_result() {
  result_ = 0;
  clear_has_result();
  SetDirty();
}
inline ::Packet::AccountRegistReply_Result AccountRegistReply::result() const {
  return static_cast< ::Packet::AccountRegistReply_Result >(result_);
}
inline void AccountRegistReply::set_result(::Packet::AccountRegistReply_Result value) {
  assert(::Packet::AccountRegistReply_Result_IsValid(value));
  SetDirty();
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// LoginRequest

// required string version = 1;
inline bool LoginRequest::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
  SetDirty();
}
inline const ::std::string& LoginRequest::version() const {
  return *version_;
}
inline void LoginRequest::set_version(const ::std::string& value) {
  SetDirty();
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginRequest::set_version(const char* value) {
  SetDirty();
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginRequest::set_version(const char* value, size_t size) {
  SetDirty();
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_version() {
  SetDirty();
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* LoginRequest::release_version() {
  SetDirty();
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_version(::std::string* version) {
  SetDirty();
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string userid = 2;
inline bool LoginRequest::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
  SetDirty();
}
inline const ::std::string& LoginRequest::userid() const {
  return *userid_;
}
inline void LoginRequest::set_userid(const ::std::string& value) {
  SetDirty();
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void LoginRequest::set_userid(const char* value) {
  SetDirty();
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void LoginRequest::set_userid(const char* value, size_t size) {
  SetDirty();
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_userid() {
  SetDirty();
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* LoginRequest::release_userid() {
  SetDirty();
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_userid(::std::string* userid) {
  SetDirty();
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 3;
inline bool LoginRequest::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
  SetDirty();
}
inline const ::std::string& LoginRequest::password() const {
  return *password_;
}
inline void LoginRequest::set_password(const ::std::string& value) {
  SetDirty();
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value) {
  SetDirty();
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value, size_t size) {
  SetDirty();
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_password() {
  SetDirty();
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginRequest::release_password() {
  SetDirty();
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_password(::std::string* password) {
  SetDirty();
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Packet.AccountType type = 4;
inline bool LoginRequest::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRequest::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRequest::clear_type() {
  type_ = 0;
  clear_has_type();
  SetDirty();
}
inline ::Packet::AccountType LoginRequest::type() const {
  return static_cast< ::Packet::AccountType >(type_);
}
inline void LoginRequest::set_type(::Packet::AccountType value) {
  assert(::Packet::AccountType_IsValid(value));
  SetDirty();
  set_has_type();
  type_ = value;
}

// required string loginkey = 5;
inline bool LoginRequest::has_loginkey() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginRequest::set_has_loginkey() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginRequest::clear_has_loginkey() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginRequest::clear_loginkey() {
  if (loginkey_ != &::google::protobuf::internal::kEmptyString) {
    loginkey_->clear();
  }
  clear_has_loginkey();
  SetDirty();
}
inline const ::std::string& LoginRequest::loginkey() const {
  return *loginkey_;
}
inline void LoginRequest::set_loginkey(const ::std::string& value) {
  SetDirty();
  set_has_loginkey();
  if (loginkey_ == &::google::protobuf::internal::kEmptyString) {
    loginkey_ = new ::std::string;
  }
  loginkey_->assign(value);
}
inline void LoginRequest::set_loginkey(const char* value) {
  SetDirty();
  set_has_loginkey();
  if (loginkey_ == &::google::protobuf::internal::kEmptyString) {
    loginkey_ = new ::std::string;
  }
  loginkey_->assign(value);
}
inline void LoginRequest::set_loginkey(const char* value, size_t size) {
  SetDirty();
  set_has_loginkey();
  if (loginkey_ == &::google::protobuf::internal::kEmptyString) {
    loginkey_ = new ::std::string;
  }
  loginkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_loginkey() {
  SetDirty();
  set_has_loginkey();
  if (loginkey_ == &::google::protobuf::internal::kEmptyString) {
    loginkey_ = new ::std::string;
  }
  return loginkey_;
}
inline ::std::string* LoginRequest::release_loginkey() {
  SetDirty();
  clear_has_loginkey();
  if (loginkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = loginkey_;
    loginkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_loginkey(::std::string* loginkey) {
  SetDirty();
  if (loginkey_ != &::google::protobuf::internal::kEmptyString) {
    delete loginkey_;
  }
  if (loginkey) {
    set_has_loginkey();
    loginkey_ = loginkey;
  } else {
    clear_has_loginkey();
    loginkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 partnerid = 6;
inline bool LoginRequest::has_partnerid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginRequest::set_has_partnerid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginRequest::clear_has_partnerid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginRequest::clear_partnerid() {
  partnerid_ = 0;
  clear_has_partnerid();
  SetDirty();
}
inline ::google::protobuf::int32 LoginRequest::partnerid() const {
  return partnerid_;
}
inline void LoginRequest::set_partnerid(::google::protobuf::int32 value) {
  SetDirty();
  set_has_partnerid();
  partnerid_ = value;
}

// required string device_type = 7;
inline bool LoginRequest::has_device_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginRequest::set_has_device_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginRequest::clear_has_device_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginRequest::clear_device_type() {
  if (device_type_ != &::google::protobuf::internal::kEmptyString) {
    device_type_->clear();
  }
  clear_has_device_type();
  SetDirty();
}
inline const ::std::string& LoginRequest::device_type() const {
  return *device_type_;
}
inline void LoginRequest::set_device_type(const ::std::string& value) {
  SetDirty();
  set_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    device_type_ = new ::std::string;
  }
  device_type_->assign(value);
}
inline void LoginRequest::set_device_type(const char* value) {
  SetDirty();
  set_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    device_type_ = new ::std::string;
  }
  device_type_->assign(value);
}
inline void LoginRequest::set_device_type(const char* value, size_t size) {
  SetDirty();
  set_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    device_type_ = new ::std::string;
  }
  device_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_device_type() {
  SetDirty();
  set_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    device_type_ = new ::std::string;
  }
  return device_type_;
}
inline ::std::string* LoginRequest::release_device_type() {
  SetDirty();
  clear_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_type_;
    device_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_device_type(::std::string* device_type) {
  SetDirty();
  if (device_type_ != &::google::protobuf::internal::kEmptyString) {
    delete device_type_;
  }
  if (device_type) {
    set_has_device_type();
    device_type_ = device_type;
  } else {
    clear_has_device_type();
    device_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string udid = 8;
inline bool LoginRequest::has_udid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginRequest::set_has_udid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginRequest::clear_has_udid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginRequest::clear_udid() {
  if (udid_ != &::google::protobuf::internal::kEmptyString) {
    udid_->clear();
  }
  clear_has_udid();
  SetDirty();
}
inline const ::std::string& LoginRequest::udid() const {
  return *udid_;
}
inline void LoginRequest::set_udid(const ::std::string& value) {
  SetDirty();
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(value);
}
inline void LoginRequest::set_udid(const char* value) {
  SetDirty();
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(value);
}
inline void LoginRequest::set_udid(const char* value, size_t size) {
  SetDirty();
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_udid() {
  SetDirty();
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  return udid_;
}
inline ::std::string* LoginRequest::release_udid() {
  SetDirty();
  clear_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = udid_;
    udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_udid(::std::string* udid) {
  SetDirty();
  if (udid_ != &::google::protobuf::internal::kEmptyString) {
    delete udid_;
  }
  if (udid) {
    set_has_udid();
    udid_ = udid;
  } else {
    clear_has_udid();
    udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string osversion = 9;
inline bool LoginRequest::has_osversion() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginRequest::set_has_osversion() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoginRequest::clear_has_osversion() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoginRequest::clear_osversion() {
  if (osversion_ != &::google::protobuf::internal::kEmptyString) {
    osversion_->clear();
  }
  clear_has_osversion();
  SetDirty();
}
inline const ::std::string& LoginRequest::osversion() const {
  return *osversion_;
}
inline void LoginRequest::set_osversion(const ::std::string& value) {
  SetDirty();
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  osversion_->assign(value);
}
inline void LoginRequest::set_osversion(const char* value) {
  SetDirty();
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  osversion_->assign(value);
}
inline void LoginRequest::set_osversion(const char* value, size_t size) {
  SetDirty();
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  osversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_osversion() {
  SetDirty();
  set_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    osversion_ = new ::std::string;
  }
  return osversion_;
}
inline ::std::string* LoginRequest::release_osversion() {
  SetDirty();
  clear_has_osversion();
  if (osversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = osversion_;
    osversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_osversion(::std::string* osversion) {
  SetDirty();
  if (osversion_ != &::google::protobuf::internal::kEmptyString) {
    delete osversion_;
  }
  if (osversion) {
    set_has_osversion();
    osversion_ = osversion;
  } else {
    clear_has_osversion();
    osversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string login_ip = 10;
inline bool LoginRequest::has_login_ip() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoginRequest::set_has_login_ip() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LoginRequest::clear_has_login_ip() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LoginRequest::clear_login_ip() {
  if (login_ip_ != &::google::protobuf::internal::kEmptyString) {
    login_ip_->clear();
  }
  clear_has_login_ip();
  SetDirty();
}
inline const ::std::string& LoginRequest::login_ip() const {
  return *login_ip_;
}
inline void LoginRequest::set_login_ip(const ::std::string& value) {
  SetDirty();
  set_has_login_ip();
  if (login_ip_ == &::google::protobuf::internal::kEmptyString) {
    login_ip_ = new ::std::string;
  }
  login_ip_->assign(value);
}
inline void LoginRequest::set_login_ip(const char* value) {
  SetDirty();
  set_has_login_ip();
  if (login_ip_ == &::google::protobuf::internal::kEmptyString) {
    login_ip_ = new ::std::string;
  }
  login_ip_->assign(value);
}
inline void LoginRequest::set_login_ip(const char* value, size_t size) {
  SetDirty();
  set_has_login_ip();
  if (login_ip_ == &::google::protobuf::internal::kEmptyString) {
    login_ip_ = new ::std::string;
  }
  login_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_login_ip() {
  SetDirty();
  set_has_login_ip();
  if (login_ip_ == &::google::protobuf::internal::kEmptyString) {
    login_ip_ = new ::std::string;
  }
  return login_ip_;
}
inline ::std::string* LoginRequest::release_login_ip() {
  SetDirty();
  clear_has_login_ip();
  if (login_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = login_ip_;
    login_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_login_ip(::std::string* login_ip) {
  SetDirty();
  if (login_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete login_ip_;
  }
  if (login_ip) {
    set_has_login_ip();
    login_ip_ = login_ip;
  } else {
    clear_has_login_ip();
    login_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 gameversionid = 11;
inline bool LoginRequest::has_gameversionid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LoginRequest::set_has_gameversionid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LoginRequest::clear_has_gameversionid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LoginRequest::clear_gameversionid() {
  gameversionid_ = 0;
  clear_has_gameversionid();
  SetDirty();
}
inline ::google::protobuf::int32 LoginRequest::gameversionid() const {
  return gameversionid_;
}
inline void LoginRequest::set_gameversionid(::google::protobuf::int32 value) {
  SetDirty();
  set_has_gameversionid();
  gameversionid_ = value;
}

// -------------------------------------------------------------------

// LoginReply

// required .Packet.LoginReply.Result result = 1;
inline bool LoginReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReply::clear_result() {
  result_ = 0;
  clear_has_result();
  SetDirty();
}
inline ::Packet::LoginReply_Result LoginReply::result() const {
  return static_cast< ::Packet::LoginReply_Result >(result_);
}
inline void LoginReply::set_result(::Packet::LoginReply_Result value) {
  assert(::Packet::LoginReply_Result_IsValid(value));
  SetDirty();
  set_has_result();
  result_ = value;
}

// optional string version = 2;
inline bool LoginReply::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginReply::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginReply::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginReply::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
  SetDirty();
}
inline const ::std::string& LoginReply::version() const {
  return *version_;
}
inline void LoginReply::set_version(const ::std::string& value) {
  SetDirty();
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginReply::set_version(const char* value) {
  SetDirty();
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginReply::set_version(const char* value, size_t size) {
  SetDirty();
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReply::mutable_version() {
  SetDirty();
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* LoginReply::release_version() {
  SetDirty();
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReply::set_allocated_version(::std::string* version) {
  SetDirty();
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AccountPlayerList

// -------------------------------------------------------------------

// AccountModel

// required fixed64 guid = 1;
inline bool AccountModel::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountModel::set_has_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountModel::clear_has_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountModel::clear_guid() {
  guid_ = GOOGLE_ULONGLONG(0);
  clear_has_guid();
  SetDirty();
}
inline ::google::protobuf::uint64 AccountModel::guid() const {
  return guid_;
}
inline void AccountModel::set_guid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_guid();
  guid_ = value;
}

// required string userid = 2;
inline bool AccountModel::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountModel::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountModel::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountModel::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
  SetDirty();
}
inline const ::std::string& AccountModel::userid() const {
  return *userid_;
}
inline void AccountModel::set_userid(const ::std::string& value) {
  SetDirty();
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void AccountModel::set_userid(const char* value) {
  SetDirty();
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void AccountModel::set_userid(const char* value, size_t size) {
  SetDirty();
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountModel::mutable_userid() {
  SetDirty();
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* AccountModel::release_userid() {
  SetDirty();
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountModel::set_allocated_userid(::std::string* userid) {
  SetDirty();
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 3;
inline bool AccountModel::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountModel::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountModel::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountModel::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
  SetDirty();
}
inline const ::std::string& AccountModel::password() const {
  return *password_;
}
inline void AccountModel::set_password(const ::std::string& value) {
  SetDirty();
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void AccountModel::set_password(const char* value) {
  SetDirty();
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void AccountModel::set_password(const char* value, size_t size) {
  SetDirty();
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountModel::mutable_password() {
  SetDirty();
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* AccountModel::release_password() {
  SetDirty();
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountModel::set_allocated_password(::std::string* password) {
  SetDirty();
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Packet.AccountType account_type = 4;
inline bool AccountModel::has_account_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountModel::set_has_account_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountModel::clear_has_account_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountModel::clear_account_type() {
  account_type_ = 0;
  clear_has_account_type();
  SetDirty();
}
inline ::Packet::AccountType AccountModel::account_type() const {
  return static_cast< ::Packet::AccountType >(account_type_);
}
inline void AccountModel::set_account_type(::Packet::AccountType value) {
  assert(::Packet::AccountType_IsValid(value));
  SetDirty();
  set_has_account_type();
  account_type_ = value;
}

// required string udid = 5;
inline bool AccountModel::has_udid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountModel::set_has_udid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountModel::clear_has_udid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountModel::clear_udid() {
  if (udid_ != &::google::protobuf::internal::kEmptyString) {
    udid_->clear();
  }
  clear_has_udid();
  SetDirty();
}
inline const ::std::string& AccountModel::udid() const {
  return *udid_;
}
inline void AccountModel::set_udid(const ::std::string& value) {
  SetDirty();
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(value);
}
inline void AccountModel::set_udid(const char* value) {
  SetDirty();
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(value);
}
inline void AccountModel::set_udid(const char* value, size_t size) {
  SetDirty();
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountModel::mutable_udid() {
  SetDirty();
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  return udid_;
}
inline ::std::string* AccountModel::release_udid() {
  SetDirty();
  clear_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = udid_;
    udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountModel::set_allocated_udid(::std::string* udid) {
  SetDirty();
  if (udid_ != &::google::protobuf::internal::kEmptyString) {
    delete udid_;
  }
  if (udid) {
    set_has_udid();
    udid_ = udid;
  } else {
    clear_has_udid();
    udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 partnerid = 6;
inline bool AccountModel::has_partnerid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AccountModel::set_has_partnerid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AccountModel::clear_has_partnerid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AccountModel::clear_partnerid() {
  partnerid_ = 0;
  clear_has_partnerid();
  SetDirty();
}
inline ::google::protobuf::int32 AccountModel::partnerid() const {
  return partnerid_;
}
inline void AccountModel::set_partnerid(::google::protobuf::int32 value) {
  SetDirty();
  set_has_partnerid();
  partnerid_ = value;
}

// -------------------------------------------------------------------

// AccountPlayerListReply

// repeated .Packet.PlayerDBInfo player_list = 1;
inline int AccountPlayerListReply::player_list_size() const {
  return player_list_.size();
}
inline void AccountPlayerListReply::clear_player_list() {
  player_list_.Clear();
  SetDirty();
}
inline const ::Packet::PlayerDBInfo& AccountPlayerListReply::player_list(int index) const {
  return player_list_.Get(index);
}
inline ::Packet::PlayerDBInfo* AccountPlayerListReply::mutable_player_list(int index) {
  SetDirty();
  return player_list_.Mutable(index);
}
inline ::Packet::PlayerDBInfo* AccountPlayerListReply::add_player_list() {
  SetDirty();
  return player_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Packet::PlayerDBInfo >&
AccountPlayerListReply::player_list() const {
  return player_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Packet::PlayerDBInfo >*
AccountPlayerListReply::mutable_player_list() {
  SetDirty();
  return &player_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Packet

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Packet::AccountNameVerifyReply_Result>() {
  return ::Packet::AccountNameVerifyReply_Result_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Packet::AccountRegistReply_Result>() {
  return ::Packet::AccountRegistReply_Result_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Packet::LoginReply_Result>() {
  return ::Packet::LoginReply_Result_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_LoginPacket_2eproto__INCLUDED
