// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SkillConfig.proto

#ifndef PROTOBUF_SkillConfig_2eproto__INCLUDED
#define PROTOBUF_SkillConfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "ProtoBufOption.pb.h"
#include "AllConfigEnum.pb.h"
#include "AllPacketEnum.pb.h"
#include "BattleInfo.pb.h"
#include "ActorBasicInfo.pb.h"
// @@protoc_insertion_point(includes)

namespace Config {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SkillConfig_2eproto();
void protobuf_AssignDesc_SkillConfig_2eproto();
void protobuf_ShutdownFile_SkillConfig_2eproto();

class TargetSelectLogic;
class TargetSelectExtra;
class SkillConfig;
class ImpactConfig;
class SkillBuildConfig;
class BuffDefine;

// ===================================================================

class TargetSelectLogic : public ::google::protobuf::Message {
 public:
  TargetSelectLogic();
  virtual ~TargetSelectLogic();

  TargetSelectLogic(const TargetSelectLogic& from);

  inline TargetSelectLogic& operator=(const TargetSelectLogic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetSelectLogic& default_instance();

  void Swap(TargetSelectLogic* other);

  // implements Message ----------------------------------------------

  TargetSelectLogic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetSelectLogic& from);
  void MergeFrom(const TargetSelectLogic& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Config.TargetSortType sort_type = 1;
  inline bool has_sort_type() const;
  inline void clear_sort_type();
  static const int kSortTypeFieldNumber = 1;
  inline ::Config::TargetSortType sort_type() const;
  inline void set_sort_type(::Config::TargetSortType value);

  // required .Config.TargetCamp target_camp = 2;
  inline bool has_target_camp() const;
  inline void clear_target_camp();
  static const int kTargetCampFieldNumber = 2;
  inline ::Config::TargetCamp target_camp() const;
  inline void set_target_camp(::Config::TargetCamp value);

  // required int32 range = 3;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 3;
  inline ::google::protobuf::int32 range() const;
  inline void set_range(::google::protobuf::int32 value);

  // required int32 min_count = 4;
  inline bool has_min_count() const;
  inline void clear_min_count();
  static const int kMinCountFieldNumber = 4;
  inline ::google::protobuf::int32 min_count() const;
  inline void set_min_count(::google::protobuf::int32 value);

  // required int32 max_count = 5;
  inline bool has_max_count() const;
  inline void clear_max_count();
  static const int kMaxCountFieldNumber = 5;
  inline ::google::protobuf::int32 max_count() const;
  inline void set_max_count(::google::protobuf::int32 value);

  // required .Config.AreaType area_type = 6;
  inline bool has_area_type() const;
  inline void clear_area_type();
  static const int kAreaTypeFieldNumber = 6;
  inline ::Config::AreaType area_type() const;
  inline void set_area_type(::Config::AreaType value);

  // required int32 param_1 = 7;
  inline bool has_param_1() const;
  inline void clear_param_1();
  static const int kParam1FieldNumber = 7;
  inline ::google::protobuf::int32 param_1() const;
  inline void set_param_1(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Config.TargetSelectLogic)
 private:
  inline void set_has_sort_type();
  inline void clear_has_sort_type();
  inline void set_has_target_camp();
  inline void clear_has_target_camp();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_min_count();
  inline void clear_has_min_count();
  inline void set_has_max_count();
  inline void clear_has_max_count();
  inline void set_has_area_type();
  inline void clear_has_area_type();
  inline void set_has_param_1();
  inline void clear_has_param_1();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int sort_type_;
  int target_camp_;
  ::google::protobuf::int32 range_;
  ::google::protobuf::int32 min_count_;
  ::google::protobuf::int32 max_count_;
  int area_type_;
  ::google::protobuf::int32 param_1_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_SkillConfig_2eproto();
  friend void protobuf_AssignDesc_SkillConfig_2eproto();
  friend void protobuf_ShutdownFile_SkillConfig_2eproto();

  void InitAsDefaultInstance();
  static TargetSelectLogic* default_instance_;
};
// -------------------------------------------------------------------

class TargetSelectExtra : public ::google::protobuf::Message {
 public:
  TargetSelectExtra();
  virtual ~TargetSelectExtra();

  TargetSelectExtra(const TargetSelectExtra& from);

  inline TargetSelectExtra& operator=(const TargetSelectExtra& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetSelectExtra& default_instance();

  void Swap(TargetSelectExtra* other);

  // implements Message ----------------------------------------------

  TargetSelectExtra* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetSelectExtra& from);
  void MergeFrom(const TargetSelectExtra& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Config.TargetSortType sort_type = 1;
  inline bool has_sort_type() const;
  inline void clear_sort_type();
  static const int kSortTypeFieldNumber = 1;
  inline ::Config::TargetSortType sort_type() const;
  inline void set_sort_type(::Config::TargetSortType value);

  // required int32 range = 2;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 2;
  inline ::google::protobuf::int32 range() const;
  inline void set_range(::google::protobuf::int32 value);

  // required int32 max_count = 3;
  inline bool has_max_count() const;
  inline void clear_max_count();
  static const int kMaxCountFieldNumber = 3;
  inline ::google::protobuf::int32 max_count() const;
  inline void set_max_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Config.TargetSelectExtra)
 private:
  inline void set_has_sort_type();
  inline void clear_has_sort_type();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_max_count();
  inline void clear_has_max_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int sort_type_;
  ::google::protobuf::int32 range_;
  ::google::protobuf::int32 max_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SkillConfig_2eproto();
  friend void protobuf_AssignDesc_SkillConfig_2eproto();
  friend void protobuf_ShutdownFile_SkillConfig_2eproto();

  void InitAsDefaultInstance();
  static TargetSelectExtra* default_instance_;
};
// -------------------------------------------------------------------

class SkillConfig : public ::google::protobuf::Message {
 public:
  SkillConfig();
  virtual ~SkillConfig();

  SkillConfig(const SkillConfig& from);

  inline SkillConfig& operator=(const SkillConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SkillConfig& default_instance();

  void Swap(SkillConfig* other);

  // implements Message ----------------------------------------------

  SkillConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SkillConfig& from);
  void MergeFrom(const SkillConfig& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required int32 prefix_time = 3;
  inline bool has_prefix_time() const;
  inline void clear_prefix_time();
  static const int kPrefixTimeFieldNumber = 3;
  inline ::google::protobuf::int32 prefix_time() const;
  inline void set_prefix_time(::google::protobuf::int32 value);

  // required float bullet_speed = 4;
  inline bool has_bullet_speed() const;
  inline void clear_bullet_speed();
  static const int kBulletSpeedFieldNumber = 4;
  inline float bullet_speed() const;
  inline void set_bullet_speed(float value);

  // required int32 surffix_time = 5;
  inline bool has_surffix_time() const;
  inline void clear_surffix_time();
  static const int kSurffixTimeFieldNumber = 5;
  inline ::google::protobuf::int32 surffix_time() const;
  inline void set_surffix_time(::google::protobuf::int32 value);

  // required int32 cd_time = 6;
  inline bool has_cd_time() const;
  inline void clear_cd_time();
  static const int kCdTimeFieldNumber = 6;
  inline ::google::protobuf::int32 cd_time() const;
  inline void set_cd_time(::google::protobuf::int32 value);

  // required .Config.TargetSelectLogic skill_tar_logic = 7;
  inline bool has_skill_tar_logic() const;
  inline void clear_skill_tar_logic();
  static const int kSkillTarLogicFieldNumber = 7;
  inline const ::Config::TargetSelectLogic& skill_tar_logic() const;
  inline ::Config::TargetSelectLogic* mutable_skill_tar_logic();
  inline ::Config::TargetSelectLogic* release_skill_tar_logic();
  inline void set_allocated_skill_tar_logic(::Config::TargetSelectLogic* skill_tar_logic);

  // required .Config.TargetSelectExtra tar_extra = 8;
  inline bool has_tar_extra() const;
  inline void clear_tar_extra();
  static const int kTarExtraFieldNumber = 8;
  inline const ::Config::TargetSelectExtra& tar_extra() const;
  inline ::Config::TargetSelectExtra* mutable_tar_extra();
  inline ::Config::TargetSelectExtra* release_tar_extra();
  inline void set_allocated_tar_extra(::Config::TargetSelectExtra* tar_extra);

  // required .Config.SkillType skill_type = 9;
  inline bool has_skill_type() const;
  inline void clear_skill_type();
  static const int kSkillTypeFieldNumber = 9;
  inline ::Config::SkillType skill_type() const;
  inline void set_skill_type(::Config::SkillType value);

  // required .Packet.Property self_property = 14;
  inline bool has_self_property() const;
  inline void clear_self_property();
  static const int kSelfPropertyFieldNumber = 14;
  inline ::Packet::Property self_property() const;
  inline void set_self_property(::Packet::Property value);

  // required .Packet.Property target_property = 15;
  inline bool has_target_property() const;
  inline void clear_target_property();
  static const int kTargetPropertyFieldNumber = 15;
  inline ::Packet::Property target_property() const;
  inline void set_target_property(::Packet::Property value);

  // required string skill_effect = 16;
  inline bool has_skill_effect() const;
  inline void clear_skill_effect();
  static const int kSkillEffectFieldNumber = 16;
  inline const ::std::string& skill_effect() const;
  inline void set_skill_effect(const ::std::string& value);
  inline void set_skill_effect(const char* value);
  inline void set_skill_effect(const char* value, size_t size);
  inline ::std::string* mutable_skill_effect();
  inline ::std::string* release_skill_effect();
  inline void set_allocated_skill_effect(::std::string* skill_effect);

  // required int32 self_buff = 17;
  inline bool has_self_buff() const;
  inline void clear_self_buff();
  static const int kSelfBuffFieldNumber = 17;
  inline ::google::protobuf::int32 self_buff() const;
  inline void set_self_buff(::google::protobuf::int32 value);

  // repeated int32 buffs = 18;
  inline int buffs_size() const;
  inline void clear_buffs();
  static const int kBuffsFieldNumber = 18;
  inline ::google::protobuf::int32 buffs(int index) const;
  inline void set_buffs(int index, ::google::protobuf::int32 value);
  inline void add_buffs(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      buffs() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_buffs();

  // repeated .Config.TargetSelectLogic buff_tar_logics = 19;
  inline int buff_tar_logics_size() const;
  inline void clear_buff_tar_logics();
  static const int kBuffTarLogicsFieldNumber = 19;
  inline const ::Config::TargetSelectLogic& buff_tar_logics(int index) const;
  inline ::Config::TargetSelectLogic* mutable_buff_tar_logics(int index);
  inline ::Config::TargetSelectLogic* add_buff_tar_logics();
  inline const ::google::protobuf::RepeatedPtrField< ::Config::TargetSelectLogic >&
      buff_tar_logics() const;
  inline ::google::protobuf::RepeatedPtrField< ::Config::TargetSelectLogic >*
      mutable_buff_tar_logics();

  // repeated .Config.SkillConfig sub_skills = 20;
  inline int sub_skills_size() const;
  inline void clear_sub_skills();
  static const int kSubSkillsFieldNumber = 20;
  inline const ::Config::SkillConfig& sub_skills(int index) const;
  inline ::Config::SkillConfig* mutable_sub_skills(int index);
  inline ::Config::SkillConfig* add_sub_skills();
  inline const ::google::protobuf::RepeatedPtrField< ::Config::SkillConfig >&
      sub_skills() const;
  inline ::google::protobuf::RepeatedPtrField< ::Config::SkillConfig >*
      mutable_sub_skills();

  // required int32 parent_skill = 21;
  inline bool has_parent_skill() const;
  inline void clear_parent_skill();
  static const int kParentSkillFieldNumber = 21;
  inline ::google::protobuf::int32 parent_skill() const;
  inline void set_parent_skill(::google::protobuf::int32 value);

  // required float acce_factor = 22;
  inline bool has_acce_factor() const;
  inline void clear_acce_factor();
  static const int kAcceFactorFieldNumber = 22;
  inline float acce_factor() const;
  inline void set_acce_factor(float value);

  // required .Packet.Property self_property_revise_0 = 23;
  inline bool has_self_property_revise_0() const;
  inline void clear_self_property_revise_0();
  static const int kSelfPropertyRevise0FieldNumber = 23;
  inline ::Packet::Property self_property_revise_0() const;
  inline void set_self_property_revise_0(::Packet::Property value);

  // required float self_property_revise_value_0 = 24;
  inline bool has_self_property_revise_value_0() const;
  inline void clear_self_property_revise_value_0();
  static const int kSelfPropertyReviseValue0FieldNumber = 24;
  inline float self_property_revise_value_0() const;
  inline void set_self_property_revise_value_0(float value);

  // required .Config.PropertyReviseValueType self_property_revise_value_type_0 = 25;
  inline bool has_self_property_revise_value_type_0() const;
  inline void clear_self_property_revise_value_type_0();
  static const int kSelfPropertyReviseValueType0FieldNumber = 25;
  inline ::Config::PropertyReviseValueType self_property_revise_value_type_0() const;
  inline void set_self_property_revise_value_type_0(::Config::PropertyReviseValueType value);

  // required .Packet.Property buff_property_revise_0 = 26;
  inline bool has_buff_property_revise_0() const;
  inline void clear_buff_property_revise_0();
  static const int kBuffPropertyRevise0FieldNumber = 26;
  inline ::Packet::Property buff_property_revise_0() const;
  inline void set_buff_property_revise_0(::Packet::Property value);

  // required float buff_property_revise_value_0 = 27;
  inline bool has_buff_property_revise_value_0() const;
  inline void clear_buff_property_revise_value_0();
  static const int kBuffPropertyReviseValue0FieldNumber = 27;
  inline float buff_property_revise_value_0() const;
  inline void set_buff_property_revise_value_0(float value);

  // required .Config.PropertyReviseValueType buff_property_revise_value_type_0 = 28;
  inline bool has_buff_property_revise_value_type_0() const;
  inline void clear_buff_property_revise_value_type_0();
  static const int kBuffPropertyReviseValueType0FieldNumber = 28;
  inline ::Config::PropertyReviseValueType buff_property_revise_value_type_0() const;
  inline void set_buff_property_revise_value_type_0(::Config::PropertyReviseValueType value);

  // required string position_effect = 29;
  inline bool has_position_effect() const;
  inline void clear_position_effect();
  static const int kPositionEffectFieldNumber = 29;
  inline const ::std::string& position_effect() const;
  inline void set_position_effect(const ::std::string& value);
  inline void set_position_effect(const char* value);
  inline void set_position_effect(const char* value, size_t size);
  inline ::std::string* mutable_position_effect();
  inline ::std::string* release_position_effect();
  inline void set_allocated_position_effect(::std::string* position_effect);

  // required int32 effect_param_0 = 30;
  inline bool has_effect_param_0() const;
  inline void clear_effect_param_0();
  static const int kEffectParam0FieldNumber = 30;
  inline ::google::protobuf::int32 effect_param_0() const;
  inline void set_effect_param_0(::google::protobuf::int32 value);

  // required int32 effect_param_1 = 31;
  inline bool has_effect_param_1() const;
  inline void clear_effect_param_1();
  static const int kEffectParam1FieldNumber = 31;
  inline ::google::protobuf::int32 effect_param_1() const;
  inline void set_effect_param_1(::google::protobuf::int32 value);

  // required int32 effect_param_2 = 32;
  inline bool has_effect_param_2() const;
  inline void clear_effect_param_2();
  static const int kEffectParam2FieldNumber = 32;
  inline ::google::protobuf::int32 effect_param_2() const;
  inline void set_effect_param_2(::google::protobuf::int32 value);

  // repeated string effect_param_str = 33;
  inline int effect_param_str_size() const;
  inline void clear_effect_param_str();
  static const int kEffectParamStrFieldNumber = 33;
  inline const ::std::string& effect_param_str(int index) const;
  inline ::std::string* mutable_effect_param_str(int index);
  inline void set_effect_param_str(int index, const ::std::string& value);
  inline void set_effect_param_str(int index, const char* value);
  inline void set_effect_param_str(int index, const char* value, size_t size);
  inline ::std::string* add_effect_param_str();
  inline void add_effect_param_str(const ::std::string& value);
  inline void add_effect_param_str(const char* value);
  inline void add_effect_param_str(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& effect_param_str() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_effect_param_str();

  // required bool is_sneak = 34;
  inline bool has_is_sneak() const;
  inline void clear_is_sneak();
  static const int kIsSneakFieldNumber = 34;
  inline bool is_sneak() const;
  inline void set_is_sneak(bool value);

  // @@protoc_insertion_point(class_scope:Config.SkillConfig)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_prefix_time();
  inline void clear_has_prefix_time();
  inline void set_has_bullet_speed();
  inline void clear_has_bullet_speed();
  inline void set_has_surffix_time();
  inline void clear_has_surffix_time();
  inline void set_has_cd_time();
  inline void clear_has_cd_time();
  inline void set_has_skill_tar_logic();
  inline void clear_has_skill_tar_logic();
  inline void set_has_tar_extra();
  inline void clear_has_tar_extra();
  inline void set_has_skill_type();
  inline void clear_has_skill_type();
  inline void set_has_self_property();
  inline void clear_has_self_property();
  inline void set_has_target_property();
  inline void clear_has_target_property();
  inline void set_has_skill_effect();
  inline void clear_has_skill_effect();
  inline void set_has_self_buff();
  inline void clear_has_self_buff();
  inline void set_has_parent_skill();
  inline void clear_has_parent_skill();
  inline void set_has_acce_factor();
  inline void clear_has_acce_factor();
  inline void set_has_self_property_revise_0();
  inline void clear_has_self_property_revise_0();
  inline void set_has_self_property_revise_value_0();
  inline void clear_has_self_property_revise_value_0();
  inline void set_has_self_property_revise_value_type_0();
  inline void clear_has_self_property_revise_value_type_0();
  inline void set_has_buff_property_revise_0();
  inline void clear_has_buff_property_revise_0();
  inline void set_has_buff_property_revise_value_0();
  inline void clear_has_buff_property_revise_value_0();
  inline void set_has_buff_property_revise_value_type_0();
  inline void clear_has_buff_property_revise_value_type_0();
  inline void set_has_position_effect();
  inline void clear_has_position_effect();
  inline void set_has_effect_param_0();
  inline void clear_has_effect_param_0();
  inline void set_has_effect_param_1();
  inline void clear_has_effect_param_1();
  inline void set_has_effect_param_2();
  inline void clear_has_effect_param_2();
  inline void set_has_is_sneak();
  inline void clear_has_is_sneak();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 prefix_time_;
  float bullet_speed_;
  ::google::protobuf::int32 surffix_time_;
  ::google::protobuf::int32 cd_time_;
  ::Config::TargetSelectLogic* skill_tar_logic_;
  ::Config::TargetSelectExtra* tar_extra_;
  int skill_type_;
  int self_property_;
  ::std::string* skill_effect_;
  int target_property_;
  ::google::protobuf::int32 self_buff_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > buffs_;
  ::google::protobuf::RepeatedPtrField< ::Config::TargetSelectLogic > buff_tar_logics_;
  ::google::protobuf::RepeatedPtrField< ::Config::SkillConfig > sub_skills_;
  ::google::protobuf::int32 parent_skill_;
  float acce_factor_;
  int self_property_revise_0_;
  float self_property_revise_value_0_;
  int self_property_revise_value_type_0_;
  int buff_property_revise_0_;
  float buff_property_revise_value_0_;
  int buff_property_revise_value_type_0_;
  ::std::string* position_effect_;
  ::google::protobuf::int32 effect_param_0_;
  ::google::protobuf::int32 effect_param_1_;
  ::google::protobuf::RepeatedPtrField< ::std::string> effect_param_str_;
  ::google::protobuf::int32 effect_param_2_;
  bool is_sneak_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(30 + 31) / 32];

  friend void  protobuf_AddDesc_SkillConfig_2eproto();
  friend void protobuf_AssignDesc_SkillConfig_2eproto();
  friend void protobuf_ShutdownFile_SkillConfig_2eproto();

  void InitAsDefaultInstance();
  static SkillConfig* default_instance_;
};
// -------------------------------------------------------------------

class ImpactConfig : public ::google::protobuf::Message {
 public:
  ImpactConfig();
  virtual ~ImpactConfig();

  ImpactConfig(const ImpactConfig& from);

  inline ImpactConfig& operator=(const ImpactConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImpactConfig& default_instance();

  void Swap(ImpactConfig* other);

  // implements Message ----------------------------------------------

  ImpactConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImpactConfig& from);
  void MergeFrom(const ImpactConfig& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string impact_logic = 2;
  inline bool has_impact_logic() const;
  inline void clear_impact_logic();
  static const int kImpactLogicFieldNumber = 2;
  inline const ::std::string& impact_logic() const;
  inline void set_impact_logic(const ::std::string& value);
  inline void set_impact_logic(const char* value);
  inline void set_impact_logic(const char* value, size_t size);
  inline ::std::string* mutable_impact_logic();
  inline ::std::string* release_impact_logic();
  inline void set_allocated_impact_logic(::std::string* impact_logic);

  // required .Config.ImpactEffectType effect_type = 3;
  inline bool has_effect_type() const;
  inline void clear_effect_type();
  static const int kEffectTypeFieldNumber = 3;
  inline ::Config::ImpactEffectType effect_type() const;
  inline void set_effect_type(::Config::ImpactEffectType value);

  // required int32 max_layer = 4;
  inline bool has_max_layer() const;
  inline void clear_max_layer();
  static const int kMaxLayerFieldNumber = 4;
  inline ::google::protobuf::int32 max_layer() const;
  inline void set_max_layer(::google::protobuf::int32 value);

  // required int32 mutex_id = 5;
  inline bool has_mutex_id() const;
  inline void clear_mutex_id();
  static const int kMutexIdFieldNumber = 5;
  inline ::google::protobuf::int32 mutex_id() const;
  inline void set_mutex_id(::google::protobuf::int32 value);

  // required int32 priority = 6;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 6;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // required int32 last_time = 7;
  inline bool has_last_time() const;
  inline void clear_last_time();
  static const int kLastTimeFieldNumber = 7;
  inline ::google::protobuf::int32 last_time() const;
  inline void set_last_time(::google::protobuf::int32 value);

  // required int32 trigger_freq = 8;
  inline bool has_trigger_freq() const;
  inline void clear_trigger_freq();
  static const int kTriggerFreqFieldNumber = 8;
  inline ::google::protobuf::int32 trigger_freq() const;
  inline void set_trigger_freq(::google::protobuf::int32 value);

  // required int32 effect_times = 9;
  inline bool has_effect_times() const;
  inline void clear_effect_times();
  static const int kEffectTimesFieldNumber = 9;
  inline ::google::protobuf::int32 effect_times() const;
  inline void set_effect_times(::google::protobuf::int32 value);

  // repeated int32 param_types = 10;
  inline int param_types_size() const;
  inline void clear_param_types();
  static const int kParamTypesFieldNumber = 10;
  inline ::google::protobuf::int32 param_types(int index) const;
  inline void set_param_types(int index, ::google::protobuf::int32 value);
  inline void add_param_types(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      param_types() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_param_types();

  // repeated float param_values = 11;
  inline int param_values_size() const;
  inline void clear_param_values();
  static const int kParamValuesFieldNumber = 11;
  inline float param_values(int index) const;
  inline void set_param_values(int index, float value);
  inline void add_param_values(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      param_values() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_param_values();

  // required .Config.TargetSelectLogic buff_tar_logic = 12;
  inline bool has_buff_tar_logic() const;
  inline void clear_buff_tar_logic();
  static const int kBuffTarLogicFieldNumber = 12;
  inline const ::Config::TargetSelectLogic& buff_tar_logic() const;
  inline ::Config::TargetSelectLogic* mutable_buff_tar_logic();
  inline ::Config::TargetSelectLogic* release_buff_tar_logic();
  inline void set_allocated_buff_tar_logic(::Config::TargetSelectLogic* buff_tar_logic);

  // @@protoc_insertion_point(class_scope:Config.ImpactConfig)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_impact_logic();
  inline void clear_has_impact_logic();
  inline void set_has_effect_type();
  inline void clear_has_effect_type();
  inline void set_has_max_layer();
  inline void clear_has_max_layer();
  inline void set_has_mutex_id();
  inline void clear_has_mutex_id();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_last_time();
  inline void clear_has_last_time();
  inline void set_has_trigger_freq();
  inline void clear_has_trigger_freq();
  inline void set_has_effect_times();
  inline void clear_has_effect_times();
  inline void set_has_buff_tar_logic();
  inline void clear_has_buff_tar_logic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* impact_logic_;
  ::google::protobuf::int32 id_;
  int effect_type_;
  ::google::protobuf::int32 max_layer_;
  ::google::protobuf::int32 mutex_id_;
  ::google::protobuf::int32 priority_;
  ::google::protobuf::int32 last_time_;
  ::google::protobuf::int32 trigger_freq_;
  ::google::protobuf::int32 effect_times_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > param_types_;
  ::google::protobuf::RepeatedField< float > param_values_;
  ::Config::TargetSelectLogic* buff_tar_logic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_SkillConfig_2eproto();
  friend void protobuf_AssignDesc_SkillConfig_2eproto();
  friend void protobuf_ShutdownFile_SkillConfig_2eproto();

  void InitAsDefaultInstance();
  static ImpactConfig* default_instance_;
};
// -------------------------------------------------------------------

class SkillBuildConfig : public ::google::protobuf::Message {
 public:
  SkillBuildConfig();
  virtual ~SkillBuildConfig();

  SkillBuildConfig(const SkillBuildConfig& from);

  inline SkillBuildConfig& operator=(const SkillBuildConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SkillBuildConfig& default_instance();

  void Swap(SkillBuildConfig* other);

  // implements Message ----------------------------------------------

  SkillBuildConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SkillBuildConfig& from);
  void MergeFrom(const SkillBuildConfig& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 actor_id = 1;
  inline bool has_actor_id() const;
  inline void clear_actor_id();
  static const int kActorIdFieldNumber = 1;
  inline ::google::protobuf::int32 actor_id() const;
  inline void set_actor_id(::google::protobuf::int32 value);

  // required .Packet.ActorColor color = 2;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline ::Packet::ActorColor color() const;
  inline void set_color(::Packet::ActorColor value);

  // repeated int32 skill_ids = 3;
  inline int skill_ids_size() const;
  inline void clear_skill_ids();
  static const int kSkillIdsFieldNumber = 3;
  inline ::google::protobuf::int32 skill_ids(int index) const;
  inline void set_skill_ids(int index, ::google::protobuf::int32 value);
  inline void add_skill_ids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      skill_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_skill_ids();

  // @@protoc_insertion_point(class_scope:Config.SkillBuildConfig)
 private:
  inline void set_has_actor_id();
  inline void clear_has_actor_id();
  inline void set_has_color();
  inline void clear_has_color();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 actor_id_;
  int color_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > skill_ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SkillConfig_2eproto();
  friend void protobuf_AssignDesc_SkillConfig_2eproto();
  friend void protobuf_ShutdownFile_SkillConfig_2eproto();

  void InitAsDefaultInstance();
  static SkillBuildConfig* default_instance_;
};
// -------------------------------------------------------------------

class BuffDefine : public ::google::protobuf::Message {
 public:
  BuffDefine();
  virtual ~BuffDefine();

  BuffDefine(const BuffDefine& from);

  inline BuffDefine& operator=(const BuffDefine& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffDefine& default_instance();

  void Swap(BuffDefine* other);

  // implements Message ----------------------------------------------

  BuffDefine* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffDefine& from);
  void MergeFrom(const BuffDefine& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Config.BuffType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Config::BuffType type() const;
  inline void set_type(::Config::BuffType value);

  // required bool is_debuff = 2;
  inline bool has_is_debuff() const;
  inline void clear_is_debuff();
  static const int kIsDebuffFieldNumber = 2;
  inline bool is_debuff() const;
  inline void set_is_debuff(bool value);

  // required bool can_despell = 3;
  inline bool has_can_despell() const;
  inline void clear_can_despell();
  static const int kCanDespellFieldNumber = 3;
  inline bool can_despell() const;
  inline void set_can_despell(bool value);

  // @@protoc_insertion_point(class_scope:Config.BuffDefine)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_is_debuff();
  inline void clear_has_is_debuff();
  inline void set_has_can_despell();
  inline void clear_has_can_despell();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  bool is_debuff_;
  bool can_despell_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SkillConfig_2eproto();
  friend void protobuf_AssignDesc_SkillConfig_2eproto();
  friend void protobuf_ShutdownFile_SkillConfig_2eproto();

  void InitAsDefaultInstance();
  static BuffDefine* default_instance_;
};
// ===================================================================


// ===================================================================

// TargetSelectLogic

// required .Config.TargetSortType sort_type = 1;
inline bool TargetSelectLogic::has_sort_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetSelectLogic::set_has_sort_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetSelectLogic::clear_has_sort_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetSelectLogic::clear_sort_type() {
  sort_type_ = 0;
  clear_has_sort_type();
  SetDirty();
}
inline ::Config::TargetSortType TargetSelectLogic::sort_type() const {
  return static_cast< ::Config::TargetSortType >(sort_type_);
}
inline void TargetSelectLogic::set_sort_type(::Config::TargetSortType value) {
  assert(::Config::TargetSortType_IsValid(value));
  SetDirty();
  set_has_sort_type();
  sort_type_ = value;
}

// required .Config.TargetCamp target_camp = 2;
inline bool TargetSelectLogic::has_target_camp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetSelectLogic::set_has_target_camp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TargetSelectLogic::clear_has_target_camp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TargetSelectLogic::clear_target_camp() {
  target_camp_ = 0;
  clear_has_target_camp();
  SetDirty();
}
inline ::Config::TargetCamp TargetSelectLogic::target_camp() const {
  return static_cast< ::Config::TargetCamp >(target_camp_);
}
inline void TargetSelectLogic::set_target_camp(::Config::TargetCamp value) {
  assert(::Config::TargetCamp_IsValid(value));
  SetDirty();
  set_has_target_camp();
  target_camp_ = value;
}

// required int32 range = 3;
inline bool TargetSelectLogic::has_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TargetSelectLogic::set_has_range() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TargetSelectLogic::clear_has_range() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TargetSelectLogic::clear_range() {
  range_ = 0;
  clear_has_range();
  SetDirty();
}
inline ::google::protobuf::int32 TargetSelectLogic::range() const {
  return range_;
}
inline void TargetSelectLogic::set_range(::google::protobuf::int32 value) {
  SetDirty();
  set_has_range();
  range_ = value;
}

// required int32 min_count = 4;
inline bool TargetSelectLogic::has_min_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TargetSelectLogic::set_has_min_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TargetSelectLogic::clear_has_min_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TargetSelectLogic::clear_min_count() {
  min_count_ = 0;
  clear_has_min_count();
  SetDirty();
}
inline ::google::protobuf::int32 TargetSelectLogic::min_count() const {
  return min_count_;
}
inline void TargetSelectLogic::set_min_count(::google::protobuf::int32 value) {
  SetDirty();
  set_has_min_count();
  min_count_ = value;
}

// required int32 max_count = 5;
inline bool TargetSelectLogic::has_max_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TargetSelectLogic::set_has_max_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TargetSelectLogic::clear_has_max_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TargetSelectLogic::clear_max_count() {
  max_count_ = 0;
  clear_has_max_count();
  SetDirty();
}
inline ::google::protobuf::int32 TargetSelectLogic::max_count() const {
  return max_count_;
}
inline void TargetSelectLogic::set_max_count(::google::protobuf::int32 value) {
  SetDirty();
  set_has_max_count();
  max_count_ = value;
}

// required .Config.AreaType area_type = 6;
inline bool TargetSelectLogic::has_area_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TargetSelectLogic::set_has_area_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TargetSelectLogic::clear_has_area_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TargetSelectLogic::clear_area_type() {
  area_type_ = 0;
  clear_has_area_type();
  SetDirty();
}
inline ::Config::AreaType TargetSelectLogic::area_type() const {
  return static_cast< ::Config::AreaType >(area_type_);
}
inline void TargetSelectLogic::set_area_type(::Config::AreaType value) {
  assert(::Config::AreaType_IsValid(value));
  SetDirty();
  set_has_area_type();
  area_type_ = value;
}

// required int32 param_1 = 7;
inline bool TargetSelectLogic::has_param_1() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TargetSelectLogic::set_has_param_1() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TargetSelectLogic::clear_has_param_1() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TargetSelectLogic::clear_param_1() {
  param_1_ = 0;
  clear_has_param_1();
  SetDirty();
}
inline ::google::protobuf::int32 TargetSelectLogic::param_1() const {
  return param_1_;
}
inline void TargetSelectLogic::set_param_1(::google::protobuf::int32 value) {
  SetDirty();
  set_has_param_1();
  param_1_ = value;
}

// -------------------------------------------------------------------

// TargetSelectExtra

// required .Config.TargetSortType sort_type = 1;
inline bool TargetSelectExtra::has_sort_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetSelectExtra::set_has_sort_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetSelectExtra::clear_has_sort_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetSelectExtra::clear_sort_type() {
  sort_type_ = 0;
  clear_has_sort_type();
  SetDirty();
}
inline ::Config::TargetSortType TargetSelectExtra::sort_type() const {
  return static_cast< ::Config::TargetSortType >(sort_type_);
}
inline void TargetSelectExtra::set_sort_type(::Config::TargetSortType value) {
  assert(::Config::TargetSortType_IsValid(value));
  SetDirty();
  set_has_sort_type();
  sort_type_ = value;
}

// required int32 range = 2;
inline bool TargetSelectExtra::has_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetSelectExtra::set_has_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TargetSelectExtra::clear_has_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TargetSelectExtra::clear_range() {
  range_ = 0;
  clear_has_range();
  SetDirty();
}
inline ::google::protobuf::int32 TargetSelectExtra::range() const {
  return range_;
}
inline void TargetSelectExtra::set_range(::google::protobuf::int32 value) {
  SetDirty();
  set_has_range();
  range_ = value;
}

// required int32 max_count = 3;
inline bool TargetSelectExtra::has_max_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TargetSelectExtra::set_has_max_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TargetSelectExtra::clear_has_max_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TargetSelectExtra::clear_max_count() {
  max_count_ = 0;
  clear_has_max_count();
  SetDirty();
}
inline ::google::protobuf::int32 TargetSelectExtra::max_count() const {
  return max_count_;
}
inline void TargetSelectExtra::set_max_count(::google::protobuf::int32 value) {
  SetDirty();
  set_has_max_count();
  max_count_ = value;
}

// -------------------------------------------------------------------

// SkillConfig

// required int32 id = 1;
inline bool SkillConfig::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkillConfig::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkillConfig::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkillConfig::clear_id() {
  id_ = 0;
  clear_has_id();
  SetDirty();
}
inline ::google::protobuf::int32 SkillConfig::id() const {
  return id_;
}
inline void SkillConfig::set_id(::google::protobuf::int32 value) {
  SetDirty();
  set_has_id();
  id_ = value;
}

// required int32 level = 2;
inline bool SkillConfig::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SkillConfig::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SkillConfig::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SkillConfig::clear_level() {
  level_ = 0;
  clear_has_level();
  SetDirty();
}
inline ::google::protobuf::int32 SkillConfig::level() const {
  return level_;
}
inline void SkillConfig::set_level(::google::protobuf::int32 value) {
  SetDirty();
  set_has_level();
  level_ = value;
}

// required int32 prefix_time = 3;
inline bool SkillConfig::has_prefix_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SkillConfig::set_has_prefix_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SkillConfig::clear_has_prefix_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SkillConfig::clear_prefix_time() {
  prefix_time_ = 0;
  clear_has_prefix_time();
  SetDirty();
}
inline ::google::protobuf::int32 SkillConfig::prefix_time() const {
  return prefix_time_;
}
inline void SkillConfig::set_prefix_time(::google::protobuf::int32 value) {
  SetDirty();
  set_has_prefix_time();
  prefix_time_ = value;
}

// required float bullet_speed = 4;
inline bool SkillConfig::has_bullet_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SkillConfig::set_has_bullet_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SkillConfig::clear_has_bullet_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SkillConfig::clear_bullet_speed() {
  bullet_speed_ = 0;
  clear_has_bullet_speed();
  SetDirty();
}
inline float SkillConfig::bullet_speed() const {
  return bullet_speed_;
}
inline void SkillConfig::set_bullet_speed(float value) {
  SetDirty();
  set_has_bullet_speed();
  bullet_speed_ = value;
}

// required int32 surffix_time = 5;
inline bool SkillConfig::has_surffix_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SkillConfig::set_has_surffix_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SkillConfig::clear_has_surffix_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SkillConfig::clear_surffix_time() {
  surffix_time_ = 0;
  clear_has_surffix_time();
  SetDirty();
}
inline ::google::protobuf::int32 SkillConfig::surffix_time() const {
  return surffix_time_;
}
inline void SkillConfig::set_surffix_time(::google::protobuf::int32 value) {
  SetDirty();
  set_has_surffix_time();
  surffix_time_ = value;
}

// required int32 cd_time = 6;
inline bool SkillConfig::has_cd_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SkillConfig::set_has_cd_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SkillConfig::clear_has_cd_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SkillConfig::clear_cd_time() {
  cd_time_ = 0;
  clear_has_cd_time();
  SetDirty();
}
inline ::google::protobuf::int32 SkillConfig::cd_time() const {
  return cd_time_;
}
inline void SkillConfig::set_cd_time(::google::protobuf::int32 value) {
  SetDirty();
  set_has_cd_time();
  cd_time_ = value;
}

// required .Config.TargetSelectLogic skill_tar_logic = 7;
inline bool SkillConfig::has_skill_tar_logic() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SkillConfig::set_has_skill_tar_logic() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SkillConfig::clear_has_skill_tar_logic() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SkillConfig::clear_skill_tar_logic() {
  if (skill_tar_logic_ != NULL) skill_tar_logic_->::Config::TargetSelectLogic::Clear();
  clear_has_skill_tar_logic();
  SetDirty();
}
inline const ::Config::TargetSelectLogic& SkillConfig::skill_tar_logic() const {
  return skill_tar_logic_ != NULL ? *skill_tar_logic_ : *default_instance_->skill_tar_logic_;
}
inline ::Config::TargetSelectLogic* SkillConfig::mutable_skill_tar_logic() {
  SetDirty();
  set_has_skill_tar_logic();
  if (skill_tar_logic_ == NULL) skill_tar_logic_ = new ::Config::TargetSelectLogic;
  return skill_tar_logic_;
}
inline ::Config::TargetSelectLogic* SkillConfig::release_skill_tar_logic() {
  SetDirty();
  clear_has_skill_tar_logic();
  ::Config::TargetSelectLogic* temp = skill_tar_logic_;
  skill_tar_logic_ = NULL;
  return temp;
}
inline void SkillConfig::set_allocated_skill_tar_logic(::Config::TargetSelectLogic* skill_tar_logic) {
  SetDirty();
  delete skill_tar_logic_;
  skill_tar_logic_ = skill_tar_logic;
  if (skill_tar_logic) {
    set_has_skill_tar_logic();
  } else {
    clear_has_skill_tar_logic();
  }
}

// required .Config.TargetSelectExtra tar_extra = 8;
inline bool SkillConfig::has_tar_extra() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SkillConfig::set_has_tar_extra() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SkillConfig::clear_has_tar_extra() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SkillConfig::clear_tar_extra() {
  if (tar_extra_ != NULL) tar_extra_->::Config::TargetSelectExtra::Clear();
  clear_has_tar_extra();
  SetDirty();
}
inline const ::Config::TargetSelectExtra& SkillConfig::tar_extra() const {
  return tar_extra_ != NULL ? *tar_extra_ : *default_instance_->tar_extra_;
}
inline ::Config::TargetSelectExtra* SkillConfig::mutable_tar_extra() {
  SetDirty();
  set_has_tar_extra();
  if (tar_extra_ == NULL) tar_extra_ = new ::Config::TargetSelectExtra;
  return tar_extra_;
}
inline ::Config::TargetSelectExtra* SkillConfig::release_tar_extra() {
  SetDirty();
  clear_has_tar_extra();
  ::Config::TargetSelectExtra* temp = tar_extra_;
  tar_extra_ = NULL;
  return temp;
}
inline void SkillConfig::set_allocated_tar_extra(::Config::TargetSelectExtra* tar_extra) {
  SetDirty();
  delete tar_extra_;
  tar_extra_ = tar_extra;
  if (tar_extra) {
    set_has_tar_extra();
  } else {
    clear_has_tar_extra();
  }
}

// required .Config.SkillType skill_type = 9;
inline bool SkillConfig::has_skill_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SkillConfig::set_has_skill_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SkillConfig::clear_has_skill_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SkillConfig::clear_skill_type() {
  skill_type_ = 0;
  clear_has_skill_type();
  SetDirty();
}
inline ::Config::SkillType SkillConfig::skill_type() const {
  return static_cast< ::Config::SkillType >(skill_type_);
}
inline void SkillConfig::set_skill_type(::Config::SkillType value) {
  assert(::Config::SkillType_IsValid(value));
  SetDirty();
  set_has_skill_type();
  skill_type_ = value;
}

// required .Packet.Property self_property = 14;
inline bool SkillConfig::has_self_property() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SkillConfig::set_has_self_property() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SkillConfig::clear_has_self_property() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SkillConfig::clear_self_property() {
  self_property_ = 0;
  clear_has_self_property();
  SetDirty();
}
inline ::Packet::Property SkillConfig::self_property() const {
  return static_cast< ::Packet::Property >(self_property_);
}
inline void SkillConfig::set_self_property(::Packet::Property value) {
  assert(::Packet::Property_IsValid(value));
  SetDirty();
  set_has_self_property();
  self_property_ = value;
}

// required .Packet.Property target_property = 15;
inline bool SkillConfig::has_target_property() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SkillConfig::set_has_target_property() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SkillConfig::clear_has_target_property() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SkillConfig::clear_target_property() {
  target_property_ = 0;
  clear_has_target_property();
  SetDirty();
}
inline ::Packet::Property SkillConfig::target_property() const {
  return static_cast< ::Packet::Property >(target_property_);
}
inline void SkillConfig::set_target_property(::Packet::Property value) {
  assert(::Packet::Property_IsValid(value));
  SetDirty();
  set_has_target_property();
  target_property_ = value;
}

// required string skill_effect = 16;
inline bool SkillConfig::has_skill_effect() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SkillConfig::set_has_skill_effect() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SkillConfig::clear_has_skill_effect() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SkillConfig::clear_skill_effect() {
  if (skill_effect_ != &::google::protobuf::internal::kEmptyString) {
    skill_effect_->clear();
  }
  clear_has_skill_effect();
  SetDirty();
}
inline const ::std::string& SkillConfig::skill_effect() const {
  return *skill_effect_;
}
inline void SkillConfig::set_skill_effect(const ::std::string& value) {
  SetDirty();
  set_has_skill_effect();
  if (skill_effect_ == &::google::protobuf::internal::kEmptyString) {
    skill_effect_ = new ::std::string;
  }
  skill_effect_->assign(value);
}
inline void SkillConfig::set_skill_effect(const char* value) {
  SetDirty();
  set_has_skill_effect();
  if (skill_effect_ == &::google::protobuf::internal::kEmptyString) {
    skill_effect_ = new ::std::string;
  }
  skill_effect_->assign(value);
}
inline void SkillConfig::set_skill_effect(const char* value, size_t size) {
  SetDirty();
  set_has_skill_effect();
  if (skill_effect_ == &::google::protobuf::internal::kEmptyString) {
    skill_effect_ = new ::std::string;
  }
  skill_effect_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillConfig::mutable_skill_effect() {
  SetDirty();
  set_has_skill_effect();
  if (skill_effect_ == &::google::protobuf::internal::kEmptyString) {
    skill_effect_ = new ::std::string;
  }
  return skill_effect_;
}
inline ::std::string* SkillConfig::release_skill_effect() {
  SetDirty();
  clear_has_skill_effect();
  if (skill_effect_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = skill_effect_;
    skill_effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillConfig::set_allocated_skill_effect(::std::string* skill_effect) {
  SetDirty();
  if (skill_effect_ != &::google::protobuf::internal::kEmptyString) {
    delete skill_effect_;
  }
  if (skill_effect) {
    set_has_skill_effect();
    skill_effect_ = skill_effect;
  } else {
    clear_has_skill_effect();
    skill_effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 self_buff = 17;
inline bool SkillConfig::has_self_buff() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SkillConfig::set_has_self_buff() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SkillConfig::clear_has_self_buff() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SkillConfig::clear_self_buff() {
  self_buff_ = 0;
  clear_has_self_buff();
  SetDirty();
}
inline ::google::protobuf::int32 SkillConfig::self_buff() const {
  return self_buff_;
}
inline void SkillConfig::set_self_buff(::google::protobuf::int32 value) {
  SetDirty();
  set_has_self_buff();
  self_buff_ = value;
}

// repeated int32 buffs = 18;
inline int SkillConfig::buffs_size() const {
  return buffs_.size();
}
inline void SkillConfig::clear_buffs() {
  buffs_.Clear();
  SetDirty();
}
inline ::google::protobuf::int32 SkillConfig::buffs(int index) const {
  return buffs_.Get(index);
}
inline void SkillConfig::set_buffs(int index, ::google::protobuf::int32 value) {
  SetDirty();
  buffs_.Set(index, value);
}
inline void SkillConfig::add_buffs(::google::protobuf::int32 value) {
  SetDirty();
  buffs_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SkillConfig::buffs() const {
  return buffs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SkillConfig::mutable_buffs() {
  SetDirty();
  return &buffs_;
}

// repeated .Config.TargetSelectLogic buff_tar_logics = 19;
inline int SkillConfig::buff_tar_logics_size() const {
  return buff_tar_logics_.size();
}
inline void SkillConfig::clear_buff_tar_logics() {
  buff_tar_logics_.Clear();
  SetDirty();
}
inline const ::Config::TargetSelectLogic& SkillConfig::buff_tar_logics(int index) const {
  return buff_tar_logics_.Get(index);
}
inline ::Config::TargetSelectLogic* SkillConfig::mutable_buff_tar_logics(int index) {
  SetDirty();
  return buff_tar_logics_.Mutable(index);
}
inline ::Config::TargetSelectLogic* SkillConfig::add_buff_tar_logics() {
  SetDirty();
  return buff_tar_logics_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Config::TargetSelectLogic >&
SkillConfig::buff_tar_logics() const {
  return buff_tar_logics_;
}
inline ::google::protobuf::RepeatedPtrField< ::Config::TargetSelectLogic >*
SkillConfig::mutable_buff_tar_logics() {
  SetDirty();
  return &buff_tar_logics_;
}

// repeated .Config.SkillConfig sub_skills = 20;
inline int SkillConfig::sub_skills_size() const {
  return sub_skills_.size();
}
inline void SkillConfig::clear_sub_skills() {
  sub_skills_.Clear();
  SetDirty();
}
inline const ::Config::SkillConfig& SkillConfig::sub_skills(int index) const {
  return sub_skills_.Get(index);
}
inline ::Config::SkillConfig* SkillConfig::mutable_sub_skills(int index) {
  SetDirty();
  return sub_skills_.Mutable(index);
}
inline ::Config::SkillConfig* SkillConfig::add_sub_skills() {
  SetDirty();
  return sub_skills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Config::SkillConfig >&
SkillConfig::sub_skills() const {
  return sub_skills_;
}
inline ::google::protobuf::RepeatedPtrField< ::Config::SkillConfig >*
SkillConfig::mutable_sub_skills() {
  SetDirty();
  return &sub_skills_;
}

// required int32 parent_skill = 21;
inline bool SkillConfig::has_parent_skill() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SkillConfig::set_has_parent_skill() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SkillConfig::clear_has_parent_skill() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SkillConfig::clear_parent_skill() {
  parent_skill_ = 0;
  clear_has_parent_skill();
  SetDirty();
}
inline ::google::protobuf::int32 SkillConfig::parent_skill() const {
  return parent_skill_;
}
inline void SkillConfig::set_parent_skill(::google::protobuf::int32 value) {
  SetDirty();
  set_has_parent_skill();
  parent_skill_ = value;
}

// required float acce_factor = 22;
inline bool SkillConfig::has_acce_factor() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SkillConfig::set_has_acce_factor() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SkillConfig::clear_has_acce_factor() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SkillConfig::clear_acce_factor() {
  acce_factor_ = 0;
  clear_has_acce_factor();
  SetDirty();
}
inline float SkillConfig::acce_factor() const {
  return acce_factor_;
}
inline void SkillConfig::set_acce_factor(float value) {
  SetDirty();
  set_has_acce_factor();
  acce_factor_ = value;
}

// required .Packet.Property self_property_revise_0 = 23;
inline bool SkillConfig::has_self_property_revise_0() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SkillConfig::set_has_self_property_revise_0() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SkillConfig::clear_has_self_property_revise_0() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SkillConfig::clear_self_property_revise_0() {
  self_property_revise_0_ = 0;
  clear_has_self_property_revise_0();
  SetDirty();
}
inline ::Packet::Property SkillConfig::self_property_revise_0() const {
  return static_cast< ::Packet::Property >(self_property_revise_0_);
}
inline void SkillConfig::set_self_property_revise_0(::Packet::Property value) {
  assert(::Packet::Property_IsValid(value));
  SetDirty();
  set_has_self_property_revise_0();
  self_property_revise_0_ = value;
}

// required float self_property_revise_value_0 = 24;
inline bool SkillConfig::has_self_property_revise_value_0() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SkillConfig::set_has_self_property_revise_value_0() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SkillConfig::clear_has_self_property_revise_value_0() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SkillConfig::clear_self_property_revise_value_0() {
  self_property_revise_value_0_ = 0;
  clear_has_self_property_revise_value_0();
  SetDirty();
}
inline float SkillConfig::self_property_revise_value_0() const {
  return self_property_revise_value_0_;
}
inline void SkillConfig::set_self_property_revise_value_0(float value) {
  SetDirty();
  set_has_self_property_revise_value_0();
  self_property_revise_value_0_ = value;
}

// required .Config.PropertyReviseValueType self_property_revise_value_type_0 = 25;
inline bool SkillConfig::has_self_property_revise_value_type_0() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SkillConfig::set_has_self_property_revise_value_type_0() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SkillConfig::clear_has_self_property_revise_value_type_0() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SkillConfig::clear_self_property_revise_value_type_0() {
  self_property_revise_value_type_0_ = 0;
  clear_has_self_property_revise_value_type_0();
  SetDirty();
}
inline ::Config::PropertyReviseValueType SkillConfig::self_property_revise_value_type_0() const {
  return static_cast< ::Config::PropertyReviseValueType >(self_property_revise_value_type_0_);
}
inline void SkillConfig::set_self_property_revise_value_type_0(::Config::PropertyReviseValueType value) {
  assert(::Config::PropertyReviseValueType_IsValid(value));
  SetDirty();
  set_has_self_property_revise_value_type_0();
  self_property_revise_value_type_0_ = value;
}

// required .Packet.Property buff_property_revise_0 = 26;
inline bool SkillConfig::has_buff_property_revise_0() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SkillConfig::set_has_buff_property_revise_0() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SkillConfig::clear_has_buff_property_revise_0() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SkillConfig::clear_buff_property_revise_0() {
  buff_property_revise_0_ = 0;
  clear_has_buff_property_revise_0();
  SetDirty();
}
inline ::Packet::Property SkillConfig::buff_property_revise_0() const {
  return static_cast< ::Packet::Property >(buff_property_revise_0_);
}
inline void SkillConfig::set_buff_property_revise_0(::Packet::Property value) {
  assert(::Packet::Property_IsValid(value));
  SetDirty();
  set_has_buff_property_revise_0();
  buff_property_revise_0_ = value;
}

// required float buff_property_revise_value_0 = 27;
inline bool SkillConfig::has_buff_property_revise_value_0() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SkillConfig::set_has_buff_property_revise_value_0() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SkillConfig::clear_has_buff_property_revise_value_0() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SkillConfig::clear_buff_property_revise_value_0() {
  buff_property_revise_value_0_ = 0;
  clear_has_buff_property_revise_value_0();
  SetDirty();
}
inline float SkillConfig::buff_property_revise_value_0() const {
  return buff_property_revise_value_0_;
}
inline void SkillConfig::set_buff_property_revise_value_0(float value) {
  SetDirty();
  set_has_buff_property_revise_value_0();
  buff_property_revise_value_0_ = value;
}

// required .Config.PropertyReviseValueType buff_property_revise_value_type_0 = 28;
inline bool SkillConfig::has_buff_property_revise_value_type_0() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SkillConfig::set_has_buff_property_revise_value_type_0() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SkillConfig::clear_has_buff_property_revise_value_type_0() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SkillConfig::clear_buff_property_revise_value_type_0() {
  buff_property_revise_value_type_0_ = 0;
  clear_has_buff_property_revise_value_type_0();
  SetDirty();
}
inline ::Config::PropertyReviseValueType SkillConfig::buff_property_revise_value_type_0() const {
  return static_cast< ::Config::PropertyReviseValueType >(buff_property_revise_value_type_0_);
}
inline void SkillConfig::set_buff_property_revise_value_type_0(::Config::PropertyReviseValueType value) {
  assert(::Config::PropertyReviseValueType_IsValid(value));
  SetDirty();
  set_has_buff_property_revise_value_type_0();
  buff_property_revise_value_type_0_ = value;
}

// required string position_effect = 29;
inline bool SkillConfig::has_position_effect() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void SkillConfig::set_has_position_effect() {
  _has_bits_[0] |= 0x01000000u;
}
inline void SkillConfig::clear_has_position_effect() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void SkillConfig::clear_position_effect() {
  if (position_effect_ != &::google::protobuf::internal::kEmptyString) {
    position_effect_->clear();
  }
  clear_has_position_effect();
  SetDirty();
}
inline const ::std::string& SkillConfig::position_effect() const {
  return *position_effect_;
}
inline void SkillConfig::set_position_effect(const ::std::string& value) {
  SetDirty();
  set_has_position_effect();
  if (position_effect_ == &::google::protobuf::internal::kEmptyString) {
    position_effect_ = new ::std::string;
  }
  position_effect_->assign(value);
}
inline void SkillConfig::set_position_effect(const char* value) {
  SetDirty();
  set_has_position_effect();
  if (position_effect_ == &::google::protobuf::internal::kEmptyString) {
    position_effect_ = new ::std::string;
  }
  position_effect_->assign(value);
}
inline void SkillConfig::set_position_effect(const char* value, size_t size) {
  SetDirty();
  set_has_position_effect();
  if (position_effect_ == &::google::protobuf::internal::kEmptyString) {
    position_effect_ = new ::std::string;
  }
  position_effect_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillConfig::mutable_position_effect() {
  SetDirty();
  set_has_position_effect();
  if (position_effect_ == &::google::protobuf::internal::kEmptyString) {
    position_effect_ = new ::std::string;
  }
  return position_effect_;
}
inline ::std::string* SkillConfig::release_position_effect() {
  SetDirty();
  clear_has_position_effect();
  if (position_effect_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = position_effect_;
    position_effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillConfig::set_allocated_position_effect(::std::string* position_effect) {
  SetDirty();
  if (position_effect_ != &::google::protobuf::internal::kEmptyString) {
    delete position_effect_;
  }
  if (position_effect) {
    set_has_position_effect();
    position_effect_ = position_effect;
  } else {
    clear_has_position_effect();
    position_effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 effect_param_0 = 30;
inline bool SkillConfig::has_effect_param_0() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void SkillConfig::set_has_effect_param_0() {
  _has_bits_[0] |= 0x02000000u;
}
inline void SkillConfig::clear_has_effect_param_0() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void SkillConfig::clear_effect_param_0() {
  effect_param_0_ = 0;
  clear_has_effect_param_0();
  SetDirty();
}
inline ::google::protobuf::int32 SkillConfig::effect_param_0() const {
  return effect_param_0_;
}
inline void SkillConfig::set_effect_param_0(::google::protobuf::int32 value) {
  SetDirty();
  set_has_effect_param_0();
  effect_param_0_ = value;
}

// required int32 effect_param_1 = 31;
inline bool SkillConfig::has_effect_param_1() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void SkillConfig::set_has_effect_param_1() {
  _has_bits_[0] |= 0x04000000u;
}
inline void SkillConfig::clear_has_effect_param_1() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void SkillConfig::clear_effect_param_1() {
  effect_param_1_ = 0;
  clear_has_effect_param_1();
  SetDirty();
}
inline ::google::protobuf::int32 SkillConfig::effect_param_1() const {
  return effect_param_1_;
}
inline void SkillConfig::set_effect_param_1(::google::protobuf::int32 value) {
  SetDirty();
  set_has_effect_param_1();
  effect_param_1_ = value;
}

// required int32 effect_param_2 = 32;
inline bool SkillConfig::has_effect_param_2() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void SkillConfig::set_has_effect_param_2() {
  _has_bits_[0] |= 0x08000000u;
}
inline void SkillConfig::clear_has_effect_param_2() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void SkillConfig::clear_effect_param_2() {
  effect_param_2_ = 0;
  clear_has_effect_param_2();
  SetDirty();
}
inline ::google::protobuf::int32 SkillConfig::effect_param_2() const {
  return effect_param_2_;
}
inline void SkillConfig::set_effect_param_2(::google::protobuf::int32 value) {
  SetDirty();
  set_has_effect_param_2();
  effect_param_2_ = value;
}

// repeated string effect_param_str = 33;
inline int SkillConfig::effect_param_str_size() const {
  return effect_param_str_.size();
}
inline void SkillConfig::clear_effect_param_str() {
  effect_param_str_.Clear();
  SetDirty();
}
inline const ::std::string& SkillConfig::effect_param_str(int index) const {
  return effect_param_str_.Get(index);
}
inline ::std::string* SkillConfig::mutable_effect_param_str(int index) {
  SetDirty();
  return effect_param_str_.Mutable(index);
}
inline void SkillConfig::set_effect_param_str(int index, const ::std::string& value) {
  SetDirty();
  effect_param_str_.Mutable(index)->assign(value);
}
inline void SkillConfig::set_effect_param_str(int index, const char* value) {
  SetDirty();
  effect_param_str_.Mutable(index)->assign(value);
}
inline void SkillConfig::set_effect_param_str(int index, const char* value, size_t size) {
  SetDirty();
  effect_param_str_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillConfig::add_effect_param_str() {
  SetDirty();
  return effect_param_str_.Add();
}
inline void SkillConfig::add_effect_param_str(const ::std::string& value) {
  SetDirty();
  effect_param_str_.Add()->assign(value);
}
inline void SkillConfig::add_effect_param_str(const char* value) {
  SetDirty();
  effect_param_str_.Add()->assign(value);
}
inline void SkillConfig::add_effect_param_str(const char* value, size_t size) {
  SetDirty();
  effect_param_str_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SkillConfig::effect_param_str() const {
  return effect_param_str_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SkillConfig::mutable_effect_param_str() {
  SetDirty();
  return &effect_param_str_;
}

// required bool is_sneak = 34;
inline bool SkillConfig::has_is_sneak() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void SkillConfig::set_has_is_sneak() {
  _has_bits_[0] |= 0x20000000u;
}
inline void SkillConfig::clear_has_is_sneak() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void SkillConfig::clear_is_sneak() {
  is_sneak_ = false;
  clear_has_is_sneak();
  SetDirty();
}
inline bool SkillConfig::is_sneak() const {
  return is_sneak_;
}
inline void SkillConfig::set_is_sneak(bool value) {
  SetDirty();
  set_has_is_sneak();
  is_sneak_ = value;
}

// -------------------------------------------------------------------

// ImpactConfig

// required int32 id = 1;
inline bool ImpactConfig::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImpactConfig::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImpactConfig::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImpactConfig::clear_id() {
  id_ = 0;
  clear_has_id();
  SetDirty();
}
inline ::google::protobuf::int32 ImpactConfig::id() const {
  return id_;
}
inline void ImpactConfig::set_id(::google::protobuf::int32 value) {
  SetDirty();
  set_has_id();
  id_ = value;
}

// required string impact_logic = 2;
inline bool ImpactConfig::has_impact_logic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImpactConfig::set_has_impact_logic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImpactConfig::clear_has_impact_logic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImpactConfig::clear_impact_logic() {
  if (impact_logic_ != &::google::protobuf::internal::kEmptyString) {
    impact_logic_->clear();
  }
  clear_has_impact_logic();
  SetDirty();
}
inline const ::std::string& ImpactConfig::impact_logic() const {
  return *impact_logic_;
}
inline void ImpactConfig::set_impact_logic(const ::std::string& value) {
  SetDirty();
  set_has_impact_logic();
  if (impact_logic_ == &::google::protobuf::internal::kEmptyString) {
    impact_logic_ = new ::std::string;
  }
  impact_logic_->assign(value);
}
inline void ImpactConfig::set_impact_logic(const char* value) {
  SetDirty();
  set_has_impact_logic();
  if (impact_logic_ == &::google::protobuf::internal::kEmptyString) {
    impact_logic_ = new ::std::string;
  }
  impact_logic_->assign(value);
}
inline void ImpactConfig::set_impact_logic(const char* value, size_t size) {
  SetDirty();
  set_has_impact_logic();
  if (impact_logic_ == &::google::protobuf::internal::kEmptyString) {
    impact_logic_ = new ::std::string;
  }
  impact_logic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImpactConfig::mutable_impact_logic() {
  SetDirty();
  set_has_impact_logic();
  if (impact_logic_ == &::google::protobuf::internal::kEmptyString) {
    impact_logic_ = new ::std::string;
  }
  return impact_logic_;
}
inline ::std::string* ImpactConfig::release_impact_logic() {
  SetDirty();
  clear_has_impact_logic();
  if (impact_logic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = impact_logic_;
    impact_logic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImpactConfig::set_allocated_impact_logic(::std::string* impact_logic) {
  SetDirty();
  if (impact_logic_ != &::google::protobuf::internal::kEmptyString) {
    delete impact_logic_;
  }
  if (impact_logic) {
    set_has_impact_logic();
    impact_logic_ = impact_logic;
  } else {
    clear_has_impact_logic();
    impact_logic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Config.ImpactEffectType effect_type = 3;
inline bool ImpactConfig::has_effect_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImpactConfig::set_has_effect_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImpactConfig::clear_has_effect_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImpactConfig::clear_effect_type() {
  effect_type_ = -1;
  clear_has_effect_type();
  SetDirty();
}
inline ::Config::ImpactEffectType ImpactConfig::effect_type() const {
  return static_cast< ::Config::ImpactEffectType >(effect_type_);
}
inline void ImpactConfig::set_effect_type(::Config::ImpactEffectType value) {
  assert(::Config::ImpactEffectType_IsValid(value));
  SetDirty();
  set_has_effect_type();
  effect_type_ = value;
}

// required int32 max_layer = 4;
inline bool ImpactConfig::has_max_layer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImpactConfig::set_has_max_layer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImpactConfig::clear_has_max_layer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImpactConfig::clear_max_layer() {
  max_layer_ = 0;
  clear_has_max_layer();
  SetDirty();
}
inline ::google::protobuf::int32 ImpactConfig::max_layer() const {
  return max_layer_;
}
inline void ImpactConfig::set_max_layer(::google::protobuf::int32 value) {
  SetDirty();
  set_has_max_layer();
  max_layer_ = value;
}

// required int32 mutex_id = 5;
inline bool ImpactConfig::has_mutex_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImpactConfig::set_has_mutex_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImpactConfig::clear_has_mutex_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImpactConfig::clear_mutex_id() {
  mutex_id_ = 0;
  clear_has_mutex_id();
  SetDirty();
}
inline ::google::protobuf::int32 ImpactConfig::mutex_id() const {
  return mutex_id_;
}
inline void ImpactConfig::set_mutex_id(::google::protobuf::int32 value) {
  SetDirty();
  set_has_mutex_id();
  mutex_id_ = value;
}

// required int32 priority = 6;
inline bool ImpactConfig::has_priority() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImpactConfig::set_has_priority() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImpactConfig::clear_has_priority() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImpactConfig::clear_priority() {
  priority_ = 0;
  clear_has_priority();
  SetDirty();
}
inline ::google::protobuf::int32 ImpactConfig::priority() const {
  return priority_;
}
inline void ImpactConfig::set_priority(::google::protobuf::int32 value) {
  SetDirty();
  set_has_priority();
  priority_ = value;
}

// required int32 last_time = 7;
inline bool ImpactConfig::has_last_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ImpactConfig::set_has_last_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ImpactConfig::clear_has_last_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ImpactConfig::clear_last_time() {
  last_time_ = 0;
  clear_has_last_time();
  SetDirty();
}
inline ::google::protobuf::int32 ImpactConfig::last_time() const {
  return last_time_;
}
inline void ImpactConfig::set_last_time(::google::protobuf::int32 value) {
  SetDirty();
  set_has_last_time();
  last_time_ = value;
}

// required int32 trigger_freq = 8;
inline bool ImpactConfig::has_trigger_freq() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ImpactConfig::set_has_trigger_freq() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ImpactConfig::clear_has_trigger_freq() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ImpactConfig::clear_trigger_freq() {
  trigger_freq_ = 0;
  clear_has_trigger_freq();
  SetDirty();
}
inline ::google::protobuf::int32 ImpactConfig::trigger_freq() const {
  return trigger_freq_;
}
inline void ImpactConfig::set_trigger_freq(::google::protobuf::int32 value) {
  SetDirty();
  set_has_trigger_freq();
  trigger_freq_ = value;
}

// required int32 effect_times = 9;
inline bool ImpactConfig::has_effect_times() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ImpactConfig::set_has_effect_times() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ImpactConfig::clear_has_effect_times() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ImpactConfig::clear_effect_times() {
  effect_times_ = 0;
  clear_has_effect_times();
  SetDirty();
}
inline ::google::protobuf::int32 ImpactConfig::effect_times() const {
  return effect_times_;
}
inline void ImpactConfig::set_effect_times(::google::protobuf::int32 value) {
  SetDirty();
  set_has_effect_times();
  effect_times_ = value;
}

// repeated int32 param_types = 10;
inline int ImpactConfig::param_types_size() const {
  return param_types_.size();
}
inline void ImpactConfig::clear_param_types() {
  param_types_.Clear();
  SetDirty();
}
inline ::google::protobuf::int32 ImpactConfig::param_types(int index) const {
  return param_types_.Get(index);
}
inline void ImpactConfig::set_param_types(int index, ::google::protobuf::int32 value) {
  SetDirty();
  param_types_.Set(index, value);
}
inline void ImpactConfig::add_param_types(::google::protobuf::int32 value) {
  SetDirty();
  param_types_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ImpactConfig::param_types() const {
  return param_types_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ImpactConfig::mutable_param_types() {
  SetDirty();
  return &param_types_;
}

// repeated float param_values = 11;
inline int ImpactConfig::param_values_size() const {
  return param_values_.size();
}
inline void ImpactConfig::clear_param_values() {
  param_values_.Clear();
  SetDirty();
}
inline float ImpactConfig::param_values(int index) const {
  return param_values_.Get(index);
}
inline void ImpactConfig::set_param_values(int index, float value) {
  SetDirty();
  param_values_.Set(index, value);
}
inline void ImpactConfig::add_param_values(float value) {
  SetDirty();
  param_values_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ImpactConfig::param_values() const {
  return param_values_;
}
inline ::google::protobuf::RepeatedField< float >*
ImpactConfig::mutable_param_values() {
  SetDirty();
  return &param_values_;
}

// required .Config.TargetSelectLogic buff_tar_logic = 12;
inline bool ImpactConfig::has_buff_tar_logic() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ImpactConfig::set_has_buff_tar_logic() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ImpactConfig::clear_has_buff_tar_logic() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ImpactConfig::clear_buff_tar_logic() {
  if (buff_tar_logic_ != NULL) buff_tar_logic_->::Config::TargetSelectLogic::Clear();
  clear_has_buff_tar_logic();
  SetDirty();
}
inline const ::Config::TargetSelectLogic& ImpactConfig::buff_tar_logic() const {
  return buff_tar_logic_ != NULL ? *buff_tar_logic_ : *default_instance_->buff_tar_logic_;
}
inline ::Config::TargetSelectLogic* ImpactConfig::mutable_buff_tar_logic() {
  SetDirty();
  set_has_buff_tar_logic();
  if (buff_tar_logic_ == NULL) buff_tar_logic_ = new ::Config::TargetSelectLogic;
  return buff_tar_logic_;
}
inline ::Config::TargetSelectLogic* ImpactConfig::release_buff_tar_logic() {
  SetDirty();
  clear_has_buff_tar_logic();
  ::Config::TargetSelectLogic* temp = buff_tar_logic_;
  buff_tar_logic_ = NULL;
  return temp;
}
inline void ImpactConfig::set_allocated_buff_tar_logic(::Config::TargetSelectLogic* buff_tar_logic) {
  SetDirty();
  delete buff_tar_logic_;
  buff_tar_logic_ = buff_tar_logic;
  if (buff_tar_logic) {
    set_has_buff_tar_logic();
  } else {
    clear_has_buff_tar_logic();
  }
}

// -------------------------------------------------------------------

// SkillBuildConfig

// required int32 actor_id = 1;
inline bool SkillBuildConfig::has_actor_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkillBuildConfig::set_has_actor_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkillBuildConfig::clear_has_actor_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkillBuildConfig::clear_actor_id() {
  actor_id_ = 0;
  clear_has_actor_id();
  SetDirty();
}
inline ::google::protobuf::int32 SkillBuildConfig::actor_id() const {
  return actor_id_;
}
inline void SkillBuildConfig::set_actor_id(::google::protobuf::int32 value) {
  SetDirty();
  set_has_actor_id();
  actor_id_ = value;
}

// required .Packet.ActorColor color = 2;
inline bool SkillBuildConfig::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SkillBuildConfig::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SkillBuildConfig::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SkillBuildConfig::clear_color() {
  color_ = 1;
  clear_has_color();
  SetDirty();
}
inline ::Packet::ActorColor SkillBuildConfig::color() const {
  return static_cast< ::Packet::ActorColor >(color_);
}
inline void SkillBuildConfig::set_color(::Packet::ActorColor value) {
  assert(::Packet::ActorColor_IsValid(value));
  SetDirty();
  set_has_color();
  color_ = value;
}

// repeated int32 skill_ids = 3;
inline int SkillBuildConfig::skill_ids_size() const {
  return skill_ids_.size();
}
inline void SkillBuildConfig::clear_skill_ids() {
  skill_ids_.Clear();
  SetDirty();
}
inline ::google::protobuf::int32 SkillBuildConfig::skill_ids(int index) const {
  return skill_ids_.Get(index);
}
inline void SkillBuildConfig::set_skill_ids(int index, ::google::protobuf::int32 value) {
  SetDirty();
  skill_ids_.Set(index, value);
}
inline void SkillBuildConfig::add_skill_ids(::google::protobuf::int32 value) {
  SetDirty();
  skill_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SkillBuildConfig::skill_ids() const {
  return skill_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SkillBuildConfig::mutable_skill_ids() {
  SetDirty();
  return &skill_ids_;
}

// -------------------------------------------------------------------

// BuffDefine

// required .Config.BuffType type = 1;
inline bool BuffDefine::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffDefine::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffDefine::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffDefine::clear_type() {
  type_ = 1;
  clear_has_type();
  SetDirty();
}
inline ::Config::BuffType BuffDefine::type() const {
  return static_cast< ::Config::BuffType >(type_);
}
inline void BuffDefine::set_type(::Config::BuffType value) {
  assert(::Config::BuffType_IsValid(value));
  SetDirty();
  set_has_type();
  type_ = value;
}

// required bool is_debuff = 2;
inline bool BuffDefine::has_is_debuff() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffDefine::set_has_is_debuff() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffDefine::clear_has_is_debuff() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffDefine::clear_is_debuff() {
  is_debuff_ = false;
  clear_has_is_debuff();
  SetDirty();
}
inline bool BuffDefine::is_debuff() const {
  return is_debuff_;
}
inline void BuffDefine::set_is_debuff(bool value) {
  SetDirty();
  set_has_is_debuff();
  is_debuff_ = value;
}

// required bool can_despell = 3;
inline bool BuffDefine::has_can_despell() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuffDefine::set_has_can_despell() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuffDefine::clear_has_can_despell() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuffDefine::clear_can_despell() {
  can_despell_ = false;
  clear_has_can_despell();
  SetDirty();
}
inline bool BuffDefine::can_despell() const {
  return can_despell_;
}
inline void BuffDefine::set_can_despell(bool value) {
  SetDirty();
  set_has_can_despell();
  can_despell_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Config

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SkillConfig_2eproto__INCLUDED
