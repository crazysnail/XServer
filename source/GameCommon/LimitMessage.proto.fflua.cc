// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LimitMessage.proto
#include "LimitMessage.pb.h"
#include "LimitMessage.proto.fflua.h"
namespace Packet {
bool ServerFull_fflua_reg(lua_State* state)
{
//for decltype
	ServerFull* message(nullptr);
	message;
	ff::fflua_register_t<ServerFull, ctor()>(state, "ServerFull", "google::protobuf::Message")
		// required int32 queue_user_count = 1;
		.def(&ServerFull::queue_user_count, "queue_user_count")
		.def(&ServerFull::set_queue_user_count, "set_queue_user_count")
		.def(&ServerFull::ByteSize, "ByteSize")
		.def(&ServerFull::SetInitialized, "SetInitialized")
		;
	return true;
}
bool TargetSceneIsFull_fflua_reg(lua_State* state)
{
//for decltype
	TargetSceneIsFull* message(nullptr);
	message;
	ff::fflua_register_t<TargetSceneIsFull, ctor()>(state, "TargetSceneIsFull", "google::protobuf::Message")
		// required int32 scene_id = 1;
		.def(&TargetSceneIsFull::scene_id, "scene_id")
		.def(&TargetSceneIsFull::set_scene_id, "set_scene_id")
		.def(&TargetSceneIsFull::ByteSize, "ByteSize")
		.def(&TargetSceneIsFull::SetInitialized, "SetInitialized")
		;
	return true;
}
bool LimitMessage_fflua_regist_all(lua_State* state)
{
	ServerFull_fflua_reg(state);
	TargetSceneIsFull_fflua_reg(state);
	return true;
}
}
