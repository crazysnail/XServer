// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Team.proto

#ifndef PROTOBUF_Team_2eproto__INCLUDED
#define PROTOBUF_Team_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "AllPacketEnum.pb.h"
#include "PlayerBasicInfo.pb.h"
#include "ItemAndEquip.pb.h"
#include "ProtoBufOption.pb.h"
// @@protoc_insertion_point(includes)

namespace Packet {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Team_2eproto();
void protobuf_AssignDesc_Team_2eproto();
void protobuf_ShutdownFile_Team_2eproto();

class PurposeInfo;
class TeamPlayerBasicInfo;
class TeamPlayerInfo;
class SetTeamHeroPositionReq;
class SetTeamHeroPositionReply;
class TeamInfo;
class CreateTeam;
class CreateRobotTeam;
class DelTeam;
class ChangeTeamTypeReq;
class UpdateTeamTypeReply;
class ChangeTeamArrangeTypeReq;
class UpdateTeamArrangeTypeReply;
class ApplyTeamReq;
class ApplyMissionTeamReq;
class LevelTeamReq;
class AskLevelTeamReq;
class AgreeApplyTeamReq;
class InviteyAddTeamReq;
class AskInviteyAgreeTeamReply;
class InviteyAgreeTeamReq;
class AddTeamReply;
class LeaveTeamReply;
class SetPurposeInfoReq;
class PurposeInfoUpdate;
class SetTeamAutoMatchReq;
class TeamAutoMatchUpdate;
class TeamFullPlayerInfo;
class TeamListInfo;
class TeamInfoReq;
class EmptyTeamReply;
class TeamInfoReply;
class FindTeamListReq;
class TeamListReply;
class TeamApplyListReq;
class TeamApplyListReply;
class PlayerAutoMatchInfo;
class PlayerAutoMatchReq;
class PlayerAutoMatchReply;
class PlayerSetTeamStatusReq;
class TeamPlayerBasicUpdate;
class SetTeamLeaderReq;
class ApplyTeamLeaderReq;
class AskApplyTeamLeaderReq;
class AskApplyTeamLeaderReply;
class TeamLeaderUpdate;
class RobotPlayerInOk;
class TeamAutomatchConfig;

// ===================================================================

class PurposeInfo : public ::google::protobuf::Message {
 public:
  PurposeInfo();
  virtual ~PurposeInfo();

  PurposeInfo(const PurposeInfo& from);

  inline PurposeInfo& operator=(const PurposeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PurposeInfo& default_instance();

  void Swap(PurposeInfo* other);

  // implements Message ----------------------------------------------

  PurposeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PurposeInfo& from);
  void MergeFrom(const PurposeInfo& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 purpose = 1;
  inline bool has_purpose() const;
  inline void clear_purpose();
  static const int kPurposeFieldNumber = 1;
  inline ::google::protobuf::int32 purpose() const;
  inline void set_purpose(::google::protobuf::int32 value);

  // required int32 level_limt_min = 2;
  inline bool has_level_limt_min() const;
  inline void clear_level_limt_min();
  static const int kLevelLimtMinFieldNumber = 2;
  inline ::google::protobuf::int32 level_limt_min() const;
  inline void set_level_limt_min(::google::protobuf::int32 value);

  // required int32 level_limt_max = 3;
  inline bool has_level_limt_max() const;
  inline void clear_level_limt_max();
  static const int kLevelLimtMaxFieldNumber = 3;
  inline ::google::protobuf::int32 level_limt_max() const;
  inline void set_level_limt_max(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Packet.PurposeInfo)
 private:
  inline void set_has_purpose();
  inline void clear_has_purpose();
  inline void set_has_level_limt_min();
  inline void clear_has_level_limt_min();
  inline void set_has_level_limt_max();
  inline void clear_has_level_limt_max();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 purpose_;
  ::google::protobuf::int32 level_limt_min_;
  ::google::protobuf::int32 level_limt_max_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static PurposeInfo* default_instance_;
};
// -------------------------------------------------------------------

class TeamPlayerBasicInfo : public ::google::protobuf::Message {
 public:
  TeamPlayerBasicInfo();
  virtual ~TeamPlayerBasicInfo();

  TeamPlayerBasicInfo(const TeamPlayerBasicInfo& from);

  inline TeamPlayerBasicInfo& operator=(const TeamPlayerBasicInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamPlayerBasicInfo& default_instance();

  void Swap(TeamPlayerBasicInfo* other);

  // implements Message ----------------------------------------------

  TeamPlayerBasicInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamPlayerBasicInfo& from);
  void MergeFrom(const TeamPlayerBasicInfo& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Packet.PlayerTeamStatus playerstatus = 1;
  inline bool has_playerstatus() const;
  inline void clear_playerstatus();
  static const int kPlayerstatusFieldNumber = 1;
  inline ::Packet::PlayerTeamStatus playerstatus() const;
  inline void set_playerstatus(::Packet::PlayerTeamStatus value);

  // required int32 position_index = 2;
  inline bool has_position_index() const;
  inline void clear_position_index();
  static const int kPositionIndexFieldNumber = 2;
  inline ::google::protobuf::int32 position_index() const;
  inline void set_position_index(::google::protobuf::int32 value);

  // required int32 hero_position = 3;
  inline bool has_hero_position() const;
  inline void clear_hero_position();
  static const int kHeroPositionFieldNumber = 3;
  inline ::google::protobuf::int32 hero_position() const;
  inline void set_hero_position(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Packet.TeamPlayerBasicInfo)
 private:
  inline void set_has_playerstatus();
  inline void clear_has_playerstatus();
  inline void set_has_position_index();
  inline void clear_has_position_index();
  inline void set_has_hero_position();
  inline void clear_has_hero_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int playerstatus_;
  ::google::protobuf::int32 position_index_;
  ::google::protobuf::int32 hero_position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static TeamPlayerBasicInfo* default_instance_;
};
// -------------------------------------------------------------------

class TeamPlayerInfo : public ::google::protobuf::Message {
 public:
  TeamPlayerInfo();
  virtual ~TeamPlayerInfo();

  TeamPlayerInfo(const TeamPlayerInfo& from);

  inline TeamPlayerInfo& operator=(const TeamPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamPlayerInfo& default_instance();

  void Swap(TeamPlayerInfo* other);

  // implements Message ----------------------------------------------

  TeamPlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamPlayerInfo& from);
  void MergeFrom(const TeamPlayerInfo& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 playerguid = 1;
  inline bool has_playerguid() const;
  inline void clear_playerguid();
  static const int kPlayerguidFieldNumber = 1;
  inline ::google::protobuf::uint64 playerguid() const;
  inline void set_playerguid(::google::protobuf::uint64 value);

  // required .Packet.TeamPlayerBasicInfo teambaseinfo = 2;
  inline bool has_teambaseinfo() const;
  inline void clear_teambaseinfo();
  static const int kTeambaseinfoFieldNumber = 2;
  inline const ::Packet::TeamPlayerBasicInfo& teambaseinfo() const;
  inline ::Packet::TeamPlayerBasicInfo* mutable_teambaseinfo();
  inline ::Packet::TeamPlayerBasicInfo* release_teambaseinfo();
  inline void set_allocated_teambaseinfo(::Packet::TeamPlayerBasicInfo* teambaseinfo);

  // optional .Packet.PlayerBasicInfo basic_info = 3;
  inline bool has_basic_info() const;
  inline void clear_basic_info();
  static const int kBasicInfoFieldNumber = 3;
  inline const ::Packet::PlayerBasicInfo& basic_info() const;
  inline ::Packet::PlayerBasicInfo* mutable_basic_info();
  inline ::Packet::PlayerBasicInfo* release_basic_info();
  inline void set_allocated_basic_info(::Packet::PlayerBasicInfo* basic_info);

  // optional bool is_robot = 4;
  inline bool has_is_robot() const;
  inline void clear_is_robot();
  static const int kIsRobotFieldNumber = 4;
  inline bool is_robot() const;
  inline void set_is_robot(bool value);

  // @@protoc_insertion_point(class_scope:Packet.TeamPlayerInfo)
 private:
  inline void set_has_playerguid();
  inline void clear_has_playerguid();
  inline void set_has_teambaseinfo();
  inline void clear_has_teambaseinfo();
  inline void set_has_basic_info();
  inline void clear_has_basic_info();
  inline void set_has_is_robot();
  inline void clear_has_is_robot();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerguid_;
  ::Packet::TeamPlayerBasicInfo* teambaseinfo_;
  ::Packet::PlayerBasicInfo* basic_info_;
  bool is_robot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static TeamPlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class SetTeamHeroPositionReq : public ::google::protobuf::Message {
 public:
  SetTeamHeroPositionReq();
  virtual ~SetTeamHeroPositionReq();

  SetTeamHeroPositionReq(const SetTeamHeroPositionReq& from);

  inline SetTeamHeroPositionReq& operator=(const SetTeamHeroPositionReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetTeamHeroPositionReq& default_instance();

  void Swap(SetTeamHeroPositionReq* other);

  // implements Message ----------------------------------------------

  SetTeamHeroPositionReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetTeamHeroPositionReq& from);
  void MergeFrom(const SetTeamHeroPositionReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 position_index = 1;
  inline bool has_position_index() const;
  inline void clear_position_index();
  static const int kPositionIndexFieldNumber = 1;
  inline ::google::protobuf::int32 position_index() const;
  inline void set_position_index(::google::protobuf::int32 value);

  // required int32 hero_position = 2;
  inline bool has_hero_position() const;
  inline void clear_hero_position();
  static const int kHeroPositionFieldNumber = 2;
  inline ::google::protobuf::int32 hero_position() const;
  inline void set_hero_position(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Packet.SetTeamHeroPositionReq)
 private:
  inline void set_has_position_index();
  inline void clear_has_position_index();
  inline void set_has_hero_position();
  inline void clear_has_hero_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 position_index_;
  ::google::protobuf::int32 hero_position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static SetTeamHeroPositionReq* default_instance_;
};
// -------------------------------------------------------------------

class SetTeamHeroPositionReply : public ::google::protobuf::Message {
 public:
  SetTeamHeroPositionReply();
  virtual ~SetTeamHeroPositionReply();

  SetTeamHeroPositionReply(const SetTeamHeroPositionReply& from);

  inline SetTeamHeroPositionReply& operator=(const SetTeamHeroPositionReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetTeamHeroPositionReply& default_instance();

  void Swap(SetTeamHeroPositionReply* other);

  // implements Message ----------------------------------------------

  SetTeamHeroPositionReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetTeamHeroPositionReply& from);
  void MergeFrom(const SetTeamHeroPositionReply& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 position_index = 1;
  inline bool has_position_index() const;
  inline void clear_position_index();
  static const int kPositionIndexFieldNumber = 1;
  inline ::google::protobuf::int32 position_index() const;
  inline void set_position_index(::google::protobuf::int32 value);

  // required int32 hero_position = 2;
  inline bool has_hero_position() const;
  inline void clear_hero_position();
  static const int kHeroPositionFieldNumber = 2;
  inline ::google::protobuf::int32 hero_position() const;
  inline void set_hero_position(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Packet.SetTeamHeroPositionReply)
 private:
  inline void set_has_position_index();
  inline void clear_has_position_index();
  inline void set_has_hero_position();
  inline void clear_has_hero_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 position_index_;
  ::google::protobuf::int32 hero_position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static SetTeamHeroPositionReply* default_instance_;
};
// -------------------------------------------------------------------

class TeamInfo : public ::google::protobuf::Message {
 public:
  TeamInfo();
  virtual ~TeamInfo();

  TeamInfo(const TeamInfo& from);

  inline TeamInfo& operator=(const TeamInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamInfo& default_instance();

  void Swap(TeamInfo* other);

  // implements Message ----------------------------------------------

  TeamInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamInfo& from);
  void MergeFrom(const TeamInfo& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 guid = 1;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 1;
  inline ::google::protobuf::uint64 guid() const;
  inline void set_guid(::google::protobuf::uint64 value);

  // repeated .Packet.TeamPlayerInfo member = 2;
  inline int member_size() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 2;
  inline const ::Packet::TeamPlayerInfo& member(int index) const;
  inline ::Packet::TeamPlayerInfo* mutable_member(int index);
  inline ::Packet::TeamPlayerInfo* add_member();
  inline const ::google::protobuf::RepeatedPtrField< ::Packet::TeamPlayerInfo >&
      member() const;
  inline ::google::protobuf::RepeatedPtrField< ::Packet::TeamPlayerInfo >*
      mutable_member();

  // required bool group = 3;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 3;
  inline bool group() const;
  inline void set_group(bool value);

  // required .Packet.ArrangeType arrangetype = 4;
  inline bool has_arrangetype() const;
  inline void clear_arrangetype();
  static const int kArrangetypeFieldNumber = 4;
  inline ::Packet::ArrangeType arrangetype() const;
  inline void set_arrangetype(::Packet::ArrangeType value);

  // required fixed64 leader = 5;
  inline bool has_leader() const;
  inline void clear_leader();
  static const int kLeaderFieldNumber = 5;
  inline ::google::protobuf::uint64 leader() const;
  inline void set_leader(::google::protobuf::uint64 value);

  // required fixed64 applyleader = 6;
  inline bool has_applyleader() const;
  inline void clear_applyleader();
  static const int kApplyleaderFieldNumber = 6;
  inline ::google::protobuf::uint64 applyleader() const;
  inline void set_applyleader(::google::protobuf::uint64 value);

  // required bool agreeapplyleader = 7;
  inline bool has_agreeapplyleader() const;
  inline void clear_agreeapplyleader();
  static const int kAgreeapplyleaderFieldNumber = 7;
  inline bool agreeapplyleader() const;
  inline void set_agreeapplyleader(bool value);

  // required int32 agreeapplytime = 8;
  inline bool has_agreeapplytime() const;
  inline void clear_agreeapplytime();
  static const int kAgreeapplytimeFieldNumber = 8;
  inline ::google::protobuf::int32 agreeapplytime() const;
  inline void set_agreeapplytime(::google::protobuf::int32 value);

  // required bool auto_match = 9;
  inline bool has_auto_match() const;
  inline void clear_auto_match();
  static const int kAutoMatchFieldNumber = 9;
  inline bool auto_match() const;
  inline void set_auto_match(bool value);

  // repeated fixed64 applylist = 10;
  inline int applylist_size() const;
  inline void clear_applylist();
  static const int kApplylistFieldNumber = 10;
  inline ::google::protobuf::uint64 applylist(int index) const;
  inline void set_applylist(int index, ::google::protobuf::uint64 value);
  inline void add_applylist(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      applylist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_applylist();

  // required .Packet.PurposeInfo purpose = 11;
  inline bool has_purpose() const;
  inline void clear_purpose();
  static const int kPurposeFieldNumber = 11;
  inline const ::Packet::PurposeInfo& purpose() const;
  inline ::Packet::PurposeInfo* mutable_purpose();
  inline ::Packet::PurposeInfo* release_purpose();
  inline void set_allocated_purpose(::Packet::PurposeInfo* purpose);

  // required bool setposition = 12;
  inline bool has_setposition() const;
  inline void clear_setposition();
  static const int kSetpositionFieldNumber = 12;
  inline bool setposition() const;
  inline void set_setposition(bool value);

  // optional bool robot_team = 13;
  inline bool has_robot_team() const;
  inline void clear_robot_team();
  static const int kRobotTeamFieldNumber = 13;
  inline bool robot_team() const;
  inline void set_robot_team(bool value);

  // @@protoc_insertion_point(class_scope:Packet.TeamInfo)
 private:
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_arrangetype();
  inline void clear_has_arrangetype();
  inline void set_has_leader();
  inline void clear_has_leader();
  inline void set_has_applyleader();
  inline void clear_has_applyleader();
  inline void set_has_agreeapplyleader();
  inline void clear_has_agreeapplyleader();
  inline void set_has_agreeapplytime();
  inline void clear_has_agreeapplytime();
  inline void set_has_auto_match();
  inline void clear_has_auto_match();
  inline void set_has_purpose();
  inline void clear_has_purpose();
  inline void set_has_setposition();
  inline void clear_has_setposition();
  inline void set_has_robot_team();
  inline void clear_has_robot_team();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 guid_;
  ::google::protobuf::RepeatedPtrField< ::Packet::TeamPlayerInfo > member_;
  ::google::protobuf::uint64 leader_;
  ::google::protobuf::uint64 applyleader_;
  int arrangetype_;
  bool group_;
  bool agreeapplyleader_;
  bool auto_match_;
  bool setposition_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > applylist_;
  ::google::protobuf::int32 agreeapplytime_;
  bool robot_team_;
  ::Packet::PurposeInfo* purpose_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static TeamInfo* default_instance_;
};
// -------------------------------------------------------------------

class CreateTeam : public ::google::protobuf::Message {
 public:
  CreateTeam();
  virtual ~CreateTeam();

  CreateTeam(const CreateTeam& from);

  inline CreateTeam& operator=(const CreateTeam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateTeam& default_instance();

  void Swap(CreateTeam* other);

  // implements Message ----------------------------------------------

  CreateTeam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateTeam& from);
  void MergeFrom(const CreateTeam& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Packet.CreateTeam)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static CreateTeam* default_instance_;
};
// -------------------------------------------------------------------

class CreateRobotTeam : public ::google::protobuf::Message {
 public:
  CreateRobotTeam();
  virtual ~CreateRobotTeam();

  CreateRobotTeam(const CreateRobotTeam& from);

  inline CreateRobotTeam& operator=(const CreateRobotTeam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRobotTeam& default_instance();

  void Swap(CreateRobotTeam* other);

  // implements Message ----------------------------------------------

  CreateRobotTeam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRobotTeam& from);
  void MergeFrom(const CreateRobotTeam& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Packet.PlayerBasicInfo basic_info = 1;
  inline int basic_info_size() const;
  inline void clear_basic_info();
  static const int kBasicInfoFieldNumber = 1;
  inline const ::Packet::PlayerBasicInfo& basic_info(int index) const;
  inline ::Packet::PlayerBasicInfo* mutable_basic_info(int index);
  inline ::Packet::PlayerBasicInfo* add_basic_info();
  inline const ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo >&
      basic_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo >*
      mutable_basic_info();

  // repeated int32 one_key_id = 2;
  inline int one_key_id_size() const;
  inline void clear_one_key_id();
  static const int kOneKeyIdFieldNumber = 2;
  inline ::google::protobuf::int32 one_key_id(int index) const;
  inline void set_one_key_id(int index, ::google::protobuf::int32 value);
  inline void add_one_key_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      one_key_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_one_key_id();

  // @@protoc_insertion_point(class_scope:Packet.CreateRobotTeam)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo > basic_info_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > one_key_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static CreateRobotTeam* default_instance_;
};
// -------------------------------------------------------------------

class DelTeam : public ::google::protobuf::Message {
 public:
  DelTeam();
  virtual ~DelTeam();

  DelTeam(const DelTeam& from);

  inline DelTeam& operator=(const DelTeam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DelTeam& default_instance();

  void Swap(DelTeam* other);

  // implements Message ----------------------------------------------

  DelTeam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DelTeam& from);
  void MergeFrom(const DelTeam& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Packet.DelTeam)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static DelTeam* default_instance_;
};
// -------------------------------------------------------------------

class ChangeTeamTypeReq : public ::google::protobuf::Message {
 public:
  ChangeTeamTypeReq();
  virtual ~ChangeTeamTypeReq();

  ChangeTeamTypeReq(const ChangeTeamTypeReq& from);

  inline ChangeTeamTypeReq& operator=(const ChangeTeamTypeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeTeamTypeReq& default_instance();

  void Swap(ChangeTeamTypeReq* other);

  // implements Message ----------------------------------------------

  ChangeTeamTypeReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeTeamTypeReq& from);
  void MergeFrom(const ChangeTeamTypeReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline bool group() const;
  inline void set_group(bool value);

  // @@protoc_insertion_point(class_scope:Packet.ChangeTeamTypeReq)
 private:
  inline void set_has_group();
  inline void clear_has_group();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool group_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static ChangeTeamTypeReq* default_instance_;
};
// -------------------------------------------------------------------

class UpdateTeamTypeReply : public ::google::protobuf::Message {
 public:
  UpdateTeamTypeReply();
  virtual ~UpdateTeamTypeReply();

  UpdateTeamTypeReply(const UpdateTeamTypeReply& from);

  inline UpdateTeamTypeReply& operator=(const UpdateTeamTypeReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateTeamTypeReply& default_instance();

  void Swap(UpdateTeamTypeReply* other);

  // implements Message ----------------------------------------------

  UpdateTeamTypeReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateTeamTypeReply& from);
  void MergeFrom(const UpdateTeamTypeReply& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline bool group() const;
  inline void set_group(bool value);

  // @@protoc_insertion_point(class_scope:Packet.UpdateTeamTypeReply)
 private:
  inline void set_has_group();
  inline void clear_has_group();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool group_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static UpdateTeamTypeReply* default_instance_;
};
// -------------------------------------------------------------------

class ChangeTeamArrangeTypeReq : public ::google::protobuf::Message {
 public:
  ChangeTeamArrangeTypeReq();
  virtual ~ChangeTeamArrangeTypeReq();

  ChangeTeamArrangeTypeReq(const ChangeTeamArrangeTypeReq& from);

  inline ChangeTeamArrangeTypeReq& operator=(const ChangeTeamArrangeTypeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeTeamArrangeTypeReq& default_instance();

  void Swap(ChangeTeamArrangeTypeReq* other);

  // implements Message ----------------------------------------------

  ChangeTeamArrangeTypeReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeTeamArrangeTypeReq& from);
  void MergeFrom(const ChangeTeamArrangeTypeReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Packet.ArrangeType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Packet::ArrangeType type() const;
  inline void set_type(::Packet::ArrangeType value);

  // @@protoc_insertion_point(class_scope:Packet.ChangeTeamArrangeTypeReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static ChangeTeamArrangeTypeReq* default_instance_;
};
// -------------------------------------------------------------------

class UpdateTeamArrangeTypeReply : public ::google::protobuf::Message {
 public:
  UpdateTeamArrangeTypeReply();
  virtual ~UpdateTeamArrangeTypeReply();

  UpdateTeamArrangeTypeReply(const UpdateTeamArrangeTypeReply& from);

  inline UpdateTeamArrangeTypeReply& operator=(const UpdateTeamArrangeTypeReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateTeamArrangeTypeReply& default_instance();

  void Swap(UpdateTeamArrangeTypeReply* other);

  // implements Message ----------------------------------------------

  UpdateTeamArrangeTypeReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateTeamArrangeTypeReply& from);
  void MergeFrom(const UpdateTeamArrangeTypeReply& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Packet.ArrangeType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Packet::ArrangeType type() const;
  inline void set_type(::Packet::ArrangeType value);

  // @@protoc_insertion_point(class_scope:Packet.UpdateTeamArrangeTypeReply)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static UpdateTeamArrangeTypeReply* default_instance_;
};
// -------------------------------------------------------------------

class ApplyTeamReq : public ::google::protobuf::Message {
 public:
  ApplyTeamReq();
  virtual ~ApplyTeamReq();

  ApplyTeamReq(const ApplyTeamReq& from);

  inline ApplyTeamReq& operator=(const ApplyTeamReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyTeamReq& default_instance();

  void Swap(ApplyTeamReq* other);

  // implements Message ----------------------------------------------

  ApplyTeamReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyTeamReq& from);
  void MergeFrom(const ApplyTeamReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 guid = 1;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 1;
  inline ::google::protobuf::uint64 guid() const;
  inline void set_guid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Packet.ApplyTeamReq)
 private:
  inline void set_has_guid();
  inline void clear_has_guid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 guid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static ApplyTeamReq* default_instance_;
};
// -------------------------------------------------------------------

class ApplyMissionTeamReq : public ::google::protobuf::Message {
 public:
  ApplyMissionTeamReq();
  virtual ~ApplyMissionTeamReq();

  ApplyMissionTeamReq(const ApplyMissionTeamReq& from);

  inline ApplyMissionTeamReq& operator=(const ApplyMissionTeamReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyMissionTeamReq& default_instance();

  void Swap(ApplyMissionTeamReq* other);

  // implements Message ----------------------------------------------

  ApplyMissionTeamReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyMissionTeamReq& from);
  void MergeFrom(const ApplyMissionTeamReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 srcplayer_guid = 1;
  inline bool has_srcplayer_guid() const;
  inline void clear_srcplayer_guid();
  static const int kSrcplayerGuidFieldNumber = 1;
  inline ::google::protobuf::uint64 srcplayer_guid() const;
  inline void set_srcplayer_guid(::google::protobuf::uint64 value);

  // required int32 missionid = 2;
  inline bool has_missionid() const;
  inline void clear_missionid();
  static const int kMissionidFieldNumber = 2;
  inline ::google::protobuf::int32 missionid() const;
  inline void set_missionid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Packet.ApplyMissionTeamReq)
 private:
  inline void set_has_srcplayer_guid();
  inline void clear_has_srcplayer_guid();
  inline void set_has_missionid();
  inline void clear_has_missionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 srcplayer_guid_;
  ::google::protobuf::int32 missionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static ApplyMissionTeamReq* default_instance_;
};
// -------------------------------------------------------------------

class LevelTeamReq : public ::google::protobuf::Message {
 public:
  LevelTeamReq();
  virtual ~LevelTeamReq();

  LevelTeamReq(const LevelTeamReq& from);

  inline LevelTeamReq& operator=(const LevelTeamReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LevelTeamReq& default_instance();

  void Swap(LevelTeamReq* other);

  // implements Message ----------------------------------------------

  LevelTeamReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LevelTeamReq& from);
  void MergeFrom(const LevelTeamReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Packet.LevelTeamReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static LevelTeamReq* default_instance_;
};
// -------------------------------------------------------------------

class AskLevelTeamReq : public ::google::protobuf::Message {
 public:
  AskLevelTeamReq();
  virtual ~AskLevelTeamReq();

  AskLevelTeamReq(const AskLevelTeamReq& from);

  inline AskLevelTeamReq& operator=(const AskLevelTeamReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AskLevelTeamReq& default_instance();

  void Swap(AskLevelTeamReq* other);

  // implements Message ----------------------------------------------

  AskLevelTeamReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AskLevelTeamReq& from);
  void MergeFrom(const AskLevelTeamReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 playerguid = 1;
  inline bool has_playerguid() const;
  inline void clear_playerguid();
  static const int kPlayerguidFieldNumber = 1;
  inline ::google::protobuf::uint64 playerguid() const;
  inline void set_playerguid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Packet.AskLevelTeamReq)
 private:
  inline void set_has_playerguid();
  inline void clear_has_playerguid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerguid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static AskLevelTeamReq* default_instance_;
};
// -------------------------------------------------------------------

class AgreeApplyTeamReq : public ::google::protobuf::Message {
 public:
  AgreeApplyTeamReq();
  virtual ~AgreeApplyTeamReq();

  AgreeApplyTeamReq(const AgreeApplyTeamReq& from);

  inline AgreeApplyTeamReq& operator=(const AgreeApplyTeamReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AgreeApplyTeamReq& default_instance();

  void Swap(AgreeApplyTeamReq* other);

  // implements Message ----------------------------------------------

  AgreeApplyTeamReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgreeApplyTeamReq& from);
  void MergeFrom(const AgreeApplyTeamReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 playerguid = 1;
  inline bool has_playerguid() const;
  inline void clear_playerguid();
  static const int kPlayerguidFieldNumber = 1;
  inline ::google::protobuf::uint64 playerguid() const;
  inline void set_playerguid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Packet.AgreeApplyTeamReq)
 private:
  inline void set_has_playerguid();
  inline void clear_has_playerguid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerguid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static AgreeApplyTeamReq* default_instance_;
};
// -------------------------------------------------------------------

class InviteyAddTeamReq : public ::google::protobuf::Message {
 public:
  InviteyAddTeamReq();
  virtual ~InviteyAddTeamReq();

  InviteyAddTeamReq(const InviteyAddTeamReq& from);

  inline InviteyAddTeamReq& operator=(const InviteyAddTeamReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InviteyAddTeamReq& default_instance();

  void Swap(InviteyAddTeamReq* other);

  // implements Message ----------------------------------------------

  InviteyAddTeamReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InviteyAddTeamReq& from);
  void MergeFrom(const InviteyAddTeamReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 playerguid = 1;
  inline bool has_playerguid() const;
  inline void clear_playerguid();
  static const int kPlayerguidFieldNumber = 1;
  inline ::google::protobuf::uint64 playerguid() const;
  inline void set_playerguid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Packet.InviteyAddTeamReq)
 private:
  inline void set_has_playerguid();
  inline void clear_has_playerguid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerguid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static InviteyAddTeamReq* default_instance_;
};
// -------------------------------------------------------------------

class AskInviteyAgreeTeamReply : public ::google::protobuf::Message {
 public:
  AskInviteyAgreeTeamReply();
  virtual ~AskInviteyAgreeTeamReply();

  AskInviteyAgreeTeamReply(const AskInviteyAgreeTeamReply& from);

  inline AskInviteyAgreeTeamReply& operator=(const AskInviteyAgreeTeamReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AskInviteyAgreeTeamReply& default_instance();

  void Swap(AskInviteyAgreeTeamReply* other);

  // implements Message ----------------------------------------------

  AskInviteyAgreeTeamReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AskInviteyAgreeTeamReply& from);
  void MergeFrom(const AskInviteyAgreeTeamReply& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 teamid = 1;
  inline bool has_teamid() const;
  inline void clear_teamid();
  static const int kTeamidFieldNumber = 1;
  inline ::google::protobuf::uint64 teamid() const;
  inline void set_teamid(::google::protobuf::uint64 value);

  // required string teaminvitename = 2;
  inline bool has_teaminvitename() const;
  inline void clear_teaminvitename();
  static const int kTeaminvitenameFieldNumber = 2;
  inline const ::std::string& teaminvitename() const;
  inline void set_teaminvitename(const ::std::string& value);
  inline void set_teaminvitename(const char* value);
  inline void set_teaminvitename(const char* value, size_t size);
  inline ::std::string* mutable_teaminvitename();
  inline ::std::string* release_teaminvitename();
  inline void set_allocated_teaminvitename(::std::string* teaminvitename);

  // required fixed64 teaminviteguid = 3;
  inline bool has_teaminviteguid() const;
  inline void clear_teaminviteguid();
  static const int kTeaminviteguidFieldNumber = 3;
  inline ::google::protobuf::uint64 teaminviteguid() const;
  inline void set_teaminviteguid(::google::protobuf::uint64 value);

  // required int32 purpose = 4;
  inline bool has_purpose() const;
  inline void clear_purpose();
  static const int kPurposeFieldNumber = 4;
  inline ::google::protobuf::int32 purpose() const;
  inline void set_purpose(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Packet.AskInviteyAgreeTeamReply)
 private:
  inline void set_has_teamid();
  inline void clear_has_teamid();
  inline void set_has_teaminvitename();
  inline void clear_has_teaminvitename();
  inline void set_has_teaminviteguid();
  inline void clear_has_teaminviteguid();
  inline void set_has_purpose();
  inline void clear_has_purpose();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 teamid_;
  ::std::string* teaminvitename_;
  ::google::protobuf::uint64 teaminviteguid_;
  ::google::protobuf::int32 purpose_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static AskInviteyAgreeTeamReply* default_instance_;
};
// -------------------------------------------------------------------

class InviteyAgreeTeamReq : public ::google::protobuf::Message {
 public:
  InviteyAgreeTeamReq();
  virtual ~InviteyAgreeTeamReq();

  InviteyAgreeTeamReq(const InviteyAgreeTeamReq& from);

  inline InviteyAgreeTeamReq& operator=(const InviteyAgreeTeamReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InviteyAgreeTeamReq& default_instance();

  void Swap(InviteyAgreeTeamReq* other);

  // implements Message ----------------------------------------------

  InviteyAgreeTeamReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InviteyAgreeTeamReq& from);
  void MergeFrom(const InviteyAgreeTeamReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 teamid = 1;
  inline bool has_teamid() const;
  inline void clear_teamid();
  static const int kTeamidFieldNumber = 1;
  inline ::google::protobuf::uint64 teamid() const;
  inline void set_teamid(::google::protobuf::uint64 value);

  // required bool agree = 2;
  inline bool has_agree() const;
  inline void clear_agree();
  static const int kAgreeFieldNumber = 2;
  inline bool agree() const;
  inline void set_agree(bool value);

  // required fixed64 teaminviteguid = 3;
  inline bool has_teaminviteguid() const;
  inline void clear_teaminviteguid();
  static const int kTeaminviteguidFieldNumber = 3;
  inline ::google::protobuf::uint64 teaminviteguid() const;
  inline void set_teaminviteguid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Packet.InviteyAgreeTeamReq)
 private:
  inline void set_has_teamid();
  inline void clear_has_teamid();
  inline void set_has_agree();
  inline void clear_has_agree();
  inline void set_has_teaminviteguid();
  inline void clear_has_teaminviteguid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 teamid_;
  ::google::protobuf::uint64 teaminviteguid_;
  bool agree_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static InviteyAgreeTeamReq* default_instance_;
};
// -------------------------------------------------------------------

class AddTeamReply : public ::google::protobuf::Message {
 public:
  AddTeamReply();
  virtual ~AddTeamReply();

  AddTeamReply(const AddTeamReply& from);

  inline AddTeamReply& operator=(const AddTeamReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddTeamReply& default_instance();

  void Swap(AddTeamReply* other);

  // implements Message ----------------------------------------------

  AddTeamReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddTeamReply& from);
  void MergeFrom(const AddTeamReply& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 playerguid = 1;
  inline bool has_playerguid() const;
  inline void clear_playerguid();
  static const int kPlayerguidFieldNumber = 1;
  inline ::google::protobuf::uint64 playerguid() const;
  inline void set_playerguid(::google::protobuf::uint64 value);

  // required string playername = 2;
  inline bool has_playername() const;
  inline void clear_playername();
  static const int kPlayernameFieldNumber = 2;
  inline const ::std::string& playername() const;
  inline void set_playername(const ::std::string& value);
  inline void set_playername(const char* value);
  inline void set_playername(const char* value, size_t size);
  inline ::std::string* mutable_playername();
  inline ::std::string* release_playername();
  inline void set_allocated_playername(::std::string* playername);

  // @@protoc_insertion_point(class_scope:Packet.AddTeamReply)
 private:
  inline void set_has_playerguid();
  inline void clear_has_playerguid();
  inline void set_has_playername();
  inline void clear_has_playername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerguid_;
  ::std::string* playername_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static AddTeamReply* default_instance_;
};
// -------------------------------------------------------------------

class LeaveTeamReply : public ::google::protobuf::Message {
 public:
  LeaveTeamReply();
  virtual ~LeaveTeamReply();

  LeaveTeamReply(const LeaveTeamReply& from);

  inline LeaveTeamReply& operator=(const LeaveTeamReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveTeamReply& default_instance();

  void Swap(LeaveTeamReply* other);

  // implements Message ----------------------------------------------

  LeaveTeamReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveTeamReply& from);
  void MergeFrom(const LeaveTeamReply& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 playerguid = 1;
  inline bool has_playerguid() const;
  inline void clear_playerguid();
  static const int kPlayerguidFieldNumber = 1;
  inline ::google::protobuf::uint64 playerguid() const;
  inline void set_playerguid(::google::protobuf::uint64 value);

  // required string playername = 2;
  inline bool has_playername() const;
  inline void clear_playername();
  static const int kPlayernameFieldNumber = 2;
  inline const ::std::string& playername() const;
  inline void set_playername(const ::std::string& value);
  inline void set_playername(const char* value);
  inline void set_playername(const char* value, size_t size);
  inline ::std::string* mutable_playername();
  inline ::std::string* release_playername();
  inline void set_allocated_playername(::std::string* playername);

  // @@protoc_insertion_point(class_scope:Packet.LeaveTeamReply)
 private:
  inline void set_has_playerguid();
  inline void clear_has_playerguid();
  inline void set_has_playername();
  inline void clear_has_playername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerguid_;
  ::std::string* playername_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static LeaveTeamReply* default_instance_;
};
// -------------------------------------------------------------------

class SetPurposeInfoReq : public ::google::protobuf::Message {
 public:
  SetPurposeInfoReq();
  virtual ~SetPurposeInfoReq();

  SetPurposeInfoReq(const SetPurposeInfoReq& from);

  inline SetPurposeInfoReq& operator=(const SetPurposeInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetPurposeInfoReq& default_instance();

  void Swap(SetPurposeInfoReq* other);

  // implements Message ----------------------------------------------

  SetPurposeInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetPurposeInfoReq& from);
  void MergeFrom(const SetPurposeInfoReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Packet.PurposeInfo purpose = 1;
  inline bool has_purpose() const;
  inline void clear_purpose();
  static const int kPurposeFieldNumber = 1;
  inline const ::Packet::PurposeInfo& purpose() const;
  inline ::Packet::PurposeInfo* mutable_purpose();
  inline ::Packet::PurposeInfo* release_purpose();
  inline void set_allocated_purpose(::Packet::PurposeInfo* purpose);

  // @@protoc_insertion_point(class_scope:Packet.SetPurposeInfoReq)
 private:
  inline void set_has_purpose();
  inline void clear_has_purpose();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Packet::PurposeInfo* purpose_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static SetPurposeInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class PurposeInfoUpdate : public ::google::protobuf::Message {
 public:
  PurposeInfoUpdate();
  virtual ~PurposeInfoUpdate();

  PurposeInfoUpdate(const PurposeInfoUpdate& from);

  inline PurposeInfoUpdate& operator=(const PurposeInfoUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PurposeInfoUpdate& default_instance();

  void Swap(PurposeInfoUpdate* other);

  // implements Message ----------------------------------------------

  PurposeInfoUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PurposeInfoUpdate& from);
  void MergeFrom(const PurposeInfoUpdate& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Packet.PurposeInfo purpose = 1;
  inline bool has_purpose() const;
  inline void clear_purpose();
  static const int kPurposeFieldNumber = 1;
  inline const ::Packet::PurposeInfo& purpose() const;
  inline ::Packet::PurposeInfo* mutable_purpose();
  inline ::Packet::PurposeInfo* release_purpose();
  inline void set_allocated_purpose(::Packet::PurposeInfo* purpose);

  // @@protoc_insertion_point(class_scope:Packet.PurposeInfoUpdate)
 private:
  inline void set_has_purpose();
  inline void clear_has_purpose();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Packet::PurposeInfo* purpose_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static PurposeInfoUpdate* default_instance_;
};
// -------------------------------------------------------------------

class SetTeamAutoMatchReq : public ::google::protobuf::Message {
 public:
  SetTeamAutoMatchReq();
  virtual ~SetTeamAutoMatchReq();

  SetTeamAutoMatchReq(const SetTeamAutoMatchReq& from);

  inline SetTeamAutoMatchReq& operator=(const SetTeamAutoMatchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetTeamAutoMatchReq& default_instance();

  void Swap(SetTeamAutoMatchReq* other);

  // implements Message ----------------------------------------------

  SetTeamAutoMatchReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetTeamAutoMatchReq& from);
  void MergeFrom(const SetTeamAutoMatchReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool auto_match = 1;
  inline bool has_auto_match() const;
  inline void clear_auto_match();
  static const int kAutoMatchFieldNumber = 1;
  inline bool auto_match() const;
  inline void set_auto_match(bool value);

  // @@protoc_insertion_point(class_scope:Packet.SetTeamAutoMatchReq)
 private:
  inline void set_has_auto_match();
  inline void clear_has_auto_match();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool auto_match_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static SetTeamAutoMatchReq* default_instance_;
};
// -------------------------------------------------------------------

class TeamAutoMatchUpdate : public ::google::protobuf::Message {
 public:
  TeamAutoMatchUpdate();
  virtual ~TeamAutoMatchUpdate();

  TeamAutoMatchUpdate(const TeamAutoMatchUpdate& from);

  inline TeamAutoMatchUpdate& operator=(const TeamAutoMatchUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamAutoMatchUpdate& default_instance();

  void Swap(TeamAutoMatchUpdate* other);

  // implements Message ----------------------------------------------

  TeamAutoMatchUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamAutoMatchUpdate& from);
  void MergeFrom(const TeamAutoMatchUpdate& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool auto_match = 1;
  inline bool has_auto_match() const;
  inline void clear_auto_match();
  static const int kAutoMatchFieldNumber = 1;
  inline bool auto_match() const;
  inline void set_auto_match(bool value);

  // @@protoc_insertion_point(class_scope:Packet.TeamAutoMatchUpdate)
 private:
  inline void set_has_auto_match();
  inline void clear_has_auto_match();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool auto_match_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static TeamAutoMatchUpdate* default_instance_;
};
// -------------------------------------------------------------------

class TeamFullPlayerInfo : public ::google::protobuf::Message {
 public:
  TeamFullPlayerInfo();
  virtual ~TeamFullPlayerInfo();

  TeamFullPlayerInfo(const TeamFullPlayerInfo& from);

  inline TeamFullPlayerInfo& operator=(const TeamFullPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamFullPlayerInfo& default_instance();

  void Swap(TeamFullPlayerInfo* other);

  // implements Message ----------------------------------------------

  TeamFullPlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamFullPlayerInfo& from);
  void MergeFrom(const TeamFullPlayerInfo& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Packet.PlayerBasicInfo playerbase = 1;
  inline bool has_playerbase() const;
  inline void clear_playerbase();
  static const int kPlayerbaseFieldNumber = 1;
  inline const ::Packet::PlayerBasicInfo& playerbase() const;
  inline ::Packet::PlayerBasicInfo* mutable_playerbase();
  inline ::Packet::PlayerBasicInfo* release_playerbase();
  inline void set_allocated_playerbase(::Packet::PlayerBasicInfo* playerbase);

  // required .Packet.TeamPlayerBasicInfo teambaseinfo = 2;
  inline bool has_teambaseinfo() const;
  inline void clear_teambaseinfo();
  static const int kTeambaseinfoFieldNumber = 2;
  inline const ::Packet::TeamPlayerBasicInfo& teambaseinfo() const;
  inline ::Packet::TeamPlayerBasicInfo* mutable_teambaseinfo();
  inline ::Packet::TeamPlayerBasicInfo* release_teambaseinfo();
  inline void set_allocated_teambaseinfo(::Packet::TeamPlayerBasicInfo* teambaseinfo);

  // @@protoc_insertion_point(class_scope:Packet.TeamFullPlayerInfo)
 private:
  inline void set_has_playerbase();
  inline void clear_has_playerbase();
  inline void set_has_teambaseinfo();
  inline void clear_has_teambaseinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Packet::PlayerBasicInfo* playerbase_;
  ::Packet::TeamPlayerBasicInfo* teambaseinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static TeamFullPlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class TeamListInfo : public ::google::protobuf::Message {
 public:
  TeamListInfo();
  virtual ~TeamListInfo();

  TeamListInfo(const TeamListInfo& from);

  inline TeamListInfo& operator=(const TeamListInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamListInfo& default_instance();

  void Swap(TeamListInfo* other);

  // implements Message ----------------------------------------------

  TeamListInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamListInfo& from);
  void MergeFrom(const TeamListInfo& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 guid = 1;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 1;
  inline ::google::protobuf::uint64 guid() const;
  inline void set_guid(::google::protobuf::uint64 value);

  // required int32 purpose = 2;
  inline bool has_purpose() const;
  inline void clear_purpose();
  static const int kPurposeFieldNumber = 2;
  inline ::google::protobuf::int32 purpose() const;
  inline void set_purpose(::google::protobuf::int32 value);

  // required int32 membersize = 3;
  inline bool has_membersize() const;
  inline void clear_membersize();
  static const int kMembersizeFieldNumber = 3;
  inline ::google::protobuf::int32 membersize() const;
  inline void set_membersize(::google::protobuf::int32 value);

  // required string leadername = 4;
  inline bool has_leadername() const;
  inline void clear_leadername();
  static const int kLeadernameFieldNumber = 4;
  inline const ::std::string& leadername() const;
  inline void set_leadername(const ::std::string& value);
  inline void set_leadername(const char* value);
  inline void set_leadername(const char* value, size_t size);
  inline ::std::string* mutable_leadername();
  inline ::std::string* release_leadername();
  inline void set_allocated_leadername(::std::string* leadername);

  // required int32 leaderlevel = 5;
  inline bool has_leaderlevel() const;
  inline void clear_leaderlevel();
  static const int kLeaderlevelFieldNumber = 5;
  inline ::google::protobuf::int32 leaderlevel() const;
  inline void set_leaderlevel(::google::protobuf::int32 value);

  // required int32 init_actor_id = 6;
  inline bool has_init_actor_id() const;
  inline void clear_init_actor_id();
  static const int kInitActorIdFieldNumber = 6;
  inline ::google::protobuf::int32 init_actor_id() const;
  inline void set_init_actor_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Packet.TeamListInfo)
 private:
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_purpose();
  inline void clear_has_purpose();
  inline void set_has_membersize();
  inline void clear_has_membersize();
  inline void set_has_leadername();
  inline void clear_has_leadername();
  inline void set_has_leaderlevel();
  inline void clear_has_leaderlevel();
  inline void set_has_init_actor_id();
  inline void clear_has_init_actor_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 guid_;
  ::google::protobuf::int32 purpose_;
  ::google::protobuf::int32 membersize_;
  ::std::string* leadername_;
  ::google::protobuf::int32 leaderlevel_;
  ::google::protobuf::int32 init_actor_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static TeamListInfo* default_instance_;
};
// -------------------------------------------------------------------

class TeamInfoReq : public ::google::protobuf::Message {
 public:
  TeamInfoReq();
  virtual ~TeamInfoReq();

  TeamInfoReq(const TeamInfoReq& from);

  inline TeamInfoReq& operator=(const TeamInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamInfoReq& default_instance();

  void Swap(TeamInfoReq* other);

  // implements Message ----------------------------------------------

  TeamInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamInfoReq& from);
  void MergeFrom(const TeamInfoReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Packet.TeamInfoReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static TeamInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class EmptyTeamReply : public ::google::protobuf::Message {
 public:
  EmptyTeamReply();
  virtual ~EmptyTeamReply();

  EmptyTeamReply(const EmptyTeamReply& from);

  inline EmptyTeamReply& operator=(const EmptyTeamReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmptyTeamReply& default_instance();

  void Swap(EmptyTeamReply* other);

  // implements Message ----------------------------------------------

  EmptyTeamReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmptyTeamReply& from);
  void MergeFrom(const EmptyTeamReply& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Packet.EmptyTeamReply)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static EmptyTeamReply* default_instance_;
};
// -------------------------------------------------------------------

class TeamInfoReply : public ::google::protobuf::Message {
 public:
  TeamInfoReply();
  virtual ~TeamInfoReply();

  TeamInfoReply(const TeamInfoReply& from);

  inline TeamInfoReply& operator=(const TeamInfoReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamInfoReply& default_instance();

  void Swap(TeamInfoReply* other);

  // implements Message ----------------------------------------------

  TeamInfoReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamInfoReply& from);
  void MergeFrom(const TeamInfoReply& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 guid = 1;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 1;
  inline ::google::protobuf::uint64 guid() const;
  inline void set_guid(::google::protobuf::uint64 value);

  // repeated .Packet.TeamFullPlayerInfo member = 2;
  inline int member_size() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 2;
  inline const ::Packet::TeamFullPlayerInfo& member(int index) const;
  inline ::Packet::TeamFullPlayerInfo* mutable_member(int index);
  inline ::Packet::TeamFullPlayerInfo* add_member();
  inline const ::google::protobuf::RepeatedPtrField< ::Packet::TeamFullPlayerInfo >&
      member() const;
  inline ::google::protobuf::RepeatedPtrField< ::Packet::TeamFullPlayerInfo >*
      mutable_member();

  // required fixed64 leader = 3;
  inline bool has_leader() const;
  inline void clear_leader();
  static const int kLeaderFieldNumber = 3;
  inline ::google::protobuf::uint64 leader() const;
  inline void set_leader(::google::protobuf::uint64 value);

  // required bool group = 4;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 4;
  inline bool group() const;
  inline void set_group(bool value);

  // required .Packet.ArrangeType arrangetype = 5;
  inline bool has_arrangetype() const;
  inline void clear_arrangetype();
  static const int kArrangetypeFieldNumber = 5;
  inline ::Packet::ArrangeType arrangetype() const;
  inline void set_arrangetype(::Packet::ArrangeType value);

  // required .Packet.PurposeInfo purpose = 6;
  inline bool has_purpose() const;
  inline void clear_purpose();
  static const int kPurposeFieldNumber = 6;
  inline const ::Packet::PurposeInfo& purpose() const;
  inline ::Packet::PurposeInfo* mutable_purpose();
  inline ::Packet::PurposeInfo* release_purpose();
  inline void set_allocated_purpose(::Packet::PurposeInfo* purpose);

  // required bool auto_match = 7;
  inline bool has_auto_match() const;
  inline void clear_auto_match();
  static const int kAutoMatchFieldNumber = 7;
  inline bool auto_match() const;
  inline void set_auto_match(bool value);

  // repeated .Packet.PlayerBasicInfo applylist = 8;
  inline int applylist_size() const;
  inline void clear_applylist();
  static const int kApplylistFieldNumber = 8;
  inline const ::Packet::PlayerBasicInfo& applylist(int index) const;
  inline ::Packet::PlayerBasicInfo* mutable_applylist(int index);
  inline ::Packet::PlayerBasicInfo* add_applylist();
  inline const ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo >&
      applylist() const;
  inline ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo >*
      mutable_applylist();

  // @@protoc_insertion_point(class_scope:Packet.TeamInfoReply)
 private:
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_leader();
  inline void clear_has_leader();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_arrangetype();
  inline void clear_has_arrangetype();
  inline void set_has_purpose();
  inline void clear_has_purpose();
  inline void set_has_auto_match();
  inline void clear_has_auto_match();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 guid_;
  ::google::protobuf::RepeatedPtrField< ::Packet::TeamFullPlayerInfo > member_;
  ::google::protobuf::uint64 leader_;
  int arrangetype_;
  bool group_;
  bool auto_match_;
  ::Packet::PurposeInfo* purpose_;
  ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo > applylist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static TeamInfoReply* default_instance_;
};
// -------------------------------------------------------------------

class FindTeamListReq : public ::google::protobuf::Message {
 public:
  FindTeamListReq();
  virtual ~FindTeamListReq();

  FindTeamListReq(const FindTeamListReq& from);

  inline FindTeamListReq& operator=(const FindTeamListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FindTeamListReq& default_instance();

  void Swap(FindTeamListReq* other);

  // implements Message ----------------------------------------------

  FindTeamListReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FindTeamListReq& from);
  void MergeFrom(const FindTeamListReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Packet.FindTeamListReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static FindTeamListReq* default_instance_;
};
// -------------------------------------------------------------------

class TeamListReply : public ::google::protobuf::Message {
 public:
  TeamListReply();
  virtual ~TeamListReply();

  TeamListReply(const TeamListReply& from);

  inline TeamListReply& operator=(const TeamListReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamListReply& default_instance();

  void Swap(TeamListReply* other);

  // implements Message ----------------------------------------------

  TeamListReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamListReply& from);
  void MergeFrom(const TeamListReply& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Packet.TeamListInfo teams = 1;
  inline int teams_size() const;
  inline void clear_teams();
  static const int kTeamsFieldNumber = 1;
  inline const ::Packet::TeamListInfo& teams(int index) const;
  inline ::Packet::TeamListInfo* mutable_teams(int index);
  inline ::Packet::TeamListInfo* add_teams();
  inline const ::google::protobuf::RepeatedPtrField< ::Packet::TeamListInfo >&
      teams() const;
  inline ::google::protobuf::RepeatedPtrField< ::Packet::TeamListInfo >*
      mutable_teams();

  // @@protoc_insertion_point(class_scope:Packet.TeamListReply)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Packet::TeamListInfo > teams_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static TeamListReply* default_instance_;
};
// -------------------------------------------------------------------

class TeamApplyListReq : public ::google::protobuf::Message {
 public:
  TeamApplyListReq();
  virtual ~TeamApplyListReq();

  TeamApplyListReq(const TeamApplyListReq& from);

  inline TeamApplyListReq& operator=(const TeamApplyListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamApplyListReq& default_instance();

  void Swap(TeamApplyListReq* other);

  // implements Message ----------------------------------------------

  TeamApplyListReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamApplyListReq& from);
  void MergeFrom(const TeamApplyListReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Packet.TeamApplyListReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static TeamApplyListReq* default_instance_;
};
// -------------------------------------------------------------------

class TeamApplyListReply : public ::google::protobuf::Message {
 public:
  TeamApplyListReply();
  virtual ~TeamApplyListReply();

  TeamApplyListReply(const TeamApplyListReply& from);

  inline TeamApplyListReply& operator=(const TeamApplyListReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamApplyListReply& default_instance();

  void Swap(TeamApplyListReply* other);

  // implements Message ----------------------------------------------

  TeamApplyListReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamApplyListReply& from);
  void MergeFrom(const TeamApplyListReply& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Packet.PlayerBasicInfo applylist = 1;
  inline int applylist_size() const;
  inline void clear_applylist();
  static const int kApplylistFieldNumber = 1;
  inline const ::Packet::PlayerBasicInfo& applylist(int index) const;
  inline ::Packet::PlayerBasicInfo* mutable_applylist(int index);
  inline ::Packet::PlayerBasicInfo* add_applylist();
  inline const ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo >&
      applylist() const;
  inline ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo >*
      mutable_applylist();

  // @@protoc_insertion_point(class_scope:Packet.TeamApplyListReply)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo > applylist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static TeamApplyListReply* default_instance_;
};
// -------------------------------------------------------------------

class PlayerAutoMatchInfo : public ::google::protobuf::Message {
 public:
  PlayerAutoMatchInfo();
  virtual ~PlayerAutoMatchInfo();

  PlayerAutoMatchInfo(const PlayerAutoMatchInfo& from);

  inline PlayerAutoMatchInfo& operator=(const PlayerAutoMatchInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerAutoMatchInfo& default_instance();

  void Swap(PlayerAutoMatchInfo* other);

  // implements Message ----------------------------------------------

  PlayerAutoMatchInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerAutoMatchInfo& from);
  void MergeFrom(const PlayerAutoMatchInfo& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 playerguid = 1;
  inline bool has_playerguid() const;
  inline void clear_playerguid();
  static const int kPlayerguidFieldNumber = 1;
  inline ::google::protobuf::uint64 playerguid() const;
  inline void set_playerguid(::google::protobuf::uint64 value);

  // required int32 purpose = 2;
  inline bool has_purpose() const;
  inline void clear_purpose();
  static const int kPurposeFieldNumber = 2;
  inline ::google::protobuf::int32 purpose() const;
  inline void set_purpose(::google::protobuf::int32 value);

  // required int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required int32 hero_position = 4;
  inline bool has_hero_position() const;
  inline void clear_hero_position();
  static const int kHeroPositionFieldNumber = 4;
  inline ::google::protobuf::int32 hero_position() const;
  inline void set_hero_position(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Packet.PlayerAutoMatchInfo)
 private:
  inline void set_has_playerguid();
  inline void clear_has_playerguid();
  inline void set_has_purpose();
  inline void clear_has_purpose();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_hero_position();
  inline void clear_has_hero_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerguid_;
  ::google::protobuf::int32 purpose_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 hero_position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static PlayerAutoMatchInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlayerAutoMatchReq : public ::google::protobuf::Message {
 public:
  PlayerAutoMatchReq();
  virtual ~PlayerAutoMatchReq();

  PlayerAutoMatchReq(const PlayerAutoMatchReq& from);

  inline PlayerAutoMatchReq& operator=(const PlayerAutoMatchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerAutoMatchReq& default_instance();

  void Swap(PlayerAutoMatchReq* other);

  // implements Message ----------------------------------------------

  PlayerAutoMatchReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerAutoMatchReq& from);
  void MergeFrom(const PlayerAutoMatchReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool auto_match = 1;
  inline bool has_auto_match() const;
  inline void clear_auto_match();
  static const int kAutoMatchFieldNumber = 1;
  inline bool auto_match() const;
  inline void set_auto_match(bool value);

  // required int32 purpose = 2;
  inline bool has_purpose() const;
  inline void clear_purpose();
  static const int kPurposeFieldNumber = 2;
  inline ::google::protobuf::int32 purpose() const;
  inline void set_purpose(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Packet.PlayerAutoMatchReq)
 private:
  inline void set_has_auto_match();
  inline void clear_has_auto_match();
  inline void set_has_purpose();
  inline void clear_has_purpose();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool auto_match_;
  ::google::protobuf::int32 purpose_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static PlayerAutoMatchReq* default_instance_;
};
// -------------------------------------------------------------------

class PlayerAutoMatchReply : public ::google::protobuf::Message {
 public:
  PlayerAutoMatchReply();
  virtual ~PlayerAutoMatchReply();

  PlayerAutoMatchReply(const PlayerAutoMatchReply& from);

  inline PlayerAutoMatchReply& operator=(const PlayerAutoMatchReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerAutoMatchReply& default_instance();

  void Swap(PlayerAutoMatchReply* other);

  // implements Message ----------------------------------------------

  PlayerAutoMatchReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerAutoMatchReply& from);
  void MergeFrom(const PlayerAutoMatchReply& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool auto_match = 1;
  inline bool has_auto_match() const;
  inline void clear_auto_match();
  static const int kAutoMatchFieldNumber = 1;
  inline bool auto_match() const;
  inline void set_auto_match(bool value);

  // optional int32 purpose = 2;
  inline bool has_purpose() const;
  inline void clear_purpose();
  static const int kPurposeFieldNumber = 2;
  inline ::google::protobuf::int32 purpose() const;
  inline void set_purpose(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Packet.PlayerAutoMatchReply)
 private:
  inline void set_has_auto_match();
  inline void clear_has_auto_match();
  inline void set_has_purpose();
  inline void clear_has_purpose();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool auto_match_;
  ::google::protobuf::int32 purpose_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static PlayerAutoMatchReply* default_instance_;
};
// -------------------------------------------------------------------

class PlayerSetTeamStatusReq : public ::google::protobuf::Message {
 public:
  PlayerSetTeamStatusReq();
  virtual ~PlayerSetTeamStatusReq();

  PlayerSetTeamStatusReq(const PlayerSetTeamStatusReq& from);

  inline PlayerSetTeamStatusReq& operator=(const PlayerSetTeamStatusReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerSetTeamStatusReq& default_instance();

  void Swap(PlayerSetTeamStatusReq* other);

  // implements Message ----------------------------------------------

  PlayerSetTeamStatusReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerSetTeamStatusReq& from);
  void MergeFrom(const PlayerSetTeamStatusReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Packet.PlayerTeamStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::Packet::PlayerTeamStatus status() const;
  inline void set_status(::Packet::PlayerTeamStatus value);

  // @@protoc_insertion_point(class_scope:Packet.PlayerSetTeamStatusReq)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static PlayerSetTeamStatusReq* default_instance_;
};
// -------------------------------------------------------------------

class TeamPlayerBasicUpdate : public ::google::protobuf::Message {
 public:
  TeamPlayerBasicUpdate();
  virtual ~TeamPlayerBasicUpdate();

  TeamPlayerBasicUpdate(const TeamPlayerBasicUpdate& from);

  inline TeamPlayerBasicUpdate& operator=(const TeamPlayerBasicUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamPlayerBasicUpdate& default_instance();

  void Swap(TeamPlayerBasicUpdate* other);

  // implements Message ----------------------------------------------

  TeamPlayerBasicUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamPlayerBasicUpdate& from);
  void MergeFrom(const TeamPlayerBasicUpdate& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Packet.TeamFullPlayerInfo playerinfo = 1;
  inline bool has_playerinfo() const;
  inline void clear_playerinfo();
  static const int kPlayerinfoFieldNumber = 1;
  inline const ::Packet::TeamFullPlayerInfo& playerinfo() const;
  inline ::Packet::TeamFullPlayerInfo* mutable_playerinfo();
  inline ::Packet::TeamFullPlayerInfo* release_playerinfo();
  inline void set_allocated_playerinfo(::Packet::TeamFullPlayerInfo* playerinfo);

  // @@protoc_insertion_point(class_scope:Packet.TeamPlayerBasicUpdate)
 private:
  inline void set_has_playerinfo();
  inline void clear_has_playerinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Packet::TeamFullPlayerInfo* playerinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static TeamPlayerBasicUpdate* default_instance_;
};
// -------------------------------------------------------------------

class SetTeamLeaderReq : public ::google::protobuf::Message {
 public:
  SetTeamLeaderReq();
  virtual ~SetTeamLeaderReq();

  SetTeamLeaderReq(const SetTeamLeaderReq& from);

  inline SetTeamLeaderReq& operator=(const SetTeamLeaderReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetTeamLeaderReq& default_instance();

  void Swap(SetTeamLeaderReq* other);

  // implements Message ----------------------------------------------

  SetTeamLeaderReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetTeamLeaderReq& from);
  void MergeFrom(const SetTeamLeaderReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 playerguid = 1;
  inline bool has_playerguid() const;
  inline void clear_playerguid();
  static const int kPlayerguidFieldNumber = 1;
  inline ::google::protobuf::uint64 playerguid() const;
  inline void set_playerguid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Packet.SetTeamLeaderReq)
 private:
  inline void set_has_playerguid();
  inline void clear_has_playerguid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerguid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static SetTeamLeaderReq* default_instance_;
};
// -------------------------------------------------------------------

class ApplyTeamLeaderReq : public ::google::protobuf::Message {
 public:
  ApplyTeamLeaderReq();
  virtual ~ApplyTeamLeaderReq();

  ApplyTeamLeaderReq(const ApplyTeamLeaderReq& from);

  inline ApplyTeamLeaderReq& operator=(const ApplyTeamLeaderReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyTeamLeaderReq& default_instance();

  void Swap(ApplyTeamLeaderReq* other);

  // implements Message ----------------------------------------------

  ApplyTeamLeaderReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyTeamLeaderReq& from);
  void MergeFrom(const ApplyTeamLeaderReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Packet.ApplyTeamLeaderReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static ApplyTeamLeaderReq* default_instance_;
};
// -------------------------------------------------------------------

class AskApplyTeamLeaderReq : public ::google::protobuf::Message {
 public:
  AskApplyTeamLeaderReq();
  virtual ~AskApplyTeamLeaderReq();

  AskApplyTeamLeaderReq(const AskApplyTeamLeaderReq& from);

  inline AskApplyTeamLeaderReq& operator=(const AskApplyTeamLeaderReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AskApplyTeamLeaderReq& default_instance();

  void Swap(AskApplyTeamLeaderReq* other);

  // implements Message ----------------------------------------------

  AskApplyTeamLeaderReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AskApplyTeamLeaderReq& from);
  void MergeFrom(const AskApplyTeamLeaderReq& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 playerguid = 1;
  inline bool has_playerguid() const;
  inline void clear_playerguid();
  static const int kPlayerguidFieldNumber = 1;
  inline ::google::protobuf::uint64 playerguid() const;
  inline void set_playerguid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Packet.AskApplyTeamLeaderReq)
 private:
  inline void set_has_playerguid();
  inline void clear_has_playerguid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerguid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static AskApplyTeamLeaderReq* default_instance_;
};
// -------------------------------------------------------------------

class AskApplyTeamLeaderReply : public ::google::protobuf::Message {
 public:
  AskApplyTeamLeaderReply();
  virtual ~AskApplyTeamLeaderReply();

  AskApplyTeamLeaderReply(const AskApplyTeamLeaderReply& from);

  inline AskApplyTeamLeaderReply& operator=(const AskApplyTeamLeaderReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AskApplyTeamLeaderReply& default_instance();

  void Swap(AskApplyTeamLeaderReply* other);

  // implements Message ----------------------------------------------

  AskApplyTeamLeaderReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AskApplyTeamLeaderReply& from);
  void MergeFrom(const AskApplyTeamLeaderReply& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool agree = 1;
  inline bool has_agree() const;
  inline void clear_agree();
  static const int kAgreeFieldNumber = 1;
  inline bool agree() const;
  inline void set_agree(bool value);

  // @@protoc_insertion_point(class_scope:Packet.AskApplyTeamLeaderReply)
 private:
  inline void set_has_agree();
  inline void clear_has_agree();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool agree_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static AskApplyTeamLeaderReply* default_instance_;
};
// -------------------------------------------------------------------

class TeamLeaderUpdate : public ::google::protobuf::Message {
 public:
  TeamLeaderUpdate();
  virtual ~TeamLeaderUpdate();

  TeamLeaderUpdate(const TeamLeaderUpdate& from);

  inline TeamLeaderUpdate& operator=(const TeamLeaderUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamLeaderUpdate& default_instance();

  void Swap(TeamLeaderUpdate* other);

  // implements Message ----------------------------------------------

  TeamLeaderUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamLeaderUpdate& from);
  void MergeFrom(const TeamLeaderUpdate& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 playerguid = 1;
  inline bool has_playerguid() const;
  inline void clear_playerguid();
  static const int kPlayerguidFieldNumber = 1;
  inline ::google::protobuf::uint64 playerguid() const;
  inline void set_playerguid(::google::protobuf::uint64 value);

  // required string playername = 2;
  inline bool has_playername() const;
  inline void clear_playername();
  static const int kPlayernameFieldNumber = 2;
  inline const ::std::string& playername() const;
  inline void set_playername(const ::std::string& value);
  inline void set_playername(const char* value);
  inline void set_playername(const char* value, size_t size);
  inline ::std::string* mutable_playername();
  inline ::std::string* release_playername();
  inline void set_allocated_playername(::std::string* playername);

  // required fixed32 move_speed = 3;
  inline bool has_move_speed() const;
  inline void clear_move_speed();
  static const int kMoveSpeedFieldNumber = 3;
  inline ::google::protobuf::uint32 move_speed() const;
  inline void set_move_speed(::google::protobuf::uint32 value);

  // required bool charge = 4;
  inline bool has_charge() const;
  inline void clear_charge();
  static const int kChargeFieldNumber = 4;
  inline bool charge() const;
  inline void set_charge(bool value);

  // @@protoc_insertion_point(class_scope:Packet.TeamLeaderUpdate)
 private:
  inline void set_has_playerguid();
  inline void clear_has_playerguid();
  inline void set_has_playername();
  inline void clear_has_playername();
  inline void set_has_move_speed();
  inline void clear_has_move_speed();
  inline void set_has_charge();
  inline void clear_has_charge();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 playerguid_;
  ::std::string* playername_;
  ::google::protobuf::uint32 move_speed_;
  bool charge_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static TeamLeaderUpdate* default_instance_;
};
// -------------------------------------------------------------------

class RobotPlayerInOk : public ::google::protobuf::Message {
 public:
  RobotPlayerInOk();
  virtual ~RobotPlayerInOk();

  RobotPlayerInOk(const RobotPlayerInOk& from);

  inline RobotPlayerInOk& operator=(const RobotPlayerInOk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotPlayerInOk& default_instance();

  void Swap(RobotPlayerInOk* other);

  // implements Message ----------------------------------------------

  RobotPlayerInOk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotPlayerInOk& from);
  void MergeFrom(const RobotPlayerInOk& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Packet.PlayerBasicInfo basic_info = 1;
  inline int basic_info_size() const;
  inline void clear_basic_info();
  static const int kBasicInfoFieldNumber = 1;
  inline const ::Packet::PlayerBasicInfo& basic_info(int index) const;
  inline ::Packet::PlayerBasicInfo* mutable_basic_info(int index);
  inline ::Packet::PlayerBasicInfo* add_basic_info();
  inline const ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo >&
      basic_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo >*
      mutable_basic_info();

  // repeated int32 one_key_id = 2;
  inline int one_key_id_size() const;
  inline void clear_one_key_id();
  static const int kOneKeyIdFieldNumber = 2;
  inline ::google::protobuf::int32 one_key_id(int index) const;
  inline void set_one_key_id(int index, ::google::protobuf::int32 value);
  inline void add_one_key_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      one_key_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_one_key_id();

  // @@protoc_insertion_point(class_scope:Packet.RobotPlayerInOk)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo > basic_info_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > one_key_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static RobotPlayerInOk* default_instance_;
};
// -------------------------------------------------------------------

class TeamAutomatchConfig : public ::google::protobuf::Message {
 public:
  TeamAutomatchConfig();
  virtual ~TeamAutomatchConfig();

  TeamAutomatchConfig(const TeamAutomatchConfig& from);

  inline TeamAutomatchConfig& operator=(const TeamAutomatchConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamAutomatchConfig& default_instance();

  void Swap(TeamAutomatchConfig* other);

  // implements Message ----------------------------------------------

  TeamAutomatchConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamAutomatchConfig& from);
  void MergeFrom(const TeamAutomatchConfig& from);
  void Clear();
  bool IsInitialized() const;
  void SetInitialized();

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 group = 2;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 2;
  inline ::google::protobuf::int32 group() const;
  inline void set_group(::google::protobuf::int32 value);

  // required int32 defence_count = 3;
  inline bool has_defence_count() const;
  inline void clear_defence_count();
  static const int kDefenceCountFieldNumber = 3;
  inline ::google::protobuf::int32 defence_count() const;
  inline void set_defence_count(::google::protobuf::int32 value);

  // required int32 cure_count = 4;
  inline bool has_cure_count() const;
  inline void clear_cure_count();
  static const int kCureCountFieldNumber = 4;
  inline ::google::protobuf::int32 cure_count() const;
  inline void set_cure_count(::google::protobuf::int32 value);

  // required int32 attack_count = 5;
  inline bool has_attack_count() const;
  inline void clear_attack_count();
  static const int kAttackCountFieldNumber = 5;
  inline ::google::protobuf::int32 attack_count() const;
  inline void set_attack_count(::google::protobuf::int32 value);

  // required int32 need_defence_count = 6;
  inline bool has_need_defence_count() const;
  inline void clear_need_defence_count();
  static const int kNeedDefenceCountFieldNumber = 6;
  inline ::google::protobuf::int32 need_defence_count() const;
  inline void set_need_defence_count(::google::protobuf::int32 value);

  // required int32 need_cure_count = 7;
  inline bool has_need_cure_count() const;
  inline void clear_need_cure_count();
  static const int kNeedCureCountFieldNumber = 7;
  inline ::google::protobuf::int32 need_cure_count() const;
  inline void set_need_cure_count(::google::protobuf::int32 value);

  // required int32 need_attack_count = 8;
  inline bool has_need_attack_count() const;
  inline void clear_need_attack_count();
  static const int kNeedAttackCountFieldNumber = 8;
  inline ::google::protobuf::int32 need_attack_count() const;
  inline void set_need_attack_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Packet.TeamAutomatchConfig)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_defence_count();
  inline void clear_has_defence_count();
  inline void set_has_cure_count();
  inline void clear_has_cure_count();
  inline void set_has_attack_count();
  inline void clear_has_attack_count();
  inline void set_has_need_defence_count();
  inline void clear_has_need_defence_count();
  inline void set_has_need_cure_count();
  inline void clear_has_need_cure_count();
  inline void set_has_need_attack_count();
  inline void clear_has_need_attack_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 group_;
  ::google::protobuf::int32 defence_count_;
  ::google::protobuf::int32 cure_count_;
  ::google::protobuf::int32 attack_count_;
  ::google::protobuf::int32 need_defence_count_;
  ::google::protobuf::int32 need_cure_count_;
  ::google::protobuf::int32 need_attack_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_Team_2eproto();
  friend void protobuf_AssignDesc_Team_2eproto();
  friend void protobuf_ShutdownFile_Team_2eproto();

  void InitAsDefaultInstance();
  static TeamAutomatchConfig* default_instance_;
};
// ===================================================================


// ===================================================================

// PurposeInfo

// required int32 purpose = 1;
inline bool PurposeInfo::has_purpose() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PurposeInfo::set_has_purpose() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PurposeInfo::clear_has_purpose() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PurposeInfo::clear_purpose() {
  purpose_ = 0;
  clear_has_purpose();
  SetDirty();
}
inline ::google::protobuf::int32 PurposeInfo::purpose() const {
  return purpose_;
}
inline void PurposeInfo::set_purpose(::google::protobuf::int32 value) {
  SetDirty();
  set_has_purpose();
  purpose_ = value;
}

// required int32 level_limt_min = 2;
inline bool PurposeInfo::has_level_limt_min() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PurposeInfo::set_has_level_limt_min() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PurposeInfo::clear_has_level_limt_min() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PurposeInfo::clear_level_limt_min() {
  level_limt_min_ = 0;
  clear_has_level_limt_min();
  SetDirty();
}
inline ::google::protobuf::int32 PurposeInfo::level_limt_min() const {
  return level_limt_min_;
}
inline void PurposeInfo::set_level_limt_min(::google::protobuf::int32 value) {
  SetDirty();
  set_has_level_limt_min();
  level_limt_min_ = value;
}

// required int32 level_limt_max = 3;
inline bool PurposeInfo::has_level_limt_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PurposeInfo::set_has_level_limt_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PurposeInfo::clear_has_level_limt_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PurposeInfo::clear_level_limt_max() {
  level_limt_max_ = 0;
  clear_has_level_limt_max();
  SetDirty();
}
inline ::google::protobuf::int32 PurposeInfo::level_limt_max() const {
  return level_limt_max_;
}
inline void PurposeInfo::set_level_limt_max(::google::protobuf::int32 value) {
  SetDirty();
  set_has_level_limt_max();
  level_limt_max_ = value;
}

// -------------------------------------------------------------------

// TeamPlayerBasicInfo

// required .Packet.PlayerTeamStatus playerstatus = 1;
inline bool TeamPlayerBasicInfo::has_playerstatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamPlayerBasicInfo::set_has_playerstatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamPlayerBasicInfo::clear_has_playerstatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamPlayerBasicInfo::clear_playerstatus() {
  playerstatus_ = 0;
  clear_has_playerstatus();
  SetDirty();
}
inline ::Packet::PlayerTeamStatus TeamPlayerBasicInfo::playerstatus() const {
  return static_cast< ::Packet::PlayerTeamStatus >(playerstatus_);
}
inline void TeamPlayerBasicInfo::set_playerstatus(::Packet::PlayerTeamStatus value) {
  assert(::Packet::PlayerTeamStatus_IsValid(value));
  SetDirty();
  set_has_playerstatus();
  playerstatus_ = value;
}

// required int32 position_index = 2;
inline bool TeamPlayerBasicInfo::has_position_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamPlayerBasicInfo::set_has_position_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamPlayerBasicInfo::clear_has_position_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamPlayerBasicInfo::clear_position_index() {
  position_index_ = 0;
  clear_has_position_index();
  SetDirty();
}
inline ::google::protobuf::int32 TeamPlayerBasicInfo::position_index() const {
  return position_index_;
}
inline void TeamPlayerBasicInfo::set_position_index(::google::protobuf::int32 value) {
  SetDirty();
  set_has_position_index();
  position_index_ = value;
}

// required int32 hero_position = 3;
inline bool TeamPlayerBasicInfo::has_hero_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeamPlayerBasicInfo::set_has_hero_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeamPlayerBasicInfo::clear_has_hero_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeamPlayerBasicInfo::clear_hero_position() {
  hero_position_ = 0;
  clear_has_hero_position();
  SetDirty();
}
inline ::google::protobuf::int32 TeamPlayerBasicInfo::hero_position() const {
  return hero_position_;
}
inline void TeamPlayerBasicInfo::set_hero_position(::google::protobuf::int32 value) {
  SetDirty();
  set_has_hero_position();
  hero_position_ = value;
}

// -------------------------------------------------------------------

// TeamPlayerInfo

// required fixed64 playerguid = 1;
inline bool TeamPlayerInfo::has_playerguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamPlayerInfo::set_has_playerguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamPlayerInfo::clear_has_playerguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamPlayerInfo::clear_playerguid() {
  playerguid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerguid();
  SetDirty();
}
inline ::google::protobuf::uint64 TeamPlayerInfo::playerguid() const {
  return playerguid_;
}
inline void TeamPlayerInfo::set_playerguid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_playerguid();
  playerguid_ = value;
}

// required .Packet.TeamPlayerBasicInfo teambaseinfo = 2;
inline bool TeamPlayerInfo::has_teambaseinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamPlayerInfo::set_has_teambaseinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamPlayerInfo::clear_has_teambaseinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamPlayerInfo::clear_teambaseinfo() {
  if (teambaseinfo_ != NULL) teambaseinfo_->::Packet::TeamPlayerBasicInfo::Clear();
  clear_has_teambaseinfo();
  SetDirty();
}
inline const ::Packet::TeamPlayerBasicInfo& TeamPlayerInfo::teambaseinfo() const {
  return teambaseinfo_ != NULL ? *teambaseinfo_ : *default_instance_->teambaseinfo_;
}
inline ::Packet::TeamPlayerBasicInfo* TeamPlayerInfo::mutable_teambaseinfo() {
  SetDirty();
  set_has_teambaseinfo();
  if (teambaseinfo_ == NULL) teambaseinfo_ = new ::Packet::TeamPlayerBasicInfo;
  return teambaseinfo_;
}
inline ::Packet::TeamPlayerBasicInfo* TeamPlayerInfo::release_teambaseinfo() {
  SetDirty();
  clear_has_teambaseinfo();
  ::Packet::TeamPlayerBasicInfo* temp = teambaseinfo_;
  teambaseinfo_ = NULL;
  return temp;
}
inline void TeamPlayerInfo::set_allocated_teambaseinfo(::Packet::TeamPlayerBasicInfo* teambaseinfo) {
  SetDirty();
  delete teambaseinfo_;
  teambaseinfo_ = teambaseinfo;
  if (teambaseinfo) {
    set_has_teambaseinfo();
  } else {
    clear_has_teambaseinfo();
  }
}

// optional .Packet.PlayerBasicInfo basic_info = 3;
inline bool TeamPlayerInfo::has_basic_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeamPlayerInfo::set_has_basic_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeamPlayerInfo::clear_has_basic_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeamPlayerInfo::clear_basic_info() {
  if (basic_info_ != NULL) basic_info_->::Packet::PlayerBasicInfo::Clear();
  clear_has_basic_info();
  SetDirty();
}
inline const ::Packet::PlayerBasicInfo& TeamPlayerInfo::basic_info() const {
  return basic_info_ != NULL ? *basic_info_ : *default_instance_->basic_info_;
}
inline ::Packet::PlayerBasicInfo* TeamPlayerInfo::mutable_basic_info() {
  SetDirty();
  set_has_basic_info();
  if (basic_info_ == NULL) basic_info_ = new ::Packet::PlayerBasicInfo;
  return basic_info_;
}
inline ::Packet::PlayerBasicInfo* TeamPlayerInfo::release_basic_info() {
  SetDirty();
  clear_has_basic_info();
  ::Packet::PlayerBasicInfo* temp = basic_info_;
  basic_info_ = NULL;
  return temp;
}
inline void TeamPlayerInfo::set_allocated_basic_info(::Packet::PlayerBasicInfo* basic_info) {
  SetDirty();
  delete basic_info_;
  basic_info_ = basic_info;
  if (basic_info) {
    set_has_basic_info();
  } else {
    clear_has_basic_info();
  }
}

// optional bool is_robot = 4;
inline bool TeamPlayerInfo::has_is_robot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TeamPlayerInfo::set_has_is_robot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TeamPlayerInfo::clear_has_is_robot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TeamPlayerInfo::clear_is_robot() {
  is_robot_ = false;
  clear_has_is_robot();
  SetDirty();
}
inline bool TeamPlayerInfo::is_robot() const {
  return is_robot_;
}
inline void TeamPlayerInfo::set_is_robot(bool value) {
  SetDirty();
  set_has_is_robot();
  is_robot_ = value;
}

// -------------------------------------------------------------------

// SetTeamHeroPositionReq

// required int32 position_index = 1;
inline bool SetTeamHeroPositionReq::has_position_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetTeamHeroPositionReq::set_has_position_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetTeamHeroPositionReq::clear_has_position_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetTeamHeroPositionReq::clear_position_index() {
  position_index_ = 0;
  clear_has_position_index();
  SetDirty();
}
inline ::google::protobuf::int32 SetTeamHeroPositionReq::position_index() const {
  return position_index_;
}
inline void SetTeamHeroPositionReq::set_position_index(::google::protobuf::int32 value) {
  SetDirty();
  set_has_position_index();
  position_index_ = value;
}

// required int32 hero_position = 2;
inline bool SetTeamHeroPositionReq::has_hero_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetTeamHeroPositionReq::set_has_hero_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetTeamHeroPositionReq::clear_has_hero_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetTeamHeroPositionReq::clear_hero_position() {
  hero_position_ = 0;
  clear_has_hero_position();
  SetDirty();
}
inline ::google::protobuf::int32 SetTeamHeroPositionReq::hero_position() const {
  return hero_position_;
}
inline void SetTeamHeroPositionReq::set_hero_position(::google::protobuf::int32 value) {
  SetDirty();
  set_has_hero_position();
  hero_position_ = value;
}

// -------------------------------------------------------------------

// SetTeamHeroPositionReply

// required int32 position_index = 1;
inline bool SetTeamHeroPositionReply::has_position_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetTeamHeroPositionReply::set_has_position_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetTeamHeroPositionReply::clear_has_position_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetTeamHeroPositionReply::clear_position_index() {
  position_index_ = 0;
  clear_has_position_index();
  SetDirty();
}
inline ::google::protobuf::int32 SetTeamHeroPositionReply::position_index() const {
  return position_index_;
}
inline void SetTeamHeroPositionReply::set_position_index(::google::protobuf::int32 value) {
  SetDirty();
  set_has_position_index();
  position_index_ = value;
}

// required int32 hero_position = 2;
inline bool SetTeamHeroPositionReply::has_hero_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetTeamHeroPositionReply::set_has_hero_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetTeamHeroPositionReply::clear_has_hero_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetTeamHeroPositionReply::clear_hero_position() {
  hero_position_ = 0;
  clear_has_hero_position();
  SetDirty();
}
inline ::google::protobuf::int32 SetTeamHeroPositionReply::hero_position() const {
  return hero_position_;
}
inline void SetTeamHeroPositionReply::set_hero_position(::google::protobuf::int32 value) {
  SetDirty();
  set_has_hero_position();
  hero_position_ = value;
}

// -------------------------------------------------------------------

// TeamInfo

// required fixed64 guid = 1;
inline bool TeamInfo::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamInfo::set_has_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamInfo::clear_has_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamInfo::clear_guid() {
  guid_ = GOOGLE_ULONGLONG(0);
  clear_has_guid();
  SetDirty();
}
inline ::google::protobuf::uint64 TeamInfo::guid() const {
  return guid_;
}
inline void TeamInfo::set_guid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_guid();
  guid_ = value;
}

// repeated .Packet.TeamPlayerInfo member = 2;
inline int TeamInfo::member_size() const {
  return member_.size();
}
inline void TeamInfo::clear_member() {
  member_.Clear();
  SetDirty();
}
inline const ::Packet::TeamPlayerInfo& TeamInfo::member(int index) const {
  return member_.Get(index);
}
inline ::Packet::TeamPlayerInfo* TeamInfo::mutable_member(int index) {
  SetDirty();
  return member_.Mutable(index);
}
inline ::Packet::TeamPlayerInfo* TeamInfo::add_member() {
  SetDirty();
  return member_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Packet::TeamPlayerInfo >&
TeamInfo::member() const {
  return member_;
}
inline ::google::protobuf::RepeatedPtrField< ::Packet::TeamPlayerInfo >*
TeamInfo::mutable_member() {
  SetDirty();
  return &member_;
}

// required bool group = 3;
inline bool TeamInfo::has_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeamInfo::set_has_group() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeamInfo::clear_has_group() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeamInfo::clear_group() {
  group_ = false;
  clear_has_group();
  SetDirty();
}
inline bool TeamInfo::group() const {
  return group_;
}
inline void TeamInfo::set_group(bool value) {
  SetDirty();
  set_has_group();
  group_ = value;
}

// required .Packet.ArrangeType arrangetype = 4;
inline bool TeamInfo::has_arrangetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TeamInfo::set_has_arrangetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TeamInfo::clear_has_arrangetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TeamInfo::clear_arrangetype() {
  arrangetype_ = -1;
  clear_has_arrangetype();
  SetDirty();
}
inline ::Packet::ArrangeType TeamInfo::arrangetype() const {
  return static_cast< ::Packet::ArrangeType >(arrangetype_);
}
inline void TeamInfo::set_arrangetype(::Packet::ArrangeType value) {
  assert(::Packet::ArrangeType_IsValid(value));
  SetDirty();
  set_has_arrangetype();
  arrangetype_ = value;
}

// required fixed64 leader = 5;
inline bool TeamInfo::has_leader() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TeamInfo::set_has_leader() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TeamInfo::clear_has_leader() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TeamInfo::clear_leader() {
  leader_ = GOOGLE_ULONGLONG(0);
  clear_has_leader();
  SetDirty();
}
inline ::google::protobuf::uint64 TeamInfo::leader() const {
  return leader_;
}
inline void TeamInfo::set_leader(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_leader();
  leader_ = value;
}

// required fixed64 applyleader = 6;
inline bool TeamInfo::has_applyleader() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TeamInfo::set_has_applyleader() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TeamInfo::clear_has_applyleader() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TeamInfo::clear_applyleader() {
  applyleader_ = GOOGLE_ULONGLONG(0);
  clear_has_applyleader();
  SetDirty();
}
inline ::google::protobuf::uint64 TeamInfo::applyleader() const {
  return applyleader_;
}
inline void TeamInfo::set_applyleader(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_applyleader();
  applyleader_ = value;
}

// required bool agreeapplyleader = 7;
inline bool TeamInfo::has_agreeapplyleader() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TeamInfo::set_has_agreeapplyleader() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TeamInfo::clear_has_agreeapplyleader() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TeamInfo::clear_agreeapplyleader() {
  agreeapplyleader_ = false;
  clear_has_agreeapplyleader();
  SetDirty();
}
inline bool TeamInfo::agreeapplyleader() const {
  return agreeapplyleader_;
}
inline void TeamInfo::set_agreeapplyleader(bool value) {
  SetDirty();
  set_has_agreeapplyleader();
  agreeapplyleader_ = value;
}

// required int32 agreeapplytime = 8;
inline bool TeamInfo::has_agreeapplytime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TeamInfo::set_has_agreeapplytime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TeamInfo::clear_has_agreeapplytime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TeamInfo::clear_agreeapplytime() {
  agreeapplytime_ = 0;
  clear_has_agreeapplytime();
  SetDirty();
}
inline ::google::protobuf::int32 TeamInfo::agreeapplytime() const {
  return agreeapplytime_;
}
inline void TeamInfo::set_agreeapplytime(::google::protobuf::int32 value) {
  SetDirty();
  set_has_agreeapplytime();
  agreeapplytime_ = value;
}

// required bool auto_match = 9;
inline bool TeamInfo::has_auto_match() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TeamInfo::set_has_auto_match() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TeamInfo::clear_has_auto_match() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TeamInfo::clear_auto_match() {
  auto_match_ = false;
  clear_has_auto_match();
  SetDirty();
}
inline bool TeamInfo::auto_match() const {
  return auto_match_;
}
inline void TeamInfo::set_auto_match(bool value) {
  SetDirty();
  set_has_auto_match();
  auto_match_ = value;
}

// repeated fixed64 applylist = 10;
inline int TeamInfo::applylist_size() const {
  return applylist_.size();
}
inline void TeamInfo::clear_applylist() {
  applylist_.Clear();
  SetDirty();
}
inline ::google::protobuf::uint64 TeamInfo::applylist(int index) const {
  return applylist_.Get(index);
}
inline void TeamInfo::set_applylist(int index, ::google::protobuf::uint64 value) {
  SetDirty();
  applylist_.Set(index, value);
}
inline void TeamInfo::add_applylist(::google::protobuf::uint64 value) {
  SetDirty();
  applylist_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
TeamInfo::applylist() const {
  return applylist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
TeamInfo::mutable_applylist() {
  SetDirty();
  return &applylist_;
}

// required .Packet.PurposeInfo purpose = 11;
inline bool TeamInfo::has_purpose() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TeamInfo::set_has_purpose() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TeamInfo::clear_has_purpose() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TeamInfo::clear_purpose() {
  if (purpose_ != NULL) purpose_->::Packet::PurposeInfo::Clear();
  clear_has_purpose();
  SetDirty();
}
inline const ::Packet::PurposeInfo& TeamInfo::purpose() const {
  return purpose_ != NULL ? *purpose_ : *default_instance_->purpose_;
}
inline ::Packet::PurposeInfo* TeamInfo::mutable_purpose() {
  SetDirty();
  set_has_purpose();
  if (purpose_ == NULL) purpose_ = new ::Packet::PurposeInfo;
  return purpose_;
}
inline ::Packet::PurposeInfo* TeamInfo::release_purpose() {
  SetDirty();
  clear_has_purpose();
  ::Packet::PurposeInfo* temp = purpose_;
  purpose_ = NULL;
  return temp;
}
inline void TeamInfo::set_allocated_purpose(::Packet::PurposeInfo* purpose) {
  SetDirty();
  delete purpose_;
  purpose_ = purpose;
  if (purpose) {
    set_has_purpose();
  } else {
    clear_has_purpose();
  }
}

// required bool setposition = 12;
inline bool TeamInfo::has_setposition() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TeamInfo::set_has_setposition() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TeamInfo::clear_has_setposition() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TeamInfo::clear_setposition() {
  setposition_ = false;
  clear_has_setposition();
  SetDirty();
}
inline bool TeamInfo::setposition() const {
  return setposition_;
}
inline void TeamInfo::set_setposition(bool value) {
  SetDirty();
  set_has_setposition();
  setposition_ = value;
}

// optional bool robot_team = 13;
inline bool TeamInfo::has_robot_team() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TeamInfo::set_has_robot_team() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TeamInfo::clear_has_robot_team() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TeamInfo::clear_robot_team() {
  robot_team_ = false;
  clear_has_robot_team();
  SetDirty();
}
inline bool TeamInfo::robot_team() const {
  return robot_team_;
}
inline void TeamInfo::set_robot_team(bool value) {
  SetDirty();
  set_has_robot_team();
  robot_team_ = value;
}

// -------------------------------------------------------------------

// CreateTeam

// -------------------------------------------------------------------

// CreateRobotTeam

// repeated .Packet.PlayerBasicInfo basic_info = 1;
inline int CreateRobotTeam::basic_info_size() const {
  return basic_info_.size();
}
inline void CreateRobotTeam::clear_basic_info() {
  basic_info_.Clear();
  SetDirty();
}
inline const ::Packet::PlayerBasicInfo& CreateRobotTeam::basic_info(int index) const {
  return basic_info_.Get(index);
}
inline ::Packet::PlayerBasicInfo* CreateRobotTeam::mutable_basic_info(int index) {
  SetDirty();
  return basic_info_.Mutable(index);
}
inline ::Packet::PlayerBasicInfo* CreateRobotTeam::add_basic_info() {
  SetDirty();
  return basic_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo >&
CreateRobotTeam::basic_info() const {
  return basic_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo >*
CreateRobotTeam::mutable_basic_info() {
  SetDirty();
  return &basic_info_;
}

// repeated int32 one_key_id = 2;
inline int CreateRobotTeam::one_key_id_size() const {
  return one_key_id_.size();
}
inline void CreateRobotTeam::clear_one_key_id() {
  one_key_id_.Clear();
  SetDirty();
}
inline ::google::protobuf::int32 CreateRobotTeam::one_key_id(int index) const {
  return one_key_id_.Get(index);
}
inline void CreateRobotTeam::set_one_key_id(int index, ::google::protobuf::int32 value) {
  SetDirty();
  one_key_id_.Set(index, value);
}
inline void CreateRobotTeam::add_one_key_id(::google::protobuf::int32 value) {
  SetDirty();
  one_key_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CreateRobotTeam::one_key_id() const {
  return one_key_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CreateRobotTeam::mutable_one_key_id() {
  SetDirty();
  return &one_key_id_;
}

// -------------------------------------------------------------------

// DelTeam

// -------------------------------------------------------------------

// ChangeTeamTypeReq

// required bool group = 1;
inline bool ChangeTeamTypeReq::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeTeamTypeReq::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeTeamTypeReq::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeTeamTypeReq::clear_group() {
  group_ = false;
  clear_has_group();
  SetDirty();
}
inline bool ChangeTeamTypeReq::group() const {
  return group_;
}
inline void ChangeTeamTypeReq::set_group(bool value) {
  SetDirty();
  set_has_group();
  group_ = value;
}

// -------------------------------------------------------------------

// UpdateTeamTypeReply

// required bool group = 1;
inline bool UpdateTeamTypeReply::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateTeamTypeReply::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateTeamTypeReply::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateTeamTypeReply::clear_group() {
  group_ = false;
  clear_has_group();
  SetDirty();
}
inline bool UpdateTeamTypeReply::group() const {
  return group_;
}
inline void UpdateTeamTypeReply::set_group(bool value) {
  SetDirty();
  set_has_group();
  group_ = value;
}

// -------------------------------------------------------------------

// ChangeTeamArrangeTypeReq

// required .Packet.ArrangeType type = 1;
inline bool ChangeTeamArrangeTypeReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeTeamArrangeTypeReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeTeamArrangeTypeReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeTeamArrangeTypeReq::clear_type() {
  type_ = -1;
  clear_has_type();
  SetDirty();
}
inline ::Packet::ArrangeType ChangeTeamArrangeTypeReq::type() const {
  return static_cast< ::Packet::ArrangeType >(type_);
}
inline void ChangeTeamArrangeTypeReq::set_type(::Packet::ArrangeType value) {
  assert(::Packet::ArrangeType_IsValid(value));
  SetDirty();
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// UpdateTeamArrangeTypeReply

// required .Packet.ArrangeType type = 1;
inline bool UpdateTeamArrangeTypeReply::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateTeamArrangeTypeReply::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateTeamArrangeTypeReply::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateTeamArrangeTypeReply::clear_type() {
  type_ = -1;
  clear_has_type();
  SetDirty();
}
inline ::Packet::ArrangeType UpdateTeamArrangeTypeReply::type() const {
  return static_cast< ::Packet::ArrangeType >(type_);
}
inline void UpdateTeamArrangeTypeReply::set_type(::Packet::ArrangeType value) {
  assert(::Packet::ArrangeType_IsValid(value));
  SetDirty();
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ApplyTeamReq

// required fixed64 guid = 1;
inline bool ApplyTeamReq::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyTeamReq::set_has_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyTeamReq::clear_has_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyTeamReq::clear_guid() {
  guid_ = GOOGLE_ULONGLONG(0);
  clear_has_guid();
  SetDirty();
}
inline ::google::protobuf::uint64 ApplyTeamReq::guid() const {
  return guid_;
}
inline void ApplyTeamReq::set_guid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_guid();
  guid_ = value;
}

// -------------------------------------------------------------------

// ApplyMissionTeamReq

// required fixed64 srcplayer_guid = 1;
inline bool ApplyMissionTeamReq::has_srcplayer_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyMissionTeamReq::set_has_srcplayer_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyMissionTeamReq::clear_has_srcplayer_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyMissionTeamReq::clear_srcplayer_guid() {
  srcplayer_guid_ = GOOGLE_ULONGLONG(0);
  clear_has_srcplayer_guid();
  SetDirty();
}
inline ::google::protobuf::uint64 ApplyMissionTeamReq::srcplayer_guid() const {
  return srcplayer_guid_;
}
inline void ApplyMissionTeamReq::set_srcplayer_guid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_srcplayer_guid();
  srcplayer_guid_ = value;
}

// required int32 missionid = 2;
inline bool ApplyMissionTeamReq::has_missionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyMissionTeamReq::set_has_missionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyMissionTeamReq::clear_has_missionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyMissionTeamReq::clear_missionid() {
  missionid_ = 0;
  clear_has_missionid();
  SetDirty();
}
inline ::google::protobuf::int32 ApplyMissionTeamReq::missionid() const {
  return missionid_;
}
inline void ApplyMissionTeamReq::set_missionid(::google::protobuf::int32 value) {
  SetDirty();
  set_has_missionid();
  missionid_ = value;
}

// -------------------------------------------------------------------

// LevelTeamReq

// -------------------------------------------------------------------

// AskLevelTeamReq

// required fixed64 playerguid = 1;
inline bool AskLevelTeamReq::has_playerguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AskLevelTeamReq::set_has_playerguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AskLevelTeamReq::clear_has_playerguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AskLevelTeamReq::clear_playerguid() {
  playerguid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerguid();
  SetDirty();
}
inline ::google::protobuf::uint64 AskLevelTeamReq::playerguid() const {
  return playerguid_;
}
inline void AskLevelTeamReq::set_playerguid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_playerguid();
  playerguid_ = value;
}

// -------------------------------------------------------------------

// AgreeApplyTeamReq

// required fixed64 playerguid = 1;
inline bool AgreeApplyTeamReq::has_playerguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgreeApplyTeamReq::set_has_playerguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgreeApplyTeamReq::clear_has_playerguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgreeApplyTeamReq::clear_playerguid() {
  playerguid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerguid();
  SetDirty();
}
inline ::google::protobuf::uint64 AgreeApplyTeamReq::playerguid() const {
  return playerguid_;
}
inline void AgreeApplyTeamReq::set_playerguid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_playerguid();
  playerguid_ = value;
}

// -------------------------------------------------------------------

// InviteyAddTeamReq

// required fixed64 playerguid = 1;
inline bool InviteyAddTeamReq::has_playerguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InviteyAddTeamReq::set_has_playerguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InviteyAddTeamReq::clear_has_playerguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InviteyAddTeamReq::clear_playerguid() {
  playerguid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerguid();
  SetDirty();
}
inline ::google::protobuf::uint64 InviteyAddTeamReq::playerguid() const {
  return playerguid_;
}
inline void InviteyAddTeamReq::set_playerguid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_playerguid();
  playerguid_ = value;
}

// -------------------------------------------------------------------

// AskInviteyAgreeTeamReply

// required fixed64 teamid = 1;
inline bool AskInviteyAgreeTeamReply::has_teamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AskInviteyAgreeTeamReply::set_has_teamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AskInviteyAgreeTeamReply::clear_has_teamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AskInviteyAgreeTeamReply::clear_teamid() {
  teamid_ = GOOGLE_ULONGLONG(0);
  clear_has_teamid();
  SetDirty();
}
inline ::google::protobuf::uint64 AskInviteyAgreeTeamReply::teamid() const {
  return teamid_;
}
inline void AskInviteyAgreeTeamReply::set_teamid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_teamid();
  teamid_ = value;
}

// required string teaminvitename = 2;
inline bool AskInviteyAgreeTeamReply::has_teaminvitename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AskInviteyAgreeTeamReply::set_has_teaminvitename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AskInviteyAgreeTeamReply::clear_has_teaminvitename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AskInviteyAgreeTeamReply::clear_teaminvitename() {
  if (teaminvitename_ != &::google::protobuf::internal::kEmptyString) {
    teaminvitename_->clear();
  }
  clear_has_teaminvitename();
  SetDirty();
}
inline const ::std::string& AskInviteyAgreeTeamReply::teaminvitename() const {
  return *teaminvitename_;
}
inline void AskInviteyAgreeTeamReply::set_teaminvitename(const ::std::string& value) {
  SetDirty();
  set_has_teaminvitename();
  if (teaminvitename_ == &::google::protobuf::internal::kEmptyString) {
    teaminvitename_ = new ::std::string;
  }
  teaminvitename_->assign(value);
}
inline void AskInviteyAgreeTeamReply::set_teaminvitename(const char* value) {
  SetDirty();
  set_has_teaminvitename();
  if (teaminvitename_ == &::google::protobuf::internal::kEmptyString) {
    teaminvitename_ = new ::std::string;
  }
  teaminvitename_->assign(value);
}
inline void AskInviteyAgreeTeamReply::set_teaminvitename(const char* value, size_t size) {
  SetDirty();
  set_has_teaminvitename();
  if (teaminvitename_ == &::google::protobuf::internal::kEmptyString) {
    teaminvitename_ = new ::std::string;
  }
  teaminvitename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AskInviteyAgreeTeamReply::mutable_teaminvitename() {
  SetDirty();
  set_has_teaminvitename();
  if (teaminvitename_ == &::google::protobuf::internal::kEmptyString) {
    teaminvitename_ = new ::std::string;
  }
  return teaminvitename_;
}
inline ::std::string* AskInviteyAgreeTeamReply::release_teaminvitename() {
  SetDirty();
  clear_has_teaminvitename();
  if (teaminvitename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = teaminvitename_;
    teaminvitename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AskInviteyAgreeTeamReply::set_allocated_teaminvitename(::std::string* teaminvitename) {
  SetDirty();
  if (teaminvitename_ != &::google::protobuf::internal::kEmptyString) {
    delete teaminvitename_;
  }
  if (teaminvitename) {
    set_has_teaminvitename();
    teaminvitename_ = teaminvitename;
  } else {
    clear_has_teaminvitename();
    teaminvitename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 teaminviteguid = 3;
inline bool AskInviteyAgreeTeamReply::has_teaminviteguid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AskInviteyAgreeTeamReply::set_has_teaminviteguid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AskInviteyAgreeTeamReply::clear_has_teaminviteguid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AskInviteyAgreeTeamReply::clear_teaminviteguid() {
  teaminviteguid_ = GOOGLE_ULONGLONG(0);
  clear_has_teaminviteguid();
  SetDirty();
}
inline ::google::protobuf::uint64 AskInviteyAgreeTeamReply::teaminviteguid() const {
  return teaminviteguid_;
}
inline void AskInviteyAgreeTeamReply::set_teaminviteguid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_teaminviteguid();
  teaminviteguid_ = value;
}

// required int32 purpose = 4;
inline bool AskInviteyAgreeTeamReply::has_purpose() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AskInviteyAgreeTeamReply::set_has_purpose() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AskInviteyAgreeTeamReply::clear_has_purpose() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AskInviteyAgreeTeamReply::clear_purpose() {
  purpose_ = 0;
  clear_has_purpose();
  SetDirty();
}
inline ::google::protobuf::int32 AskInviteyAgreeTeamReply::purpose() const {
  return purpose_;
}
inline void AskInviteyAgreeTeamReply::set_purpose(::google::protobuf::int32 value) {
  SetDirty();
  set_has_purpose();
  purpose_ = value;
}

// -------------------------------------------------------------------

// InviteyAgreeTeamReq

// required fixed64 teamid = 1;
inline bool InviteyAgreeTeamReq::has_teamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InviteyAgreeTeamReq::set_has_teamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InviteyAgreeTeamReq::clear_has_teamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InviteyAgreeTeamReq::clear_teamid() {
  teamid_ = GOOGLE_ULONGLONG(0);
  clear_has_teamid();
  SetDirty();
}
inline ::google::protobuf::uint64 InviteyAgreeTeamReq::teamid() const {
  return teamid_;
}
inline void InviteyAgreeTeamReq::set_teamid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_teamid();
  teamid_ = value;
}

// required bool agree = 2;
inline bool InviteyAgreeTeamReq::has_agree() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InviteyAgreeTeamReq::set_has_agree() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InviteyAgreeTeamReq::clear_has_agree() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InviteyAgreeTeamReq::clear_agree() {
  agree_ = false;
  clear_has_agree();
  SetDirty();
}
inline bool InviteyAgreeTeamReq::agree() const {
  return agree_;
}
inline void InviteyAgreeTeamReq::set_agree(bool value) {
  SetDirty();
  set_has_agree();
  agree_ = value;
}

// required fixed64 teaminviteguid = 3;
inline bool InviteyAgreeTeamReq::has_teaminviteguid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InviteyAgreeTeamReq::set_has_teaminviteguid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InviteyAgreeTeamReq::clear_has_teaminviteguid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InviteyAgreeTeamReq::clear_teaminviteguid() {
  teaminviteguid_ = GOOGLE_ULONGLONG(0);
  clear_has_teaminviteguid();
  SetDirty();
}
inline ::google::protobuf::uint64 InviteyAgreeTeamReq::teaminviteguid() const {
  return teaminviteguid_;
}
inline void InviteyAgreeTeamReq::set_teaminviteguid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_teaminviteguid();
  teaminviteguid_ = value;
}

// -------------------------------------------------------------------

// AddTeamReply

// required fixed64 playerguid = 1;
inline bool AddTeamReply::has_playerguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddTeamReply::set_has_playerguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddTeamReply::clear_has_playerguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddTeamReply::clear_playerguid() {
  playerguid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerguid();
  SetDirty();
}
inline ::google::protobuf::uint64 AddTeamReply::playerguid() const {
  return playerguid_;
}
inline void AddTeamReply::set_playerguid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_playerguid();
  playerguid_ = value;
}

// required string playername = 2;
inline bool AddTeamReply::has_playername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddTeamReply::set_has_playername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddTeamReply::clear_has_playername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddTeamReply::clear_playername() {
  if (playername_ != &::google::protobuf::internal::kEmptyString) {
    playername_->clear();
  }
  clear_has_playername();
  SetDirty();
}
inline const ::std::string& AddTeamReply::playername() const {
  return *playername_;
}
inline void AddTeamReply::set_playername(const ::std::string& value) {
  SetDirty();
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
}
inline void AddTeamReply::set_playername(const char* value) {
  SetDirty();
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
}
inline void AddTeamReply::set_playername(const char* value, size_t size) {
  SetDirty();
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddTeamReply::mutable_playername() {
  SetDirty();
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  return playername_;
}
inline ::std::string* AddTeamReply::release_playername() {
  SetDirty();
  clear_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playername_;
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddTeamReply::set_allocated_playername(::std::string* playername) {
  SetDirty();
  if (playername_ != &::google::protobuf::internal::kEmptyString) {
    delete playername_;
  }
  if (playername) {
    set_has_playername();
    playername_ = playername;
  } else {
    clear_has_playername();
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LeaveTeamReply

// required fixed64 playerguid = 1;
inline bool LeaveTeamReply::has_playerguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveTeamReply::set_has_playerguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveTeamReply::clear_has_playerguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveTeamReply::clear_playerguid() {
  playerguid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerguid();
  SetDirty();
}
inline ::google::protobuf::uint64 LeaveTeamReply::playerguid() const {
  return playerguid_;
}
inline void LeaveTeamReply::set_playerguid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_playerguid();
  playerguid_ = value;
}

// required string playername = 2;
inline bool LeaveTeamReply::has_playername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaveTeamReply::set_has_playername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaveTeamReply::clear_has_playername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaveTeamReply::clear_playername() {
  if (playername_ != &::google::protobuf::internal::kEmptyString) {
    playername_->clear();
  }
  clear_has_playername();
  SetDirty();
}
inline const ::std::string& LeaveTeamReply::playername() const {
  return *playername_;
}
inline void LeaveTeamReply::set_playername(const ::std::string& value) {
  SetDirty();
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
}
inline void LeaveTeamReply::set_playername(const char* value) {
  SetDirty();
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
}
inline void LeaveTeamReply::set_playername(const char* value, size_t size) {
  SetDirty();
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaveTeamReply::mutable_playername() {
  SetDirty();
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  return playername_;
}
inline ::std::string* LeaveTeamReply::release_playername() {
  SetDirty();
  clear_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playername_;
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LeaveTeamReply::set_allocated_playername(::std::string* playername) {
  SetDirty();
  if (playername_ != &::google::protobuf::internal::kEmptyString) {
    delete playername_;
  }
  if (playername) {
    set_has_playername();
    playername_ = playername;
  } else {
    clear_has_playername();
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SetPurposeInfoReq

// required .Packet.PurposeInfo purpose = 1;
inline bool SetPurposeInfoReq::has_purpose() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetPurposeInfoReq::set_has_purpose() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetPurposeInfoReq::clear_has_purpose() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetPurposeInfoReq::clear_purpose() {
  if (purpose_ != NULL) purpose_->::Packet::PurposeInfo::Clear();
  clear_has_purpose();
  SetDirty();
}
inline const ::Packet::PurposeInfo& SetPurposeInfoReq::purpose() const {
  return purpose_ != NULL ? *purpose_ : *default_instance_->purpose_;
}
inline ::Packet::PurposeInfo* SetPurposeInfoReq::mutable_purpose() {
  SetDirty();
  set_has_purpose();
  if (purpose_ == NULL) purpose_ = new ::Packet::PurposeInfo;
  return purpose_;
}
inline ::Packet::PurposeInfo* SetPurposeInfoReq::release_purpose() {
  SetDirty();
  clear_has_purpose();
  ::Packet::PurposeInfo* temp = purpose_;
  purpose_ = NULL;
  return temp;
}
inline void SetPurposeInfoReq::set_allocated_purpose(::Packet::PurposeInfo* purpose) {
  SetDirty();
  delete purpose_;
  purpose_ = purpose;
  if (purpose) {
    set_has_purpose();
  } else {
    clear_has_purpose();
  }
}

// -------------------------------------------------------------------

// PurposeInfoUpdate

// required .Packet.PurposeInfo purpose = 1;
inline bool PurposeInfoUpdate::has_purpose() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PurposeInfoUpdate::set_has_purpose() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PurposeInfoUpdate::clear_has_purpose() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PurposeInfoUpdate::clear_purpose() {
  if (purpose_ != NULL) purpose_->::Packet::PurposeInfo::Clear();
  clear_has_purpose();
  SetDirty();
}
inline const ::Packet::PurposeInfo& PurposeInfoUpdate::purpose() const {
  return purpose_ != NULL ? *purpose_ : *default_instance_->purpose_;
}
inline ::Packet::PurposeInfo* PurposeInfoUpdate::mutable_purpose() {
  SetDirty();
  set_has_purpose();
  if (purpose_ == NULL) purpose_ = new ::Packet::PurposeInfo;
  return purpose_;
}
inline ::Packet::PurposeInfo* PurposeInfoUpdate::release_purpose() {
  SetDirty();
  clear_has_purpose();
  ::Packet::PurposeInfo* temp = purpose_;
  purpose_ = NULL;
  return temp;
}
inline void PurposeInfoUpdate::set_allocated_purpose(::Packet::PurposeInfo* purpose) {
  SetDirty();
  delete purpose_;
  purpose_ = purpose;
  if (purpose) {
    set_has_purpose();
  } else {
    clear_has_purpose();
  }
}

// -------------------------------------------------------------------

// SetTeamAutoMatchReq

// required bool auto_match = 1;
inline bool SetTeamAutoMatchReq::has_auto_match() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetTeamAutoMatchReq::set_has_auto_match() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetTeamAutoMatchReq::clear_has_auto_match() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetTeamAutoMatchReq::clear_auto_match() {
  auto_match_ = false;
  clear_has_auto_match();
  SetDirty();
}
inline bool SetTeamAutoMatchReq::auto_match() const {
  return auto_match_;
}
inline void SetTeamAutoMatchReq::set_auto_match(bool value) {
  SetDirty();
  set_has_auto_match();
  auto_match_ = value;
}

// -------------------------------------------------------------------

// TeamAutoMatchUpdate

// required bool auto_match = 1;
inline bool TeamAutoMatchUpdate::has_auto_match() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamAutoMatchUpdate::set_has_auto_match() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamAutoMatchUpdate::clear_has_auto_match() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamAutoMatchUpdate::clear_auto_match() {
  auto_match_ = false;
  clear_has_auto_match();
  SetDirty();
}
inline bool TeamAutoMatchUpdate::auto_match() const {
  return auto_match_;
}
inline void TeamAutoMatchUpdate::set_auto_match(bool value) {
  SetDirty();
  set_has_auto_match();
  auto_match_ = value;
}

// -------------------------------------------------------------------

// TeamFullPlayerInfo

// optional .Packet.PlayerBasicInfo playerbase = 1;
inline bool TeamFullPlayerInfo::has_playerbase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamFullPlayerInfo::set_has_playerbase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamFullPlayerInfo::clear_has_playerbase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamFullPlayerInfo::clear_playerbase() {
  if (playerbase_ != NULL) playerbase_->::Packet::PlayerBasicInfo::Clear();
  clear_has_playerbase();
  SetDirty();
}
inline const ::Packet::PlayerBasicInfo& TeamFullPlayerInfo::playerbase() const {
  return playerbase_ != NULL ? *playerbase_ : *default_instance_->playerbase_;
}
inline ::Packet::PlayerBasicInfo* TeamFullPlayerInfo::mutable_playerbase() {
  SetDirty();
  set_has_playerbase();
  if (playerbase_ == NULL) playerbase_ = new ::Packet::PlayerBasicInfo;
  return playerbase_;
}
inline ::Packet::PlayerBasicInfo* TeamFullPlayerInfo::release_playerbase() {
  SetDirty();
  clear_has_playerbase();
  ::Packet::PlayerBasicInfo* temp = playerbase_;
  playerbase_ = NULL;
  return temp;
}
inline void TeamFullPlayerInfo::set_allocated_playerbase(::Packet::PlayerBasicInfo* playerbase) {
  SetDirty();
  delete playerbase_;
  playerbase_ = playerbase;
  if (playerbase) {
    set_has_playerbase();
  } else {
    clear_has_playerbase();
  }
}

// required .Packet.TeamPlayerBasicInfo teambaseinfo = 2;
inline bool TeamFullPlayerInfo::has_teambaseinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamFullPlayerInfo::set_has_teambaseinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamFullPlayerInfo::clear_has_teambaseinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamFullPlayerInfo::clear_teambaseinfo() {
  if (teambaseinfo_ != NULL) teambaseinfo_->::Packet::TeamPlayerBasicInfo::Clear();
  clear_has_teambaseinfo();
  SetDirty();
}
inline const ::Packet::TeamPlayerBasicInfo& TeamFullPlayerInfo::teambaseinfo() const {
  return teambaseinfo_ != NULL ? *teambaseinfo_ : *default_instance_->teambaseinfo_;
}
inline ::Packet::TeamPlayerBasicInfo* TeamFullPlayerInfo::mutable_teambaseinfo() {
  SetDirty();
  set_has_teambaseinfo();
  if (teambaseinfo_ == NULL) teambaseinfo_ = new ::Packet::TeamPlayerBasicInfo;
  return teambaseinfo_;
}
inline ::Packet::TeamPlayerBasicInfo* TeamFullPlayerInfo::release_teambaseinfo() {
  SetDirty();
  clear_has_teambaseinfo();
  ::Packet::TeamPlayerBasicInfo* temp = teambaseinfo_;
  teambaseinfo_ = NULL;
  return temp;
}
inline void TeamFullPlayerInfo::set_allocated_teambaseinfo(::Packet::TeamPlayerBasicInfo* teambaseinfo) {
  SetDirty();
  delete teambaseinfo_;
  teambaseinfo_ = teambaseinfo;
  if (teambaseinfo) {
    set_has_teambaseinfo();
  } else {
    clear_has_teambaseinfo();
  }
}

// -------------------------------------------------------------------

// TeamListInfo

// required fixed64 guid = 1;
inline bool TeamListInfo::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamListInfo::set_has_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamListInfo::clear_has_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamListInfo::clear_guid() {
  guid_ = GOOGLE_ULONGLONG(0);
  clear_has_guid();
  SetDirty();
}
inline ::google::protobuf::uint64 TeamListInfo::guid() const {
  return guid_;
}
inline void TeamListInfo::set_guid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_guid();
  guid_ = value;
}

// required int32 purpose = 2;
inline bool TeamListInfo::has_purpose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamListInfo::set_has_purpose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamListInfo::clear_has_purpose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamListInfo::clear_purpose() {
  purpose_ = 0;
  clear_has_purpose();
  SetDirty();
}
inline ::google::protobuf::int32 TeamListInfo::purpose() const {
  return purpose_;
}
inline void TeamListInfo::set_purpose(::google::protobuf::int32 value) {
  SetDirty();
  set_has_purpose();
  purpose_ = value;
}

// required int32 membersize = 3;
inline bool TeamListInfo::has_membersize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeamListInfo::set_has_membersize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeamListInfo::clear_has_membersize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeamListInfo::clear_membersize() {
  membersize_ = 0;
  clear_has_membersize();
  SetDirty();
}
inline ::google::protobuf::int32 TeamListInfo::membersize() const {
  return membersize_;
}
inline void TeamListInfo::set_membersize(::google::protobuf::int32 value) {
  SetDirty();
  set_has_membersize();
  membersize_ = value;
}

// required string leadername = 4;
inline bool TeamListInfo::has_leadername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TeamListInfo::set_has_leadername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TeamListInfo::clear_has_leadername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TeamListInfo::clear_leadername() {
  if (leadername_ != &::google::protobuf::internal::kEmptyString) {
    leadername_->clear();
  }
  clear_has_leadername();
  SetDirty();
}
inline const ::std::string& TeamListInfo::leadername() const {
  return *leadername_;
}
inline void TeamListInfo::set_leadername(const ::std::string& value) {
  SetDirty();
  set_has_leadername();
  if (leadername_ == &::google::protobuf::internal::kEmptyString) {
    leadername_ = new ::std::string;
  }
  leadername_->assign(value);
}
inline void TeamListInfo::set_leadername(const char* value) {
  SetDirty();
  set_has_leadername();
  if (leadername_ == &::google::protobuf::internal::kEmptyString) {
    leadername_ = new ::std::string;
  }
  leadername_->assign(value);
}
inline void TeamListInfo::set_leadername(const char* value, size_t size) {
  SetDirty();
  set_has_leadername();
  if (leadername_ == &::google::protobuf::internal::kEmptyString) {
    leadername_ = new ::std::string;
  }
  leadername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamListInfo::mutable_leadername() {
  SetDirty();
  set_has_leadername();
  if (leadername_ == &::google::protobuf::internal::kEmptyString) {
    leadername_ = new ::std::string;
  }
  return leadername_;
}
inline ::std::string* TeamListInfo::release_leadername() {
  SetDirty();
  clear_has_leadername();
  if (leadername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leadername_;
    leadername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamListInfo::set_allocated_leadername(::std::string* leadername) {
  SetDirty();
  if (leadername_ != &::google::protobuf::internal::kEmptyString) {
    delete leadername_;
  }
  if (leadername) {
    set_has_leadername();
    leadername_ = leadername;
  } else {
    clear_has_leadername();
    leadername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 leaderlevel = 5;
inline bool TeamListInfo::has_leaderlevel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TeamListInfo::set_has_leaderlevel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TeamListInfo::clear_has_leaderlevel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TeamListInfo::clear_leaderlevel() {
  leaderlevel_ = 0;
  clear_has_leaderlevel();
  SetDirty();
}
inline ::google::protobuf::int32 TeamListInfo::leaderlevel() const {
  return leaderlevel_;
}
inline void TeamListInfo::set_leaderlevel(::google::protobuf::int32 value) {
  SetDirty();
  set_has_leaderlevel();
  leaderlevel_ = value;
}

// required int32 init_actor_id = 6;
inline bool TeamListInfo::has_init_actor_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TeamListInfo::set_has_init_actor_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TeamListInfo::clear_has_init_actor_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TeamListInfo::clear_init_actor_id() {
  init_actor_id_ = 0;
  clear_has_init_actor_id();
  SetDirty();
}
inline ::google::protobuf::int32 TeamListInfo::init_actor_id() const {
  return init_actor_id_;
}
inline void TeamListInfo::set_init_actor_id(::google::protobuf::int32 value) {
  SetDirty();
  set_has_init_actor_id();
  init_actor_id_ = value;
}

// -------------------------------------------------------------------

// TeamInfoReq

// -------------------------------------------------------------------

// EmptyTeamReply

// -------------------------------------------------------------------

// TeamInfoReply

// required fixed64 guid = 1;
inline bool TeamInfoReply::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamInfoReply::set_has_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamInfoReply::clear_has_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamInfoReply::clear_guid() {
  guid_ = GOOGLE_ULONGLONG(0);
  clear_has_guid();
  SetDirty();
}
inline ::google::protobuf::uint64 TeamInfoReply::guid() const {
  return guid_;
}
inline void TeamInfoReply::set_guid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_guid();
  guid_ = value;
}

// repeated .Packet.TeamFullPlayerInfo member = 2;
inline int TeamInfoReply::member_size() const {
  return member_.size();
}
inline void TeamInfoReply::clear_member() {
  member_.Clear();
  SetDirty();
}
inline const ::Packet::TeamFullPlayerInfo& TeamInfoReply::member(int index) const {
  return member_.Get(index);
}
inline ::Packet::TeamFullPlayerInfo* TeamInfoReply::mutable_member(int index) {
  SetDirty();
  return member_.Mutable(index);
}
inline ::Packet::TeamFullPlayerInfo* TeamInfoReply::add_member() {
  SetDirty();
  return member_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Packet::TeamFullPlayerInfo >&
TeamInfoReply::member() const {
  return member_;
}
inline ::google::protobuf::RepeatedPtrField< ::Packet::TeamFullPlayerInfo >*
TeamInfoReply::mutable_member() {
  SetDirty();
  return &member_;
}

// required fixed64 leader = 3;
inline bool TeamInfoReply::has_leader() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeamInfoReply::set_has_leader() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeamInfoReply::clear_has_leader() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeamInfoReply::clear_leader() {
  leader_ = GOOGLE_ULONGLONG(0);
  clear_has_leader();
  SetDirty();
}
inline ::google::protobuf::uint64 TeamInfoReply::leader() const {
  return leader_;
}
inline void TeamInfoReply::set_leader(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_leader();
  leader_ = value;
}

// required bool group = 4;
inline bool TeamInfoReply::has_group() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TeamInfoReply::set_has_group() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TeamInfoReply::clear_has_group() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TeamInfoReply::clear_group() {
  group_ = false;
  clear_has_group();
  SetDirty();
}
inline bool TeamInfoReply::group() const {
  return group_;
}
inline void TeamInfoReply::set_group(bool value) {
  SetDirty();
  set_has_group();
  group_ = value;
}

// required .Packet.ArrangeType arrangetype = 5;
inline bool TeamInfoReply::has_arrangetype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TeamInfoReply::set_has_arrangetype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TeamInfoReply::clear_has_arrangetype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TeamInfoReply::clear_arrangetype() {
  arrangetype_ = -1;
  clear_has_arrangetype();
  SetDirty();
}
inline ::Packet::ArrangeType TeamInfoReply::arrangetype() const {
  return static_cast< ::Packet::ArrangeType >(arrangetype_);
}
inline void TeamInfoReply::set_arrangetype(::Packet::ArrangeType value) {
  assert(::Packet::ArrangeType_IsValid(value));
  SetDirty();
  set_has_arrangetype();
  arrangetype_ = value;
}

// required .Packet.PurposeInfo purpose = 6;
inline bool TeamInfoReply::has_purpose() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TeamInfoReply::set_has_purpose() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TeamInfoReply::clear_has_purpose() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TeamInfoReply::clear_purpose() {
  if (purpose_ != NULL) purpose_->::Packet::PurposeInfo::Clear();
  clear_has_purpose();
  SetDirty();
}
inline const ::Packet::PurposeInfo& TeamInfoReply::purpose() const {
  return purpose_ != NULL ? *purpose_ : *default_instance_->purpose_;
}
inline ::Packet::PurposeInfo* TeamInfoReply::mutable_purpose() {
  SetDirty();
  set_has_purpose();
  if (purpose_ == NULL) purpose_ = new ::Packet::PurposeInfo;
  return purpose_;
}
inline ::Packet::PurposeInfo* TeamInfoReply::release_purpose() {
  SetDirty();
  clear_has_purpose();
  ::Packet::PurposeInfo* temp = purpose_;
  purpose_ = NULL;
  return temp;
}
inline void TeamInfoReply::set_allocated_purpose(::Packet::PurposeInfo* purpose) {
  SetDirty();
  delete purpose_;
  purpose_ = purpose;
  if (purpose) {
    set_has_purpose();
  } else {
    clear_has_purpose();
  }
}

// required bool auto_match = 7;
inline bool TeamInfoReply::has_auto_match() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TeamInfoReply::set_has_auto_match() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TeamInfoReply::clear_has_auto_match() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TeamInfoReply::clear_auto_match() {
  auto_match_ = false;
  clear_has_auto_match();
  SetDirty();
}
inline bool TeamInfoReply::auto_match() const {
  return auto_match_;
}
inline void TeamInfoReply::set_auto_match(bool value) {
  SetDirty();
  set_has_auto_match();
  auto_match_ = value;
}

// repeated .Packet.PlayerBasicInfo applylist = 8;
inline int TeamInfoReply::applylist_size() const {
  return applylist_.size();
}
inline void TeamInfoReply::clear_applylist() {
  applylist_.Clear();
  SetDirty();
}
inline const ::Packet::PlayerBasicInfo& TeamInfoReply::applylist(int index) const {
  return applylist_.Get(index);
}
inline ::Packet::PlayerBasicInfo* TeamInfoReply::mutable_applylist(int index) {
  SetDirty();
  return applylist_.Mutable(index);
}
inline ::Packet::PlayerBasicInfo* TeamInfoReply::add_applylist() {
  SetDirty();
  return applylist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo >&
TeamInfoReply::applylist() const {
  return applylist_;
}
inline ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo >*
TeamInfoReply::mutable_applylist() {
  SetDirty();
  return &applylist_;
}

// -------------------------------------------------------------------

// FindTeamListReq

// -------------------------------------------------------------------

// TeamListReply

// repeated .Packet.TeamListInfo teams = 1;
inline int TeamListReply::teams_size() const {
  return teams_.size();
}
inline void TeamListReply::clear_teams() {
  teams_.Clear();
  SetDirty();
}
inline const ::Packet::TeamListInfo& TeamListReply::teams(int index) const {
  return teams_.Get(index);
}
inline ::Packet::TeamListInfo* TeamListReply::mutable_teams(int index) {
  SetDirty();
  return teams_.Mutable(index);
}
inline ::Packet::TeamListInfo* TeamListReply::add_teams() {
  SetDirty();
  return teams_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Packet::TeamListInfo >&
TeamListReply::teams() const {
  return teams_;
}
inline ::google::protobuf::RepeatedPtrField< ::Packet::TeamListInfo >*
TeamListReply::mutable_teams() {
  SetDirty();
  return &teams_;
}

// -------------------------------------------------------------------

// TeamApplyListReq

// -------------------------------------------------------------------

// TeamApplyListReply

// repeated .Packet.PlayerBasicInfo applylist = 1;
inline int TeamApplyListReply::applylist_size() const {
  return applylist_.size();
}
inline void TeamApplyListReply::clear_applylist() {
  applylist_.Clear();
  SetDirty();
}
inline const ::Packet::PlayerBasicInfo& TeamApplyListReply::applylist(int index) const {
  return applylist_.Get(index);
}
inline ::Packet::PlayerBasicInfo* TeamApplyListReply::mutable_applylist(int index) {
  SetDirty();
  return applylist_.Mutable(index);
}
inline ::Packet::PlayerBasicInfo* TeamApplyListReply::add_applylist() {
  SetDirty();
  return applylist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo >&
TeamApplyListReply::applylist() const {
  return applylist_;
}
inline ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo >*
TeamApplyListReply::mutable_applylist() {
  SetDirty();
  return &applylist_;
}

// -------------------------------------------------------------------

// PlayerAutoMatchInfo

// required fixed64 playerguid = 1;
inline bool PlayerAutoMatchInfo::has_playerguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerAutoMatchInfo::set_has_playerguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerAutoMatchInfo::clear_has_playerguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerAutoMatchInfo::clear_playerguid() {
  playerguid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerguid();
  SetDirty();
}
inline ::google::protobuf::uint64 PlayerAutoMatchInfo::playerguid() const {
  return playerguid_;
}
inline void PlayerAutoMatchInfo::set_playerguid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_playerguid();
  playerguid_ = value;
}

// required int32 purpose = 2;
inline bool PlayerAutoMatchInfo::has_purpose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerAutoMatchInfo::set_has_purpose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerAutoMatchInfo::clear_has_purpose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerAutoMatchInfo::clear_purpose() {
  purpose_ = 0;
  clear_has_purpose();
  SetDirty();
}
inline ::google::protobuf::int32 PlayerAutoMatchInfo::purpose() const {
  return purpose_;
}
inline void PlayerAutoMatchInfo::set_purpose(::google::protobuf::int32 value) {
  SetDirty();
  set_has_purpose();
  purpose_ = value;
}

// required int32 level = 3;
inline bool PlayerAutoMatchInfo::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerAutoMatchInfo::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerAutoMatchInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerAutoMatchInfo::clear_level() {
  level_ = 0;
  clear_has_level();
  SetDirty();
}
inline ::google::protobuf::int32 PlayerAutoMatchInfo::level() const {
  return level_;
}
inline void PlayerAutoMatchInfo::set_level(::google::protobuf::int32 value) {
  SetDirty();
  set_has_level();
  level_ = value;
}

// required int32 hero_position = 4;
inline bool PlayerAutoMatchInfo::has_hero_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerAutoMatchInfo::set_has_hero_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerAutoMatchInfo::clear_has_hero_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerAutoMatchInfo::clear_hero_position() {
  hero_position_ = 0;
  clear_has_hero_position();
  SetDirty();
}
inline ::google::protobuf::int32 PlayerAutoMatchInfo::hero_position() const {
  return hero_position_;
}
inline void PlayerAutoMatchInfo::set_hero_position(::google::protobuf::int32 value) {
  SetDirty();
  set_has_hero_position();
  hero_position_ = value;
}

// -------------------------------------------------------------------

// PlayerAutoMatchReq

// required bool auto_match = 1;
inline bool PlayerAutoMatchReq::has_auto_match() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerAutoMatchReq::set_has_auto_match() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerAutoMatchReq::clear_has_auto_match() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerAutoMatchReq::clear_auto_match() {
  auto_match_ = false;
  clear_has_auto_match();
  SetDirty();
}
inline bool PlayerAutoMatchReq::auto_match() const {
  return auto_match_;
}
inline void PlayerAutoMatchReq::set_auto_match(bool value) {
  SetDirty();
  set_has_auto_match();
  auto_match_ = value;
}

// required int32 purpose = 2;
inline bool PlayerAutoMatchReq::has_purpose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerAutoMatchReq::set_has_purpose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerAutoMatchReq::clear_has_purpose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerAutoMatchReq::clear_purpose() {
  purpose_ = 0;
  clear_has_purpose();
  SetDirty();
}
inline ::google::protobuf::int32 PlayerAutoMatchReq::purpose() const {
  return purpose_;
}
inline void PlayerAutoMatchReq::set_purpose(::google::protobuf::int32 value) {
  SetDirty();
  set_has_purpose();
  purpose_ = value;
}

// -------------------------------------------------------------------

// PlayerAutoMatchReply

// required bool auto_match = 1;
inline bool PlayerAutoMatchReply::has_auto_match() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerAutoMatchReply::set_has_auto_match() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerAutoMatchReply::clear_has_auto_match() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerAutoMatchReply::clear_auto_match() {
  auto_match_ = false;
  clear_has_auto_match();
  SetDirty();
}
inline bool PlayerAutoMatchReply::auto_match() const {
  return auto_match_;
}
inline void PlayerAutoMatchReply::set_auto_match(bool value) {
  SetDirty();
  set_has_auto_match();
  auto_match_ = value;
}

// optional int32 purpose = 2;
inline bool PlayerAutoMatchReply::has_purpose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerAutoMatchReply::set_has_purpose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerAutoMatchReply::clear_has_purpose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerAutoMatchReply::clear_purpose() {
  purpose_ = 0;
  clear_has_purpose();
  SetDirty();
}
inline ::google::protobuf::int32 PlayerAutoMatchReply::purpose() const {
  return purpose_;
}
inline void PlayerAutoMatchReply::set_purpose(::google::protobuf::int32 value) {
  SetDirty();
  set_has_purpose();
  purpose_ = value;
}

// -------------------------------------------------------------------

// PlayerSetTeamStatusReq

// required .Packet.PlayerTeamStatus status = 1;
inline bool PlayerSetTeamStatusReq::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerSetTeamStatusReq::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerSetTeamStatusReq::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerSetTeamStatusReq::clear_status() {
  status_ = 0;
  clear_has_status();
  SetDirty();
}
inline ::Packet::PlayerTeamStatus PlayerSetTeamStatusReq::status() const {
  return static_cast< ::Packet::PlayerTeamStatus >(status_);
}
inline void PlayerSetTeamStatusReq::set_status(::Packet::PlayerTeamStatus value) {
  assert(::Packet::PlayerTeamStatus_IsValid(value));
  SetDirty();
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// TeamPlayerBasicUpdate

// required .Packet.TeamFullPlayerInfo playerinfo = 1;
inline bool TeamPlayerBasicUpdate::has_playerinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamPlayerBasicUpdate::set_has_playerinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamPlayerBasicUpdate::clear_has_playerinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamPlayerBasicUpdate::clear_playerinfo() {
  if (playerinfo_ != NULL) playerinfo_->::Packet::TeamFullPlayerInfo::Clear();
  clear_has_playerinfo();
  SetDirty();
}
inline const ::Packet::TeamFullPlayerInfo& TeamPlayerBasicUpdate::playerinfo() const {
  return playerinfo_ != NULL ? *playerinfo_ : *default_instance_->playerinfo_;
}
inline ::Packet::TeamFullPlayerInfo* TeamPlayerBasicUpdate::mutable_playerinfo() {
  SetDirty();
  set_has_playerinfo();
  if (playerinfo_ == NULL) playerinfo_ = new ::Packet::TeamFullPlayerInfo;
  return playerinfo_;
}
inline ::Packet::TeamFullPlayerInfo* TeamPlayerBasicUpdate::release_playerinfo() {
  SetDirty();
  clear_has_playerinfo();
  ::Packet::TeamFullPlayerInfo* temp = playerinfo_;
  playerinfo_ = NULL;
  return temp;
}
inline void TeamPlayerBasicUpdate::set_allocated_playerinfo(::Packet::TeamFullPlayerInfo* playerinfo) {
  SetDirty();
  delete playerinfo_;
  playerinfo_ = playerinfo;
  if (playerinfo) {
    set_has_playerinfo();
  } else {
    clear_has_playerinfo();
  }
}

// -------------------------------------------------------------------

// SetTeamLeaderReq

// required fixed64 playerguid = 1;
inline bool SetTeamLeaderReq::has_playerguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetTeamLeaderReq::set_has_playerguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetTeamLeaderReq::clear_has_playerguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetTeamLeaderReq::clear_playerguid() {
  playerguid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerguid();
  SetDirty();
}
inline ::google::protobuf::uint64 SetTeamLeaderReq::playerguid() const {
  return playerguid_;
}
inline void SetTeamLeaderReq::set_playerguid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_playerguid();
  playerguid_ = value;
}

// -------------------------------------------------------------------

// ApplyTeamLeaderReq

// -------------------------------------------------------------------

// AskApplyTeamLeaderReq

// required fixed64 playerguid = 1;
inline bool AskApplyTeamLeaderReq::has_playerguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AskApplyTeamLeaderReq::set_has_playerguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AskApplyTeamLeaderReq::clear_has_playerguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AskApplyTeamLeaderReq::clear_playerguid() {
  playerguid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerguid();
  SetDirty();
}
inline ::google::protobuf::uint64 AskApplyTeamLeaderReq::playerguid() const {
  return playerguid_;
}
inline void AskApplyTeamLeaderReq::set_playerguid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_playerguid();
  playerguid_ = value;
}

// -------------------------------------------------------------------

// AskApplyTeamLeaderReply

// required bool agree = 1;
inline bool AskApplyTeamLeaderReply::has_agree() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AskApplyTeamLeaderReply::set_has_agree() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AskApplyTeamLeaderReply::clear_has_agree() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AskApplyTeamLeaderReply::clear_agree() {
  agree_ = false;
  clear_has_agree();
  SetDirty();
}
inline bool AskApplyTeamLeaderReply::agree() const {
  return agree_;
}
inline void AskApplyTeamLeaderReply::set_agree(bool value) {
  SetDirty();
  set_has_agree();
  agree_ = value;
}

// -------------------------------------------------------------------

// TeamLeaderUpdate

// required fixed64 playerguid = 1;
inline bool TeamLeaderUpdate::has_playerguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamLeaderUpdate::set_has_playerguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamLeaderUpdate::clear_has_playerguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamLeaderUpdate::clear_playerguid() {
  playerguid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerguid();
  SetDirty();
}
inline ::google::protobuf::uint64 TeamLeaderUpdate::playerguid() const {
  return playerguid_;
}
inline void TeamLeaderUpdate::set_playerguid(::google::protobuf::uint64 value) {
  SetDirty();
  set_has_playerguid();
  playerguid_ = value;
}

// required string playername = 2;
inline bool TeamLeaderUpdate::has_playername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamLeaderUpdate::set_has_playername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamLeaderUpdate::clear_has_playername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamLeaderUpdate::clear_playername() {
  if (playername_ != &::google::protobuf::internal::kEmptyString) {
    playername_->clear();
  }
  clear_has_playername();
  SetDirty();
}
inline const ::std::string& TeamLeaderUpdate::playername() const {
  return *playername_;
}
inline void TeamLeaderUpdate::set_playername(const ::std::string& value) {
  SetDirty();
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
}
inline void TeamLeaderUpdate::set_playername(const char* value) {
  SetDirty();
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
}
inline void TeamLeaderUpdate::set_playername(const char* value, size_t size) {
  SetDirty();
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamLeaderUpdate::mutable_playername() {
  SetDirty();
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  return playername_;
}
inline ::std::string* TeamLeaderUpdate::release_playername() {
  SetDirty();
  clear_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playername_;
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamLeaderUpdate::set_allocated_playername(::std::string* playername) {
  SetDirty();
  if (playername_ != &::google::protobuf::internal::kEmptyString) {
    delete playername_;
  }
  if (playername) {
    set_has_playername();
    playername_ = playername;
  } else {
    clear_has_playername();
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 move_speed = 3;
inline bool TeamLeaderUpdate::has_move_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeamLeaderUpdate::set_has_move_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeamLeaderUpdate::clear_has_move_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeamLeaderUpdate::clear_move_speed() {
  move_speed_ = 0u;
  clear_has_move_speed();
  SetDirty();
}
inline ::google::protobuf::uint32 TeamLeaderUpdate::move_speed() const {
  return move_speed_;
}
inline void TeamLeaderUpdate::set_move_speed(::google::protobuf::uint32 value) {
  SetDirty();
  set_has_move_speed();
  move_speed_ = value;
}

// required bool charge = 4;
inline bool TeamLeaderUpdate::has_charge() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TeamLeaderUpdate::set_has_charge() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TeamLeaderUpdate::clear_has_charge() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TeamLeaderUpdate::clear_charge() {
  charge_ = false;
  clear_has_charge();
  SetDirty();
}
inline bool TeamLeaderUpdate::charge() const {
  return charge_;
}
inline void TeamLeaderUpdate::set_charge(bool value) {
  SetDirty();
  set_has_charge();
  charge_ = value;
}

// -------------------------------------------------------------------

// RobotPlayerInOk

// repeated .Packet.PlayerBasicInfo basic_info = 1;
inline int RobotPlayerInOk::basic_info_size() const {
  return basic_info_.size();
}
inline void RobotPlayerInOk::clear_basic_info() {
  basic_info_.Clear();
  SetDirty();
}
inline const ::Packet::PlayerBasicInfo& RobotPlayerInOk::basic_info(int index) const {
  return basic_info_.Get(index);
}
inline ::Packet::PlayerBasicInfo* RobotPlayerInOk::mutable_basic_info(int index) {
  SetDirty();
  return basic_info_.Mutable(index);
}
inline ::Packet::PlayerBasicInfo* RobotPlayerInOk::add_basic_info() {
  SetDirty();
  return basic_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo >&
RobotPlayerInOk::basic_info() const {
  return basic_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::Packet::PlayerBasicInfo >*
RobotPlayerInOk::mutable_basic_info() {
  SetDirty();
  return &basic_info_;
}

// repeated int32 one_key_id = 2;
inline int RobotPlayerInOk::one_key_id_size() const {
  return one_key_id_.size();
}
inline void RobotPlayerInOk::clear_one_key_id() {
  one_key_id_.Clear();
  SetDirty();
}
inline ::google::protobuf::int32 RobotPlayerInOk::one_key_id(int index) const {
  return one_key_id_.Get(index);
}
inline void RobotPlayerInOk::set_one_key_id(int index, ::google::protobuf::int32 value) {
  SetDirty();
  one_key_id_.Set(index, value);
}
inline void RobotPlayerInOk::add_one_key_id(::google::protobuf::int32 value) {
  SetDirty();
  one_key_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RobotPlayerInOk::one_key_id() const {
  return one_key_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RobotPlayerInOk::mutable_one_key_id() {
  SetDirty();
  return &one_key_id_;
}

// -------------------------------------------------------------------

// TeamAutomatchConfig

// required int32 id = 1;
inline bool TeamAutomatchConfig::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamAutomatchConfig::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamAutomatchConfig::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamAutomatchConfig::clear_id() {
  id_ = 0;
  clear_has_id();
  SetDirty();
}
inline ::google::protobuf::int32 TeamAutomatchConfig::id() const {
  return id_;
}
inline void TeamAutomatchConfig::set_id(::google::protobuf::int32 value) {
  SetDirty();
  set_has_id();
  id_ = value;
}

// required int32 group = 2;
inline bool TeamAutomatchConfig::has_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamAutomatchConfig::set_has_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamAutomatchConfig::clear_has_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamAutomatchConfig::clear_group() {
  group_ = 0;
  clear_has_group();
  SetDirty();
}
inline ::google::protobuf::int32 TeamAutomatchConfig::group() const {
  return group_;
}
inline void TeamAutomatchConfig::set_group(::google::protobuf::int32 value) {
  SetDirty();
  set_has_group();
  group_ = value;
}

// required int32 defence_count = 3;
inline bool TeamAutomatchConfig::has_defence_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeamAutomatchConfig::set_has_defence_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeamAutomatchConfig::clear_has_defence_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeamAutomatchConfig::clear_defence_count() {
  defence_count_ = 0;
  clear_has_defence_count();
  SetDirty();
}
inline ::google::protobuf::int32 TeamAutomatchConfig::defence_count() const {
  return defence_count_;
}
inline void TeamAutomatchConfig::set_defence_count(::google::protobuf::int32 value) {
  SetDirty();
  set_has_defence_count();
  defence_count_ = value;
}

// required int32 cure_count = 4;
inline bool TeamAutomatchConfig::has_cure_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TeamAutomatchConfig::set_has_cure_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TeamAutomatchConfig::clear_has_cure_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TeamAutomatchConfig::clear_cure_count() {
  cure_count_ = 0;
  clear_has_cure_count();
  SetDirty();
}
inline ::google::protobuf::int32 TeamAutomatchConfig::cure_count() const {
  return cure_count_;
}
inline void TeamAutomatchConfig::set_cure_count(::google::protobuf::int32 value) {
  SetDirty();
  set_has_cure_count();
  cure_count_ = value;
}

// required int32 attack_count = 5;
inline bool TeamAutomatchConfig::has_attack_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TeamAutomatchConfig::set_has_attack_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TeamAutomatchConfig::clear_has_attack_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TeamAutomatchConfig::clear_attack_count() {
  attack_count_ = 0;
  clear_has_attack_count();
  SetDirty();
}
inline ::google::protobuf::int32 TeamAutomatchConfig::attack_count() const {
  return attack_count_;
}
inline void TeamAutomatchConfig::set_attack_count(::google::protobuf::int32 value) {
  SetDirty();
  set_has_attack_count();
  attack_count_ = value;
}

// required int32 need_defence_count = 6;
inline bool TeamAutomatchConfig::has_need_defence_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TeamAutomatchConfig::set_has_need_defence_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TeamAutomatchConfig::clear_has_need_defence_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TeamAutomatchConfig::clear_need_defence_count() {
  need_defence_count_ = 0;
  clear_has_need_defence_count();
  SetDirty();
}
inline ::google::protobuf::int32 TeamAutomatchConfig::need_defence_count() const {
  return need_defence_count_;
}
inline void TeamAutomatchConfig::set_need_defence_count(::google::protobuf::int32 value) {
  SetDirty();
  set_has_need_defence_count();
  need_defence_count_ = value;
}

// required int32 need_cure_count = 7;
inline bool TeamAutomatchConfig::has_need_cure_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TeamAutomatchConfig::set_has_need_cure_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TeamAutomatchConfig::clear_has_need_cure_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TeamAutomatchConfig::clear_need_cure_count() {
  need_cure_count_ = 0;
  clear_has_need_cure_count();
  SetDirty();
}
inline ::google::protobuf::int32 TeamAutomatchConfig::need_cure_count() const {
  return need_cure_count_;
}
inline void TeamAutomatchConfig::set_need_cure_count(::google::protobuf::int32 value) {
  SetDirty();
  set_has_need_cure_count();
  need_cure_count_ = value;
}

// required int32 need_attack_count = 8;
inline bool TeamAutomatchConfig::has_need_attack_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TeamAutomatchConfig::set_has_need_attack_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TeamAutomatchConfig::clear_has_need_attack_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TeamAutomatchConfig::clear_need_attack_count() {
  need_attack_count_ = 0;
  clear_has_need_attack_count();
  SetDirty();
}
inline ::google::protobuf::int32 TeamAutomatchConfig::need_attack_count() const {
  return need_attack_count_;
}
inline void TeamAutomatchConfig::set_need_attack_count(::google::protobuf::int32 value) {
  SetDirty();
  set_has_need_attack_count();
  need_attack_count_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Packet

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Team_2eproto__INCLUDED
