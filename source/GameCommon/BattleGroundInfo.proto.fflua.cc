// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BattleGroundInfo.proto
#include "BattleGroundInfo.pb.h"
#include "BattleGroundInfo.proto.fflua.h"
namespace Packet {
bool PlayerStartHook_fflua_reg(lua_State* state)
{
//for decltype
	PlayerStartHook* message(nullptr);
	message;
	ff::fflua_register_t<PlayerStartHook, ctor()>(state, "PlayerStartHook", "google::protobuf::Message")
		// required int32 stage_id = 1;
		.def(&PlayerStartHook::stage_id, "stage_id")
		.def(&PlayerStartHook::set_stage_id, "set_stage_id")
		// required int32 battle_group_id = 2;
		.def(&PlayerStartHook::battle_group_id, "battle_group_id")
		.def(&PlayerStartHook::set_battle_group_id, "set_battle_group_id")
		.def(&PlayerStartHook::ByteSize, "ByteSize")
		.def(&PlayerStartHook::SetInitialized, "SetInitialized")
		;
	return true;
}
bool PlayerEndHook_fflua_reg(lua_State* state)
{
//for decltype
	PlayerEndHook* message(nullptr);
	message;
	ff::fflua_register_t<PlayerEndHook, ctor()>(state, "PlayerEndHook", "google::protobuf::Message");
	return true;
}
bool ChangeHookInfo_fflua_reg(lua_State* state)
{
//for decltype
	ChangeHookInfo* message(nullptr);
	message;
	ff::fflua_register_t<ChangeHookInfo, ctor()>(state, "ChangeHookInfo", "google::protobuf::Message")
		// required .Packet.HookOption hook_option = 1;
		.def(&ChangeHookInfo::hook_option, "hook_option")
		.def(&ChangeHookInfo::mutable_hook_option, "mutable_hook_option")
		.def(&ChangeHookInfo::ByteSize, "ByteSize")
		.def(&ChangeHookInfo::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ChallengeBossReq_fflua_reg(lua_State* state)
{
//for decltype
	ChallengeBossReq* message(nullptr);
	message;
	ff::fflua_register_t<ChallengeBossReq, ctor()>(state, "ChallengeBossReq", "google::protobuf::Message")
		// required int32 scene_stage_id = 1;
		.def(&ChallengeBossReq::scene_stage_id, "scene_stage_id")
		.def(&ChallengeBossReq::set_scene_stage_id, "set_scene_stage_id")
		// required bool rush = 2;
		.def(&ChallengeBossReq::rush, "rush")
		.def(&ChallengeBossReq::set_rush, "set_rush")
		// optional int32 rush_count = 3;
		.def(&ChallengeBossReq::rush_count, "rush_count")
		.def(&ChallengeBossReq::set_rush_count, "set_rush_count")
		.def(&ChallengeBossReq::has_rush_count, "has_rush_count")
		// optional int32 battle_group_id = 4;
		.def(&ChallengeBossReq::battle_group_id, "battle_group_id")
		.def(&ChallengeBossReq::set_battle_group_id, "set_battle_group_id")
		.def(&ChallengeBossReq::has_battle_group_id, "has_battle_group_id")
		.def(&ChallengeBossReq::ByteSize, "ByteSize")
		.def(&ChallengeBossReq::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ConstantChallengeBoss_fflua_reg(lua_State* state)
{
//for decltype
	ConstantChallengeBoss* message(nullptr);
	message;
	ff::fflua_register_t<ConstantChallengeBoss, ctor()>(state, "ConstantChallengeBoss", "google::protobuf::Message")
		// required bool status = 1;
		.def(&ConstantChallengeBoss::status, "status")
		.def(&ConstantChallengeBoss::set_status, "set_status")
		// required int32 stage_id = 2;
		.def(&ConstantChallengeBoss::stage_id, "stage_id")
		.def(&ConstantChallengeBoss::set_stage_id, "set_stage_id")
		.def(&ConstantChallengeBoss::ByteSize, "ByteSize")
		.def(&ConstantChallengeBoss::SetInitialized, "SetInitialized")
		;
	return true;
}
bool CancleChallengeBoss_fflua_reg(lua_State* state)
{
//for decltype
	CancleChallengeBoss* message(nullptr);
	message;
	ff::fflua_register_t<CancleChallengeBoss, ctor()>(state, "CancleChallengeBoss", "google::protobuf::Message")
		// required int32 stage_id = 1;
		.def(&CancleChallengeBoss::stage_id, "stage_id")
		.def(&CancleChallengeBoss::set_stage_id, "set_stage_id")
		.def(&CancleChallengeBoss::ByteSize, "ByteSize")
		.def(&CancleChallengeBoss::SetInitialized, "SetInitialized")
		;
	return true;
}
bool RushRewardNotify_fflua_reg(lua_State* state)
{
//for decltype
	RushRewardNotify* message(nullptr);
	message;
	ff::fflua_register_t<RushRewardNotify, ctor()>(state, "RushRewardNotify", "google::protobuf::Message")
		// repeated .Packet.NotifyItemList list = 1;
		.def(&RushRewardNotify::list_size, "list_size")
		.def<decltype(message->list(0)) (RushRewardNotify::*)(int) const>(&RushRewardNotify::list, "list")
		.def<decltype(message->mutable_list(0)) (RushRewardNotify::*)(int)>(&RushRewardNotify::mutable_list, "mutable_list")
		.def(&RushRewardNotify::add_list, "add_list")
		.def(&RushRewardNotify::ByteSize, "ByteSize")
		.def(&RushRewardNotify::SetInitialized, "SetInitialized")
		;
	return true;
}
bool EnterBattleGroundReply_fflua_reg(lua_State* state)
{
//for decltype
	EnterBattleGroundReply* message(nullptr);
	message;
	ff::fflua_register_t<EnterBattleGroundReply, ctor()>(state, "EnterBattleGroundReply", "google::protobuf::Message")
		// optional .Packet.BattleGroundBrief brief = 1;
		.def(&EnterBattleGroundReply::brief, "brief")
		.def(&EnterBattleGroundReply::mutable_brief, "mutable_brief")
		.def(&EnterBattleGroundReply::has_brief, "has_brief")
		// optional .Packet.BattleGroundInfo info = 2;
		.def(&EnterBattleGroundReply::info, "info")
		.def(&EnterBattleGroundReply::mutable_info, "mutable_info")
		.def(&EnterBattleGroundReply::has_info, "has_info")
		.def(&EnterBattleGroundReply::ByteSize, "ByteSize")
		.def(&EnterBattleGroundReply::SetInitialized, "SetInitialized")
		;
	return true;
}
bool PlayerReachBattlePos_fflua_reg(lua_State* state)
{
//for decltype
	PlayerReachBattlePos* message(nullptr);
	message;
	ff::fflua_register_t<PlayerReachBattlePos, ctor()>(state, "PlayerReachBattlePos", "google::protobuf::Message")
		// required fixed64 battle_ground_guid = 1;
		.def(&PlayerReachBattlePos::battle_ground_guid, "battle_ground_guid")
		.def(&PlayerReachBattlePos::set_battle_ground_guid, "set_battle_ground_guid")
		// repeated fixed64 guids = 2;
		.def(&PlayerReachBattlePos::guids_size, "guids_size")
		.def<decltype(message->guids(0)) (PlayerReachBattlePos::*)(int) const>(&PlayerReachBattlePos::guids, "guids")
		.def<void(PlayerReachBattlePos::*)(int, const decltype(message->guids(0)))>(&PlayerReachBattlePos::set_guids, "set_guids")
		.def(&PlayerReachBattlePos::add_guids, "add_guids")
		// repeated .Packet.Position positions = 3;
		.def(&PlayerReachBattlePos::positions_size, "positions_size")
		.def<decltype(message->positions(0)) (PlayerReachBattlePos::*)(int) const>(&PlayerReachBattlePos::positions, "positions")
		.def<decltype(message->mutable_positions(0)) (PlayerReachBattlePos::*)(int)>(&PlayerReachBattlePos::mutable_positions, "mutable_positions")
		.def(&PlayerReachBattlePos::add_positions, "add_positions")
		.def(&PlayerReachBattlePos::ByteSize, "ByteSize")
		.def(&PlayerReachBattlePos::SetInitialized, "SetInitialized")
		;
	return true;
}
bool BattleGroundOverNotify_fflua_reg(lua_State* state)
{
//for decltype
	BattleGroundOverNotify* message(nullptr);
	message;
	ff::fflua_register_t<BattleGroundOverNotify, ctor()>(state, "BattleGroundOverNotify", "google::protobuf::Message")
		// required .Packet.BattleGroundBrief brief = 1;
		.def(&BattleGroundOverNotify::brief, "brief")
		.def(&BattleGroundOverNotify::mutable_brief, "mutable_brief")
		// required int32 winner_camp = 2;
		.def(&BattleGroundOverNotify::winner_camp, "winner_camp")
		.def(&BattleGroundOverNotify::set_winner_camp, "set_winner_camp")
		// required fixed64 time_stamp = 3;
		.def(&BattleGroundOverNotify::time_stamp, "time_stamp")
		.def(&BattleGroundOverNotify::set_time_stamp, "set_time_stamp")
		// optional fixed64 wait_millsec = 4;
		.def(&BattleGroundOverNotify::wait_millsec, "wait_millsec")
		.def(&BattleGroundOverNotify::set_wait_millsec, "set_wait_millsec")
		.def(&BattleGroundOverNotify::has_wait_millsec, "has_wait_millsec")
		.def(&BattleGroundOverNotify::ByteSize, "ByteSize")
		.def(&BattleGroundOverNotify::SetInitialized, "SetInitialized")
		;
	return true;
}
bool BattleStartNotify_fflua_reg(lua_State* state)
{
//for decltype
	BattleStartNotify* message(nullptr);
	message;
	ff::fflua_register_t<BattleStartNotify, ctor()>(state, "BattleStartNotify", "google::protobuf::Message")
		// required .Packet.BattleGroundBrief brief = 1;
		.def(&BattleStartNotify::brief, "brief")
		.def(&BattleStartNotify::mutable_brief, "mutable_brief")
		.def(&BattleStartNotify::ByteSize, "ByteSize")
		.def(&BattleStartNotify::SetInitialized, "SetInitialized")
		;
	return true;
}
bool RefreshBattleGround_fflua_reg(lua_State* state)
{
//for decltype
	RefreshBattleGround* message(nullptr);
	message;
	ff::fflua_register_t<RefreshBattleGround, ctor()>(state, "RefreshBattleGround", "google::protobuf::Message")
		// required .Packet.BattleGroundBrief brief = 1;
		.def(&RefreshBattleGround::brief, "brief")
		.def(&RefreshBattleGround::mutable_brief, "mutable_brief")
		// required .Packet.BattleGroundInfo new_info = 2;
		.def(&RefreshBattleGround::new_info, "new_info")
		.def(&RefreshBattleGround::mutable_new_info, "mutable_new_info")
		// required fixed64 time_stamp = 3;
		.def(&RefreshBattleGround::time_stamp, "time_stamp")
		.def(&RefreshBattleGround::set_time_stamp, "set_time_stamp")
		.def(&RefreshBattleGround::ByteSize, "ByteSize")
		.def(&RefreshBattleGround::SetInitialized, "SetInitialized")
		;
	return true;
}
bool BattleGroundBrief_fflua_reg(lua_State* state)
{
//for decltype
	BattleGroundBrief* message(nullptr);
	message;
	ff::fflua_register_t<BattleGroundBrief, ctor()>(state, "BattleGroundBrief", "google::protobuf::Message")
		// required fixed64 guid = 1;
		.def(&BattleGroundBrief::guid, "guid")
		.def(&BattleGroundBrief::set_guid, "set_guid")
		// required .Packet.BattleGroundType type = 2;
		.def(&BattleGroundBrief::type, "type")
		.def(&BattleGroundBrief::set_type, "set_type")
		// required fixed64 elapse_time = 3;
		.def(&BattleGroundBrief::elapse_time, "elapse_time")
		.def(&BattleGroundBrief::set_elapse_time, "set_elapse_time")
		// required int32 scene_id = 4;
		.def(&BattleGroundBrief::scene_id, "scene_id")
		.def(&BattleGroundBrief::set_scene_id, "set_scene_id")
		// optional int32 stage_id = 5;
		.def(&BattleGroundBrief::stage_id, "stage_id")
		.def(&BattleGroundBrief::set_stage_id, "set_stage_id")
		.def(&BattleGroundBrief::has_stage_id, "has_stage_id")
		// required int32 battle_group_id = 6;
		.def(&BattleGroundBrief::battle_group_id, "battle_group_id")
		.def(&BattleGroundBrief::set_battle_group_id, "set_battle_group_id")
		// required bool can_manual_control = 7;
		.def(&BattleGroundBrief::can_manual_control, "can_manual_control")
		.def(&BattleGroundBrief::set_can_manual_control, "set_can_manual_control")
		// optional int32 mission_id = 8;
		.def(&BattleGroundBrief::mission_id, "mission_id")
		.def(&BattleGroundBrief::set_mission_id, "set_mission_id")
		.def(&BattleGroundBrief::has_mission_id, "has_mission_id")
		// optional fixed64 time_out = 9;
		.def(&BattleGroundBrief::time_out, "time_out")
		.def(&BattleGroundBrief::set_time_out, "set_time_out")
		.def(&BattleGroundBrief::has_time_out, "has_time_out")
		// optional fixed64 fight_time = 10;
		.def(&BattleGroundBrief::fight_time, "fight_time")
		.def(&BattleGroundBrief::set_fight_time, "set_fight_time")
		.def(&BattleGroundBrief::has_fight_time, "has_fight_time")
		.def(&BattleGroundBrief::ByteSize, "ByteSize")
		.def(&BattleGroundBrief::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ExitBattleGround_fflua_reg(lua_State* state)
{
//for decltype
	ExitBattleGround* message(nullptr);
	message;
	ff::fflua_register_t<ExitBattleGround, ctor()>(state, "ExitBattleGround", "google::protobuf::Message");
	return true;
}
bool BattleGroundInfo_fflua_reg(lua_State* state)
{
//for decltype
	BattleGroundInfo* message(nullptr);
	message;
	ff::fflua_register_t<BattleGroundInfo, ctor()>(state, "BattleGroundInfo", "google::protobuf::Message")
		// required .Packet.BattleGroundBrief brief = 1;
		.def(&BattleGroundInfo::brief, "brief")
		.def(&BattleGroundInfo::mutable_brief, "mutable_brief")
		// repeated .Packet.ActorBattleInfo attackers = 2;
		.def(&BattleGroundInfo::attackers_size, "attackers_size")
		.def<decltype(message->attackers(0)) (BattleGroundInfo::*)(int) const>(&BattleGroundInfo::attackers, "attackers")
		.def<decltype(message->mutable_attackers(0)) (BattleGroundInfo::*)(int)>(&BattleGroundInfo::mutable_attackers, "mutable_attackers")
		.def(&BattleGroundInfo::add_attackers, "add_attackers")
		// repeated .Packet.ActorBattleInfo defenders = 3;
		.def(&BattleGroundInfo::defenders_size, "defenders_size")
		.def<decltype(message->defenders(0)) (BattleGroundInfo::*)(int) const>(&BattleGroundInfo::defenders, "defenders")
		.def<decltype(message->mutable_defenders(0)) (BattleGroundInfo::*)(int)>(&BattleGroundInfo::mutable_defenders, "mutable_defenders")
		.def(&BattleGroundInfo::add_defenders, "add_defenders")
		.def(&BattleGroundInfo::ByteSize, "ByteSize")
		.def(&BattleGroundInfo::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorBattleInfo_fflua_reg(lua_State* state)
{
//for decltype
	ActorBattleInfo* message(nullptr);
	message;
	ff::fflua_register_t<ActorBattleInfo, ctor()>(state, "ActorBattleInfo", "google::protobuf::Message")
		// required .Packet.ActorBasicInfo base_info = 1;
		.def(&ActorBattleInfo::base_info, "base_info")
		.def(&ActorBattleInfo::mutable_base_info, "mutable_base_info")
		// required .Packet.BattleInfo battle_info = 2;
		.def(&ActorBattleInfo::battle_info, "battle_info")
		.def(&ActorBattleInfo::mutable_battle_info, "mutable_battle_info")
		// required .Packet.Position positon = 3;
		.def(&ActorBattleInfo::positon, "positon")
		.def(&ActorBattleInfo::mutable_positon, "mutable_positon")
		// required double direction = 4;
		.def(&ActorBattleInfo::direction, "direction")
		.def(&ActorBattleInfo::set_direction, "set_direction")
		// required .Packet.ActorStateType state = 5;
		.def(&ActorBattleInfo::state, "state")
		.def(&ActorBattleInfo::set_state, "set_state")
		// optional int32 monster_config_id = 6;
		.def(&ActorBattleInfo::monster_config_id, "monster_config_id")
		.def(&ActorBattleInfo::set_monster_config_id, "set_monster_config_id")
		.def(&ActorBattleInfo::has_monster_config_id, "has_monster_config_id")
		// required int32 object_radius = 7;
		.def(&ActorBattleInfo::object_radius, "object_radius")
		.def(&ActorBattleInfo::set_object_radius, "set_object_radius")
		// required int32 position_index = 8;
		.def(&ActorBattleInfo::position_index, "position_index")
		.def(&ActorBattleInfo::set_position_index, "set_position_index")
		// repeated .Packet.EquipItem equips = 9;
		.def(&ActorBattleInfo::equips_size, "equips_size")
		.def<decltype(message->equips(0)) (ActorBattleInfo::*)(int) const>(&ActorBattleInfo::equips, "equips")
		.def<decltype(message->mutable_equips(0)) (ActorBattleInfo::*)(int)>(&ActorBattleInfo::mutable_equips, "mutable_equips")
		.def(&ActorBattleInfo::add_equips, "add_equips")
		// required int32 side = 10;
		.def(&ActorBattleInfo::side, "side")
		.def(&ActorBattleInfo::set_side, "set_side")
		.def(&ActorBattleInfo::ByteSize, "ByteSize")
		.def(&ActorBattleInfo::SetInitialized, "SetInitialized")
		;
	return true;
}
bool NewActorCreated_fflua_reg(lua_State* state)
{
//for decltype
	NewActorCreated* message(nullptr);
	message;
	ff::fflua_register_t<NewActorCreated, ctor()>(state, "NewActorCreated", "google::protobuf::Message")
		// optional fixed64 creator_guid = 1;
		.def(&NewActorCreated::creator_guid, "creator_guid")
		.def(&NewActorCreated::set_creator_guid, "set_creator_guid")
		.def(&NewActorCreated::has_creator_guid, "has_creator_guid")
		// optional int32 skill_id = 2;
		.def(&NewActorCreated::skill_id, "skill_id")
		.def(&NewActorCreated::set_skill_id, "set_skill_id")
		.def(&NewActorCreated::has_skill_id, "has_skill_id")
		// repeated .Packet.ActorBattleInfo attackers = 3;
		.def(&NewActorCreated::attackers_size, "attackers_size")
		.def<decltype(message->attackers(0)) (NewActorCreated::*)(int) const>(&NewActorCreated::attackers, "attackers")
		.def<decltype(message->mutable_attackers(0)) (NewActorCreated::*)(int)>(&NewActorCreated::mutable_attackers, "mutable_attackers")
		.def(&NewActorCreated::add_attackers, "add_attackers")
		// repeated .Packet.ActorBattleInfo defenders = 4;
		.def(&NewActorCreated::defenders_size, "defenders_size")
		.def<decltype(message->defenders(0)) (NewActorCreated::*)(int) const>(&NewActorCreated::defenders, "defenders")
		.def<decltype(message->mutable_defenders(0)) (NewActorCreated::*)(int)>(&NewActorCreated::mutable_defenders, "mutable_defenders")
		.def(&NewActorCreated::add_defenders, "add_defenders")
		// required fixed64 time_stamp = 5;
		.def(&NewActorCreated::time_stamp, "time_stamp")
		.def(&NewActorCreated::set_time_stamp, "set_time_stamp")
		.def(&NewActorCreated::ByteSize, "ByteSize")
		.def(&NewActorCreated::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorDismiss_fflua_reg(lua_State* state)
{
//for decltype
	ActorDismiss* message(nullptr);
	message;
	ff::fflua_register_t<ActorDismiss, ctor()>(state, "ActorDismiss", "google::protobuf::Message")
		// required fixed64 guid = 1;
		.def(&ActorDismiss::guid, "guid")
		.def(&ActorDismiss::set_guid, "set_guid")
		// required fixed64 time_stamp = 2;
		.def(&ActorDismiss::time_stamp, "time_stamp")
		.def(&ActorDismiss::set_time_stamp, "set_time_stamp")
		.def(&ActorDismiss::ByteSize, "ByteSize")
		.def(&ActorDismiss::SetInitialized, "SetInitialized")
		;
	return true;
}
bool SetControlType_fflua_reg(lua_State* state)
{
//for decltype
	SetControlType* message(nullptr);
	message;
	ff::fflua_register_t<SetControlType, ctor()>(state, "SetControlType", "google::protobuf::Message")
		// required .Packet.ActorControlType contral_type = 1;
		.def(&SetControlType::contral_type, "contral_type")
		.def(&SetControlType::set_contral_type, "set_contral_type")
		.def(&SetControlType::ByteSize, "ByteSize")
		.def(&SetControlType::SetInitialized, "SetInitialized")
		;
	return true;
}
bool UpdateFollowState_fflua_reg(lua_State* state)
{
//for decltype
	UpdateFollowState* message(nullptr);
	message;
	ff::fflua_register_t<UpdateFollowState, ctor()>(state, "UpdateFollowState", "google::protobuf::Message")
		// required bool follow = 1;
		.def(&UpdateFollowState::follow, "follow")
		.def(&UpdateFollowState::set_follow, "set_follow")
		.def(&UpdateFollowState::ByteSize, "ByteSize")
		.def(&UpdateFollowState::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ClientActorMove_fflua_reg(lua_State* state)
{
//for decltype
	ClientActorMove* message(nullptr);
	message;
	ff::fflua_register_t<ClientActorMove, ctor()>(state, "ClientActorMove", "google::protobuf::Message")
		// required fixed64 guid = 1;
		.def(&ClientActorMove::guid, "guid")
		.def(&ClientActorMove::set_guid, "set_guid")
		// required float direction = 2;
		.def(&ClientActorMove::direction, "direction")
		.def(&ClientActorMove::set_direction, "set_direction")
		// required fixed32 move_speed = 3;
		.def(&ClientActorMove::move_speed, "move_speed")
		.def(&ClientActorMove::set_move_speed, "set_move_speed")
		// required .Packet.Position old_pos = 4;
		.def(&ClientActorMove::old_pos, "old_pos")
		.def(&ClientActorMove::mutable_old_pos, "mutable_old_pos")
		// required .Packet.Position new_pos = 5;
		.def(&ClientActorMove::new_pos, "new_pos")
		.def(&ClientActorMove::mutable_new_pos, "mutable_new_pos")
		.def(&ClientActorMove::ByteSize, "ByteSize")
		.def(&ClientActorMove::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ClientActorStop_fflua_reg(lua_State* state)
{
//for decltype
	ClientActorStop* message(nullptr);
	message;
	ff::fflua_register_t<ClientActorStop, ctor()>(state, "ClientActorStop", "google::protobuf::Message")
		// optional fixed64 guid = 1;
		.def(&ClientActorStop::guid, "guid")
		.def(&ClientActorStop::set_guid, "set_guid")
		.def(&ClientActorStop::has_guid, "has_guid")
		// required float direction = 3;
		.def(&ClientActorStop::direction, "direction")
		.def(&ClientActorStop::set_direction, "set_direction")
		// required .Packet.Position stop_pos = 4;
		.def(&ClientActorStop::stop_pos, "stop_pos")
		.def(&ClientActorStop::mutable_stop_pos, "mutable_stop_pos")
		.def(&ClientActorStop::ByteSize, "ByteSize")
		.def(&ClientActorStop::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ClientActorUseSkill_fflua_reg(lua_State* state)
{
//for decltype
	ClientActorUseSkill* message(nullptr);
	message;
	ff::fflua_register_t<ClientActorUseSkill, ctor()>(state, "ClientActorUseSkill", "google::protobuf::Message")
		// required fixed64 guid = 1;
		.def(&ClientActorUseSkill::guid, "guid")
		.def(&ClientActorUseSkill::set_guid, "set_guid")
		// required int32 skill_id = 2;
		.def(&ClientActorUseSkill::skill_id, "skill_id")
		.def(&ClientActorUseSkill::set_skill_id, "set_skill_id")
		// repeated fixed64 target_guids = 3;
		.def(&ClientActorUseSkill::target_guids_size, "target_guids_size")
		.def<decltype(message->target_guids(0)) (ClientActorUseSkill::*)(int) const>(&ClientActorUseSkill::target_guids, "target_guids")
		.def<void(ClientActorUseSkill::*)(int, const decltype(message->target_guids(0)))>(&ClientActorUseSkill::set_target_guids, "set_target_guids")
		.def(&ClientActorUseSkill::add_target_guids, "add_target_guids")
		// optional fixed64 other_guids = 4;
		.def(&ClientActorUseSkill::other_guids, "other_guids")
		.def(&ClientActorUseSkill::set_other_guids, "set_other_guids")
		.def(&ClientActorUseSkill::has_other_guids, "has_other_guids")
		.def(&ClientActorUseSkill::ByteSize, "ByteSize")
		.def(&ClientActorUseSkill::SetInitialized, "SetInitialized")
		;
	return true;
}
bool BattleGroundInfo_fflua_regist_all(lua_State* state)
{
	PlayerStartHook_fflua_reg(state);
	PlayerEndHook_fflua_reg(state);
	ChangeHookInfo_fflua_reg(state);
	ChallengeBossReq_fflua_reg(state);
	ConstantChallengeBoss_fflua_reg(state);
	CancleChallengeBoss_fflua_reg(state);
	RushRewardNotify_fflua_reg(state);
	EnterBattleGroundReply_fflua_reg(state);
	PlayerReachBattlePos_fflua_reg(state);
	BattleGroundOverNotify_fflua_reg(state);
	BattleStartNotify_fflua_reg(state);
	RefreshBattleGround_fflua_reg(state);
	BattleGroundBrief_fflua_reg(state);
	ExitBattleGround_fflua_reg(state);
	BattleGroundInfo_fflua_reg(state);
	ActorBattleInfo_fflua_reg(state);
	NewActorCreated_fflua_reg(state);
	ActorDismiss_fflua_reg(state);
	SetControlType_fflua_reg(state);
	UpdateFollowState_fflua_reg(state);
	ClientActorMove_fflua_reg(state);
	ClientActorStop_fflua_reg(state);
	ClientActorUseSkill_fflua_reg(state);
	return true;
}
}
