// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BattleExpression.proto
#include "BattleExpression.pb.h"
#include "BattleExpression.proto.fflua.h"
namespace Packet {
bool SkillInfo_fflua_reg(lua_State* state)
{
//for decltype
	SkillInfo* message(nullptr);
	message;
	ff::fflua_register_t<SkillInfo, ctor()>(state, "SkillInfo", "google::protobuf::Message")
		// required int32 skill_id = 1;
		.def(&SkillInfo::skill_id, "skill_id")
		.def(&SkillInfo::set_skill_id, "set_skill_id")
		// required int32 skill_level = 2 [default = 1];
		.def(&SkillInfo::skill_level, "skill_level")
		.def(&SkillInfo::set_skill_level, "set_skill_level")
		// optional float bullet_speed = 3;
		.def(&SkillInfo::bullet_speed, "bullet_speed")
		.def(&SkillInfo::set_bullet_speed, "set_bullet_speed")
		.def(&SkillInfo::has_bullet_speed, "has_bullet_speed")
		.def(&SkillInfo::ByteSize, "ByteSize")
		.def(&SkillInfo::SetInitialized, "SetInitialized")
		;
	return true;
}
bool BuffInfo_fflua_reg(lua_State* state)
{
//for decltype
	BuffInfo* message(nullptr);
	message;
	ff::fflua_register_t<BuffInfo, ctor()>(state, "BuffInfo", "google::protobuf::Message")
		// required int32 buff_id = 1;
		.def(&BuffInfo::buff_id, "buff_id")
		.def(&BuffInfo::set_buff_id, "set_buff_id")
		// required int32 buff_level = 2 [default = 1];
		.def(&BuffInfo::buff_level, "buff_level")
		.def(&BuffInfo::set_buff_level, "set_buff_level")
		// optional .Packet.SkillInfo skill = 3;
		.def(&BuffInfo::skill, "skill")
		.def(&BuffInfo::mutable_skill, "mutable_skill")
		.def(&BuffInfo::has_skill, "has_skill")
		// optional int32 layer = 4;
		.def(&BuffInfo::layer, "layer")
		.def(&BuffInfo::set_layer, "set_layer")
		.def(&BuffInfo::has_layer, "has_layer")
		.def(&BuffInfo::ByteSize, "ByteSize")
		.def(&BuffInfo::SetInitialized, "SetInitialized")
		;
	return true;
}
bool TrapInfo_fflua_reg(lua_State* state)
{
//for decltype
	TrapInfo* message(nullptr);
	message;
	ff::fflua_register_t<TrapInfo, ctor()>(state, "TrapInfo", "google::protobuf::Message")
		// required int32 trap_id = 1;
		.def(&TrapInfo::trap_id, "trap_id")
		.def(&TrapInfo::set_trap_id, "set_trap_id")
		// required int32 trap_level = 2;
		.def(&TrapInfo::trap_level, "trap_level")
		.def(&TrapInfo::set_trap_level, "set_trap_level")
		// optional .Packet.Position pos = 3;
		.def(&TrapInfo::pos, "pos")
		.def(&TrapInfo::mutable_pos, "mutable_pos")
		.def(&TrapInfo::has_pos, "has_pos")
		// optional int32 range = 4;
		.def(&TrapInfo::range, "range")
		.def(&TrapInfo::set_range, "set_range")
		.def(&TrapInfo::has_range, "has_range")
		.def(&TrapInfo::ByteSize, "ByteSize")
		.def(&TrapInfo::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorMoveToTarget_fflua_reg(lua_State* state)
{
//for decltype
	ActorMoveToTarget* message(nullptr);
	message;
	ff::fflua_register_t<ActorMoveToTarget, ctor()>(state, "ActorMoveToTarget", "google::protobuf::Message")
		// required fixed64 source_guid = 1;
		.def(&ActorMoveToTarget::source_guid, "source_guid")
		.def(&ActorMoveToTarget::set_source_guid, "set_source_guid")
		// optional fixed64 target_guid = 2;
		.def(&ActorMoveToTarget::target_guid, "target_guid")
		.def(&ActorMoveToTarget::set_target_guid, "set_target_guid")
		.def(&ActorMoveToTarget::has_target_guid, "has_target_guid")
		// required int32 stop_range = 3;
		.def(&ActorMoveToTarget::stop_range, "stop_range")
		.def(&ActorMoveToTarget::set_stop_range, "set_stop_range")
		// required int32 move_speed = 4;
		.def(&ActorMoveToTarget::move_speed, "move_speed")
		.def(&ActorMoveToTarget::set_move_speed, "set_move_speed")
		// required fixed64 time_stamp = 5;
		.def(&ActorMoveToTarget::time_stamp, "time_stamp")
		.def(&ActorMoveToTarget::set_time_stamp, "set_time_stamp")
		// required int32 move_serial = 6;
		.def(&ActorMoveToTarget::move_serial, "move_serial")
		.def(&ActorMoveToTarget::set_move_serial, "set_move_serial")
		.def(&ActorMoveToTarget::ByteSize, "ByteSize")
		.def(&ActorMoveToTarget::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorMoveToTargetFinish_fflua_reg(lua_State* state)
{
//for decltype
	ActorMoveToTargetFinish* message(nullptr);
	message;
	ff::fflua_register_t<ActorMoveToTargetFinish, ctor()>(state, "ActorMoveToTargetFinish", "google::protobuf::Message")
		// required fixed64 source_guid = 1;
		.def(&ActorMoveToTargetFinish::source_guid, "source_guid")
		.def(&ActorMoveToTargetFinish::set_source_guid, "set_source_guid")
		// required int32 move_serial = 2;
		.def(&ActorMoveToTargetFinish::move_serial, "move_serial")
		.def(&ActorMoveToTargetFinish::set_move_serial, "set_move_serial")
		// required .Packet.Position pos = 3;
		.def(&ActorMoveToTargetFinish::pos, "pos")
		.def(&ActorMoveToTargetFinish::mutable_pos, "mutable_pos")
		.def(&ActorMoveToTargetFinish::ByteSize, "ByteSize")
		.def(&ActorMoveToTargetFinish::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorMoveToPos_fflua_reg(lua_State* state)
{
//for decltype
	ActorMoveToPos* message(nullptr);
	message;
	ff::fflua_register_t<ActorMoveToPos, ctor()>(state, "ActorMoveToPos", "google::protobuf::Message")
		// required fixed64 source_guid = 1;
		.def(&ActorMoveToPos::source_guid, "source_guid")
		.def(&ActorMoveToPos::set_source_guid, "set_source_guid")
		// required .Packet.Position target_pos = 2;
		.def(&ActorMoveToPos::target_pos, "target_pos")
		.def(&ActorMoveToPos::mutable_target_pos, "mutable_target_pos")
		// required int32 move_speed = 3;
		.def(&ActorMoveToPos::move_speed, "move_speed")
		.def(&ActorMoveToPos::set_move_speed, "set_move_speed")
		// required fixed64 time_stamp = 4;
		.def(&ActorMoveToPos::time_stamp, "time_stamp")
		.def(&ActorMoveToPos::set_time_stamp, "set_time_stamp")
		.def(&ActorMoveToPos::ByteSize, "ByteSize")
		.def(&ActorMoveToPos::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorUseSkill_fflua_reg(lua_State* state)
{
//for decltype
	ActorUseSkill* message(nullptr);
	message;
	ff::fflua_register_t<ActorUseSkill, ctor()>(state, "ActorUseSkill", "google::protobuf::Message")
		// required fixed64 source_guid = 1;
		.def(&ActorUseSkill::source_guid, "source_guid")
		.def(&ActorUseSkill::set_source_guid, "set_source_guid")
		// repeated fixed64 target_guid = 2;
		.def(&ActorUseSkill::target_guid_size, "target_guid_size")
		.def<decltype(message->target_guid(0)) (ActorUseSkill::*)(int) const>(&ActorUseSkill::target_guid, "target_guid")
		.def<void(ActorUseSkill::*)(int, const decltype(message->target_guid(0)))>(&ActorUseSkill::set_target_guid, "set_target_guid")
		.def(&ActorUseSkill::add_target_guid, "add_target_guid")
		// required .Packet.SkillInfo skill = 3;
		.def(&ActorUseSkill::skill, "skill")
		.def(&ActorUseSkill::mutable_skill, "mutable_skill")
		// required fixed64 time_stamp = 4;
		.def(&ActorUseSkill::time_stamp, "time_stamp")
		.def(&ActorUseSkill::set_time_stamp, "set_time_stamp")
		.def(&ActorUseSkill::ByteSize, "ByteSize")
		.def(&ActorUseSkill::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorCancelSkill_fflua_reg(lua_State* state)
{
//for decltype
	ActorCancelSkill* message(nullptr);
	message;
	ff::fflua_register_t<ActorCancelSkill, ctor()>(state, "ActorCancelSkill", "google::protobuf::Message")
		// required fixed64 source_guid = 1;
		.def(&ActorCancelSkill::source_guid, "source_guid")
		.def(&ActorCancelSkill::set_source_guid, "set_source_guid")
		// required int32 skill_id = 2;
		.def(&ActorCancelSkill::skill_id, "skill_id")
		.def(&ActorCancelSkill::set_skill_id, "set_skill_id")
		// required fixed64 time_stamp = 3;
		.def(&ActorCancelSkill::time_stamp, "time_stamp")
		.def(&ActorCancelSkill::set_time_stamp, "set_time_stamp")
		.def(&ActorCancelSkill::ByteSize, "ByteSize")
		.def(&ActorCancelSkill::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorBuffAttach_fflua_reg(lua_State* state)
{
//for decltype
	ActorBuffAttach* message(nullptr);
	message;
	ff::fflua_register_t<ActorBuffAttach, ctor()>(state, "ActorBuffAttach", "google::protobuf::Message")
		// required fixed64 source_guid = 1;
		.def(&ActorBuffAttach::source_guid, "source_guid")
		.def(&ActorBuffAttach::set_source_guid, "set_source_guid")
		// optional fixed64 target_guid = 2;
		.def(&ActorBuffAttach::target_guid, "target_guid")
		.def(&ActorBuffAttach::set_target_guid, "set_target_guid")
		.def(&ActorBuffAttach::has_target_guid, "has_target_guid")
		// required .Packet.BuffInfo buff = 3;
		.def(&ActorBuffAttach::buff, "buff")
		.def(&ActorBuffAttach::mutable_buff, "mutable_buff")
		// required fixed64 time_stamp = 4;
		.def(&ActorBuffAttach::time_stamp, "time_stamp")
		.def(&ActorBuffAttach::set_time_stamp, "set_time_stamp")
		.def(&ActorBuffAttach::ByteSize, "ByteSize")
		.def(&ActorBuffAttach::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorBuffRefresh_fflua_reg(lua_State* state)
{
//for decltype
	ActorBuffRefresh* message(nullptr);
	message;
	ff::fflua_register_t<ActorBuffRefresh, ctor()>(state, "ActorBuffRefresh", "google::protobuf::Message")
		// required fixed64 source_guid = 1;
		.def(&ActorBuffRefresh::source_guid, "source_guid")
		.def(&ActorBuffRefresh::set_source_guid, "set_source_guid")
		// optional fixed64 target_guid = 2;
		.def(&ActorBuffRefresh::target_guid, "target_guid")
		.def(&ActorBuffRefresh::set_target_guid, "set_target_guid")
		.def(&ActorBuffRefresh::has_target_guid, "has_target_guid")
		// required .Packet.BuffInfo buff = 3;
		.def(&ActorBuffRefresh::buff, "buff")
		.def(&ActorBuffRefresh::mutable_buff, "mutable_buff")
		// required fixed64 time_stamp = 4;
		.def(&ActorBuffRefresh::time_stamp, "time_stamp")
		.def(&ActorBuffRefresh::set_time_stamp, "set_time_stamp")
		.def(&ActorBuffRefresh::ByteSize, "ByteSize")
		.def(&ActorBuffRefresh::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorAddState_fflua_reg(lua_State* state)
{
//for decltype
	ActorAddState* message(nullptr);
	message;
	ff::fflua_register_t<ActorAddState, ctor()>(state, "ActorAddState", "google::protobuf::Message")
		// required fixed64 target_guid = 1;
		.def(&ActorAddState::target_guid, "target_guid")
		.def(&ActorAddState::set_target_guid, "set_target_guid")
		// required .Config.BattleObjectStatus state = 2;
		.def(&ActorAddState::state, "state")
		.def(&ActorAddState::set_state, "set_state")
		// required fixed64 time_stamp = 3;
		.def(&ActorAddState::time_stamp, "time_stamp")
		.def(&ActorAddState::set_time_stamp, "set_time_stamp")
		// optional float fear_dir = 4;
		.def(&ActorAddState::fear_dir, "fear_dir")
		.def(&ActorAddState::set_fear_dir, "set_fear_dir")
		.def(&ActorAddState::has_fear_dir, "has_fear_dir")
		.def(&ActorAddState::ByteSize, "ByteSize")
		.def(&ActorAddState::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorRemoveState_fflua_reg(lua_State* state)
{
//for decltype
	ActorRemoveState* message(nullptr);
	message;
	ff::fflua_register_t<ActorRemoveState, ctor()>(state, "ActorRemoveState", "google::protobuf::Message")
		// required fixed64 target_guid = 1;
		.def(&ActorRemoveState::target_guid, "target_guid")
		.def(&ActorRemoveState::set_target_guid, "set_target_guid")
		// required .Config.BattleObjectStatus state = 2;
		.def(&ActorRemoveState::state, "state")
		.def(&ActorRemoveState::set_state, "set_state")
		// required fixed64 time_stamp = 3;
		.def(&ActorRemoveState::time_stamp, "time_stamp")
		.def(&ActorRemoveState::set_time_stamp, "set_time_stamp")
		.def(&ActorRemoveState::ByteSize, "ByteSize")
		.def(&ActorRemoveState::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorBuffDettach_fflua_reg(lua_State* state)
{
//for decltype
	ActorBuffDettach* message(nullptr);
	message;
	ff::fflua_register_t<ActorBuffDettach, ctor()>(state, "ActorBuffDettach", "google::protobuf::Message")
		// optional fixed64 source_guid = 1;
		.def(&ActorBuffDettach::source_guid, "source_guid")
		.def(&ActorBuffDettach::set_source_guid, "set_source_guid")
		.def(&ActorBuffDettach::has_source_guid, "has_source_guid")
		// required fixed64 target_guid = 2;
		.def(&ActorBuffDettach::target_guid, "target_guid")
		.def(&ActorBuffDettach::set_target_guid, "set_target_guid")
		// required .Packet.BuffInfo buff = 3;
		.def(&ActorBuffDettach::buff, "buff")
		.def(&ActorBuffDettach::mutable_buff, "mutable_buff")
		// required fixed64 time_stamp = 4;
		.def(&ActorBuffDettach::time_stamp, "time_stamp")
		.def(&ActorBuffDettach::set_time_stamp, "set_time_stamp")
		.def(&ActorBuffDettach::ByteSize, "ByteSize")
		.def(&ActorBuffDettach::SetInitialized, "SetInitialized")
		;
	return true;
}
bool MoveSpeedUpdate_fflua_reg(lua_State* state)
{
//for decltype
	MoveSpeedUpdate* message(nullptr);
	message;
	ff::fflua_register_t<MoveSpeedUpdate, ctor()>(state, "MoveSpeedUpdate", "google::protobuf::Message")
		// required fixed64 target_guid = 1;
		.def(&MoveSpeedUpdate::target_guid, "target_guid")
		.def(&MoveSpeedUpdate::set_target_guid, "set_target_guid")
		// required int32 move_speed = 2;
		.def(&MoveSpeedUpdate::move_speed, "move_speed")
		.def(&MoveSpeedUpdate::set_move_speed, "set_move_speed")
		// optional .Packet.BuffInfo buff = 3;
		.def(&MoveSpeedUpdate::buff, "buff")
		.def(&MoveSpeedUpdate::mutable_buff, "mutable_buff")
		.def(&MoveSpeedUpdate::has_buff, "has_buff")
		// required fixed64 time_stamp = 4;
		.def(&MoveSpeedUpdate::time_stamp, "time_stamp")
		.def(&MoveSpeedUpdate::set_time_stamp, "set_time_stamp")
		.def(&MoveSpeedUpdate::ByteSize, "ByteSize")
		.def(&MoveSpeedUpdate::SetInitialized, "SetInitialized")
		;
	return true;
}
bool SkillEffects_fflua_reg(lua_State* state)
{
//for decltype
	SkillEffects* message(nullptr);
	message;
	ff::fflua_register_t<SkillEffects, ctor()>(state, "SkillEffects", "google::protobuf::Message")
		// repeated .Packet.ActorOnDamage damages = 1;
		.def(&SkillEffects::damages_size, "damages_size")
		.def<decltype(message->damages(0)) (SkillEffects::*)(int) const>(&SkillEffects::damages, "damages")
		.def<decltype(message->mutable_damages(0)) (SkillEffects::*)(int)>(&SkillEffects::mutable_damages, "mutable_damages")
		.def(&SkillEffects::add_damages, "add_damages")
		// repeated .Packet.ActorOnCure cures = 2;
		.def(&SkillEffects::cures_size, "cures_size")
		.def<decltype(message->cures(0)) (SkillEffects::*)(int) const>(&SkillEffects::cures, "cures")
		.def<decltype(message->mutable_cures(0)) (SkillEffects::*)(int)>(&SkillEffects::mutable_cures, "mutable_cures")
		.def(&SkillEffects::add_cures, "add_cures")
		// required fixed64 time_stamp = 3;
		.def(&SkillEffects::time_stamp, "time_stamp")
		.def(&SkillEffects::set_time_stamp, "set_time_stamp")
		.def(&SkillEffects::ByteSize, "ByteSize")
		.def(&SkillEffects::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorOnDamage_fflua_reg(lua_State* state)
{
//for decltype
	ActorOnDamage* message(nullptr);
	message;
	ff::fflua_register_t<ActorOnDamage, ctor()>(state, "ActorOnDamage", "google::protobuf::Message")
		// optional fixed64 source_guid = 1;
		.def(&ActorOnDamage::source_guid, "source_guid")
		.def(&ActorOnDamage::set_source_guid, "set_source_guid")
		.def(&ActorOnDamage::has_source_guid, "has_source_guid")
		// required fixed64 target_guid = 2;
		.def(&ActorOnDamage::target_guid, "target_guid")
		.def(&ActorOnDamage::set_target_guid, "set_target_guid")
		// required int32 damage = 3;
		.def(&ActorOnDamage::damage, "damage")
		.def(&ActorOnDamage::set_damage, "set_damage")
		// required .Packet.DamageType type = 4;
		.def(&ActorOnDamage::type, "type")
		.def(&ActorOnDamage::set_type, "set_type")
		// required .Packet.DamageExpression expression = 5;
		.def(&ActorOnDamage::expression, "expression")
		.def(&ActorOnDamage::set_expression, "set_expression")
		// required int32 old_hp = 6;
		.def(&ActorOnDamage::old_hp, "old_hp")
		.def(&ActorOnDamage::set_old_hp, "set_old_hp")
		// required int32 new_hp = 7;
		.def(&ActorOnDamage::new_hp, "new_hp")
		.def(&ActorOnDamage::set_new_hp, "set_new_hp")
		// optional .Packet.SkillInfo skill = 8;
		.def(&ActorOnDamage::skill, "skill")
		.def(&ActorOnDamage::mutable_skill, "mutable_skill")
		.def(&ActorOnDamage::has_skill, "has_skill")
		// optional .Packet.BuffInfo buff = 9;
		.def(&ActorOnDamage::buff, "buff")
		.def(&ActorOnDamage::mutable_buff, "mutable_buff")
		.def(&ActorOnDamage::has_buff, "has_buff")
		// optional .Packet.TrapInfo trap = 10;
		.def(&ActorOnDamage::trap, "trap")
		.def(&ActorOnDamage::mutable_trap, "mutable_trap")
		.def(&ActorOnDamage::has_trap, "has_trap")
		.def(&ActorOnDamage::ByteSize, "ByteSize")
		.def(&ActorOnDamage::SetInitialized, "SetInitialized")
		;
	return true;
}
bool FlashChainDamage_fflua_reg(lua_State* state)
{
//for decltype
	FlashChainDamage* message(nullptr);
	message;
	ff::fflua_register_t<FlashChainDamage, ctor()>(state, "FlashChainDamage", "google::protobuf::Message")
		// repeated .Packet.ActorOnDamage damages = 1;
		.def(&FlashChainDamage::damages_size, "damages_size")
		.def<decltype(message->damages(0)) (FlashChainDamage::*)(int) const>(&FlashChainDamage::damages, "damages")
		.def<decltype(message->mutable_damages(0)) (FlashChainDamage::*)(int)>(&FlashChainDamage::mutable_damages, "mutable_damages")
		.def(&FlashChainDamage::add_damages, "add_damages")
		// required fixed64 time_stamp = 2;
		.def(&FlashChainDamage::time_stamp, "time_stamp")
		.def(&FlashChainDamage::set_time_stamp, "set_time_stamp")
		.def(&FlashChainDamage::ByteSize, "ByteSize")
		.def(&FlashChainDamage::SetInitialized, "SetInitialized")
		;
	return true;
}
bool CureChain_fflua_reg(lua_State* state)
{
//for decltype
	CureChain* message(nullptr);
	message;
	ff::fflua_register_t<CureChain, ctor()>(state, "CureChain", "google::protobuf::Message")
		// repeated .Packet.ActorOnCure cures = 1;
		.def(&CureChain::cures_size, "cures_size")
		.def<decltype(message->cures(0)) (CureChain::*)(int) const>(&CureChain::cures, "cures")
		.def<decltype(message->mutable_cures(0)) (CureChain::*)(int)>(&CureChain::mutable_cures, "mutable_cures")
		.def(&CureChain::add_cures, "add_cures")
		// required fixed64 time_stamp = 2;
		.def(&CureChain::time_stamp, "time_stamp")
		.def(&CureChain::set_time_stamp, "set_time_stamp")
		.def(&CureChain::ByteSize, "ByteSize")
		.def(&CureChain::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorOnCure_fflua_reg(lua_State* state)
{
//for decltype
	ActorOnCure* message(nullptr);
	message;
	ff::fflua_register_t<ActorOnCure, ctor()>(state, "ActorOnCure", "google::protobuf::Message")
		// optional fixed64 source_guid = 1;
		.def(&ActorOnCure::source_guid, "source_guid")
		.def(&ActorOnCure::set_source_guid, "set_source_guid")
		.def(&ActorOnCure::has_source_guid, "has_source_guid")
		// required fixed64 target_guid = 2;
		.def(&ActorOnCure::target_guid, "target_guid")
		.def(&ActorOnCure::set_target_guid, "set_target_guid")
		// required int32 cure = 3;
		.def(&ActorOnCure::cure, "cure")
		.def(&ActorOnCure::set_cure, "set_cure")
		// required int32 old_hp = 4;
		.def(&ActorOnCure::old_hp, "old_hp")
		.def(&ActorOnCure::set_old_hp, "set_old_hp")
		// required int32 new_hp = 5;
		.def(&ActorOnCure::new_hp, "new_hp")
		.def(&ActorOnCure::set_new_hp, "set_new_hp")
		// optional .Packet.SkillInfo skill = 6;
		.def(&ActorOnCure::skill, "skill")
		.def(&ActorOnCure::mutable_skill, "mutable_skill")
		.def(&ActorOnCure::has_skill, "has_skill")
		// optional .Packet.BuffInfo buff = 7;
		.def(&ActorOnCure::buff, "buff")
		.def(&ActorOnCure::mutable_buff, "mutable_buff")
		.def(&ActorOnCure::has_buff, "has_buff")
		.def(&ActorOnCure::ByteSize, "ByteSize")
		.def(&ActorOnCure::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorDead_fflua_reg(lua_State* state)
{
//for decltype
	ActorDead* message(nullptr);
	message;
	ff::fflua_register_t<ActorDead, ctor()>(state, "ActorDead", "google::protobuf::Message")
		// optional fixed64 source_guid = 1;
		.def(&ActorDead::source_guid, "source_guid")
		.def(&ActorDead::set_source_guid, "set_source_guid")
		.def(&ActorDead::has_source_guid, "has_source_guid")
		// required fixed64 target_guid = 2;
		.def(&ActorDead::target_guid, "target_guid")
		.def(&ActorDead::set_target_guid, "set_target_guid")
		// optional .Packet.SkillInfo skill = 3;
		.def(&ActorDead::skill, "skill")
		.def(&ActorDead::mutable_skill, "mutable_skill")
		.def(&ActorDead::has_skill, "has_skill")
		// optional .Packet.BuffInfo buff = 4;
		.def(&ActorDead::buff, "buff")
		.def(&ActorDead::mutable_buff, "mutable_buff")
		.def(&ActorDead::has_buff, "has_buff")
		// required fixed64 time_stamp = 5;
		.def(&ActorDead::time_stamp, "time_stamp")
		.def(&ActorDead::set_time_stamp, "set_time_stamp")
		.def(&ActorDead::ByteSize, "ByteSize")
		.def(&ActorDead::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorRelive_fflua_reg(lua_State* state)
{
//for decltype
	ActorRelive* message(nullptr);
	message;
	ff::fflua_register_t<ActorRelive, ctor()>(state, "ActorRelive", "google::protobuf::Message")
		// optional fixed64 source_guid = 1;
		.def(&ActorRelive::source_guid, "source_guid")
		.def(&ActorRelive::set_source_guid, "set_source_guid")
		.def(&ActorRelive::has_source_guid, "has_source_guid")
		// required fixed64 target_guid = 2;
		.def(&ActorRelive::target_guid, "target_guid")
		.def(&ActorRelive::set_target_guid, "set_target_guid")
		// required int32 hp = 3;
		.def(&ActorRelive::hp, "hp")
		.def(&ActorRelive::set_hp, "set_hp")
		// required .Packet.SkillInfo skill = 4;
		.def(&ActorRelive::skill, "skill")
		.def(&ActorRelive::mutable_skill, "mutable_skill")
		// required fixed64 time_stamp = 5;
		.def(&ActorRelive::time_stamp, "time_stamp")
		.def(&ActorRelive::set_time_stamp, "set_time_stamp")
		.def(&ActorRelive::ByteSize, "ByteSize")
		.def(&ActorRelive::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorAddBuff_fflua_reg(lua_State* state)
{
//for decltype
	ActorAddBuff* message(nullptr);
	message;
	ff::fflua_register_t<ActorAddBuff, ctor()>(state, "ActorAddBuff", "google::protobuf::Message")
		// required fixed64 source_guid = 1;
		.def(&ActorAddBuff::source_guid, "source_guid")
		.def(&ActorAddBuff::set_source_guid, "set_source_guid")
		// required fixed64 target_guid = 2;
		.def(&ActorAddBuff::target_guid, "target_guid")
		.def(&ActorAddBuff::set_target_guid, "set_target_guid")
		// required .Packet.BuffInfo buff = 3;
		.def(&ActorAddBuff::buff, "buff")
		.def(&ActorAddBuff::mutable_buff, "mutable_buff")
		// required fixed64 time_stamp = 4;
		.def(&ActorAddBuff::time_stamp, "time_stamp")
		.def(&ActorAddBuff::set_time_stamp, "set_time_stamp")
		.def(&ActorAddBuff::ByteSize, "ByteSize")
		.def(&ActorAddBuff::SetInitialized, "SetInitialized")
		;
	return true;
}
bool SkillPositionLogic_fflua_reg(lua_State* state)
{
//for decltype
	SkillPositionLogic* message(nullptr);
	message;
	ff::fflua_register_t<SkillPositionLogic, ctor()>(state, "SkillPositionLogic", "google::protobuf::Message")
		// required .Packet.SkillPositionLogicType type = 1;
		.def(&SkillPositionLogic::type, "type")
		.def(&SkillPositionLogic::set_type, "set_type")
		// required fixed64 source_guid = 2;
		.def(&SkillPositionLogic::source_guid, "source_guid")
		.def(&SkillPositionLogic::set_source_guid, "set_source_guid")
		// required fixed64 target_guid = 3;
		.def(&SkillPositionLogic::target_guid, "target_guid")
		.def(&SkillPositionLogic::set_target_guid, "set_target_guid")
		// optional int32 move_speed = 4;
		.def(&SkillPositionLogic::move_speed, "move_speed")
		.def(&SkillPositionLogic::set_move_speed, "set_move_speed")
		.def(&SkillPositionLogic::has_move_speed, "has_move_speed")
		// optional .Packet.SkillInfo skill_info = 5;
		.def(&SkillPositionLogic::skill_info, "skill_info")
		.def(&SkillPositionLogic::mutable_skill_info, "mutable_skill_info")
		.def(&SkillPositionLogic::has_skill_info, "has_skill_info")
		// optional int32 range = 6;
		.def(&SkillPositionLogic::range, "range")
		.def(&SkillPositionLogic::set_range, "set_range")
		.def(&SkillPositionLogic::has_range, "has_range")
		// required fixed64 time_stamp = 7;
		.def(&SkillPositionLogic::time_stamp, "time_stamp")
		.def(&SkillPositionLogic::set_time_stamp, "set_time_stamp")
		.def(&SkillPositionLogic::ByteSize, "ByteSize")
		.def(&SkillPositionLogic::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorTransform_fflua_reg(lua_State* state)
{
//for decltype
	ActorTransform* message(nullptr);
	message;
	ff::fflua_register_t<ActorTransform, ctor()>(state, "ActorTransform", "google::protobuf::Message")
		// required fixed64 source_guid = 1;
		.def(&ActorTransform::source_guid, "source_guid")
		.def(&ActorTransform::set_source_guid, "set_source_guid")
		// required int32 new_res_id = 2;
		.def(&ActorTransform::new_res_id, "new_res_id")
		.def(&ActorTransform::set_new_res_id, "set_new_res_id")
		// required int32 new_hp = 3;
		.def(&ActorTransform::new_hp, "new_hp")
		.def(&ActorTransform::set_new_hp, "set_new_hp")
		// required int32 new_max_hp = 4;
		.def(&ActorTransform::new_max_hp, "new_max_hp")
		.def(&ActorTransform::set_new_max_hp, "set_new_max_hp")
		// required int32 radius = 5;
		.def(&ActorTransform::radius, "radius")
		.def(&ActorTransform::set_radius, "set_radius")
		// required fixed64 time_stamp = 6;
		.def(&ActorTransform::time_stamp, "time_stamp")
		.def(&ActorTransform::set_time_stamp, "set_time_stamp")
		.def(&ActorTransform::ByteSize, "ByteSize")
		.def(&ActorTransform::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorTransformCancel_fflua_reg(lua_State* state)
{
//for decltype
	ActorTransformCancel* message(nullptr);
	message;
	ff::fflua_register_t<ActorTransformCancel, ctor()>(state, "ActorTransformCancel", "google::protobuf::Message")
		// required fixed64 source_guid = 1;
		.def(&ActorTransformCancel::source_guid, "source_guid")
		.def(&ActorTransformCancel::set_source_guid, "set_source_guid")
		// required int32 radius = 2;
		.def(&ActorTransformCancel::radius, "radius")
		.def(&ActorTransformCancel::set_radius, "set_radius")
		// required fixed64 time_stamp = 3;
		.def(&ActorTransformCancel::time_stamp, "time_stamp")
		.def(&ActorTransformCancel::set_time_stamp, "set_time_stamp")
		.def(&ActorTransformCancel::ByteSize, "ByteSize")
		.def(&ActorTransformCancel::SetInitialized, "SetInitialized")
		;
	return true;
}
bool TrapCreate_fflua_reg(lua_State* state)
{
//for decltype
	TrapCreate* message(nullptr);
	message;
	ff::fflua_register_t<TrapCreate, ctor()>(state, "TrapCreate", "google::protobuf::Message")
		// required fixed64 guid = 1;
		.def(&TrapCreate::guid, "guid")
		.def(&TrapCreate::set_guid, "set_guid")
		// required .Packet.TrapInfo trap = 2;
		.def(&TrapCreate::trap, "trap")
		.def(&TrapCreate::mutable_trap, "mutable_trap")
		// required fixed64 time_stamp = 3;
		.def(&TrapCreate::time_stamp, "time_stamp")
		.def(&TrapCreate::set_time_stamp, "set_time_stamp")
		.def(&TrapCreate::ByteSize, "ByteSize")
		.def(&TrapCreate::SetInitialized, "SetInitialized")
		;
	return true;
}
bool TrapDestroy_fflua_reg(lua_State* state)
{
//for decltype
	TrapDestroy* message(nullptr);
	message;
	ff::fflua_register_t<TrapDestroy, ctor()>(state, "TrapDestroy", "google::protobuf::Message")
		// required fixed64 guid = 1;
		.def(&TrapDestroy::guid, "guid")
		.def(&TrapDestroy::set_guid, "set_guid")
		// required fixed64 time_stamp = 2;
		.def(&TrapDestroy::time_stamp, "time_stamp")
		.def(&TrapDestroy::set_time_stamp, "set_time_stamp")
		.def(&TrapDestroy::ByteSize, "ByteSize")
		.def(&TrapDestroy::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorDamage_fflua_reg(lua_State* state)
{
//for decltype
	ActorDamage* message(nullptr);
	message;
	ff::fflua_register_t<ActorDamage, ctor()>(state, "ActorDamage", "google::protobuf::Message")
		// required fixed64 guid = 1;
		.def(&ActorDamage::guid, "guid")
		.def(&ActorDamage::set_guid, "set_guid")
		// required int32 damage = 2;
		.def(&ActorDamage::damage, "damage")
		.def(&ActorDamage::set_damage, "set_damage")
		.def(&ActorDamage::ByteSize, "ByteSize")
		.def(&ActorDamage::SetInitialized, "SetInitialized")
		;
	return true;
}
bool ActorStat_fflua_reg(lua_State* state)
{
//for decltype
	ActorStat* message(nullptr);
	message;
	ff::fflua_register_t<ActorStat, ctor()>(state, "ActorStat", "google::protobuf::Message")
		// required fixed64 guid = 1;
		.def(&ActorStat::guid, "guid")
		.def(&ActorStat::set_guid, "set_guid")
		// required int32 value = 2;
		.def(&ActorStat::value, "value")
		.def(&ActorStat::set_value, "set_value")
		// optional int32 config_id = 3;
		.def(&ActorStat::config_id, "config_id")
		.def(&ActorStat::set_config_id, "set_config_id")
		.def(&ActorStat::has_config_id, "has_config_id")
		.def(&ActorStat::ByteSize, "ByteSize")
		.def(&ActorStat::SetInitialized, "SetInitialized")
		;
	return true;
}
bool Stat_fflua_reg(lua_State* state)
{
//for decltype
	Stat* message(nullptr);
	message;
	ff::fflua_register_t<Stat, ctor()>(state, "Stat", "google::protobuf::Message")
		// repeated .Packet.ActorStat damages = 1;
		.def(&Stat::damages_size, "damages_size")
		.def<decltype(message->damages(0)) (Stat::*)(int) const>(&Stat::damages, "damages")
		.def<decltype(message->mutable_damages(0)) (Stat::*)(int)>(&Stat::mutable_damages, "mutable_damages")
		.def(&Stat::add_damages, "add_damages")
		// repeated .Packet.ActorStat be_damages = 2;
		.def(&Stat::be_damages_size, "be_damages_size")
		.def<decltype(message->be_damages(0)) (Stat::*)(int) const>(&Stat::be_damages, "be_damages")
		.def<decltype(message->mutable_be_damages(0)) (Stat::*)(int)>(&Stat::mutable_be_damages, "mutable_be_damages")
		.def(&Stat::add_be_damages, "add_be_damages")
		// repeated .Packet.ActorStat cures = 3;
		.def(&Stat::cures_size, "cures_size")
		.def<decltype(message->cures(0)) (Stat::*)(int) const>(&Stat::cures, "cures")
		.def<decltype(message->mutable_cures(0)) (Stat::*)(int)>(&Stat::mutable_cures, "mutable_cures")
		.def(&Stat::add_cures, "add_cures")
		// optional fixed64 attacker_damage = 4;
		.def(&Stat::attacker_damage, "attacker_damage")
		.def(&Stat::set_attacker_damage, "set_attacker_damage")
		.def(&Stat::has_attacker_damage, "has_attacker_damage")
		// optional fixed64 defender_damage = 5;
		.def(&Stat::defender_damage, "defender_damage")
		.def(&Stat::set_defender_damage, "set_defender_damage")
		.def(&Stat::has_defender_damage, "has_defender_damage")
		// optional fixed64 attacker_cure = 6;
		.def(&Stat::attacker_cure, "attacker_cure")
		.def(&Stat::set_attacker_cure, "set_attacker_cure")
		.def(&Stat::has_attacker_cure, "has_attacker_cure")
		// optional fixed64 defender_cure = 7;
		.def(&Stat::defender_cure, "defender_cure")
		.def(&Stat::set_defender_cure, "set_defender_cure")
		.def(&Stat::has_defender_cure, "has_defender_cure")
		.def(&Stat::ByteSize, "ByteSize")
		.def(&Stat::SetInitialized, "SetInitialized")
		;
	return true;
}
bool StatisticInfo_fflua_reg(lua_State* state)
{
//for decltype
	StatisticInfo* message(nullptr);
	message;
	ff::fflua_register_t<StatisticInfo, ctor()>(state, "StatisticInfo", "google::protobuf::Message")
		// optional int32 player_exp = 1;
		.def(&StatisticInfo::player_exp, "player_exp")
		.def(&StatisticInfo::set_player_exp, "set_player_exp")
		.def(&StatisticInfo::has_player_exp, "has_player_exp")
		// optional int32 actor_exp = 2;
		.def(&StatisticInfo::actor_exp, "actor_exp")
		.def(&StatisticInfo::set_actor_exp, "set_actor_exp")
		.def(&StatisticInfo::has_actor_exp, "has_actor_exp")
		// repeated .Config.ItemPackageElement items = 3;
		.def(&StatisticInfo::items_size, "items_size")
		.def<decltype(message->items(0)) (StatisticInfo::*)(int) const>(&StatisticInfo::items, "items")
		.def<decltype(message->mutable_items(0)) (StatisticInfo::*)(int)>(&StatisticInfo::mutable_items, "mutable_items")
		.def(&StatisticInfo::add_items, "add_items")
		// optional fixed64 time_stamp = 4;
		.def(&StatisticInfo::time_stamp, "time_stamp")
		.def(&StatisticInfo::set_time_stamp, "set_time_stamp")
		.def(&StatisticInfo::has_time_stamp, "has_time_stamp")
		// optional int32 damage = 5;
		.def(&StatisticInfo::damage, "damage")
		.def(&StatisticInfo::set_damage, "set_damage")
		.def(&StatisticInfo::has_damage, "has_damage")
		// repeated .Packet.ActorDamage actordamage = 6;
		.def(&StatisticInfo::actordamage_size, "actordamage_size")
		.def<decltype(message->actordamage(0)) (StatisticInfo::*)(int) const>(&StatisticInfo::actordamage, "actordamage")
		.def<decltype(message->mutable_actordamage(0)) (StatisticInfo::*)(int)>(&StatisticInfo::mutable_actordamage, "mutable_actordamage")
		.def(&StatisticInfo::add_actordamage, "add_actordamage")
		.def(&StatisticInfo::ByteSize, "ByteSize")
		.def(&StatisticInfo::SetInitialized, "SetInitialized")
		;
	return true;
}
bool BattleExpression_fflua_regist_all(lua_State* state)
{
	SkillInfo_fflua_reg(state);
	BuffInfo_fflua_reg(state);
	TrapInfo_fflua_reg(state);
	ActorMoveToTarget_fflua_reg(state);
	ActorMoveToTargetFinish_fflua_reg(state);
	ActorMoveToPos_fflua_reg(state);
	ActorUseSkill_fflua_reg(state);
	ActorCancelSkill_fflua_reg(state);
	ActorBuffAttach_fflua_reg(state);
	ActorBuffRefresh_fflua_reg(state);
	ActorAddState_fflua_reg(state);
	ActorRemoveState_fflua_reg(state);
	ActorBuffDettach_fflua_reg(state);
	MoveSpeedUpdate_fflua_reg(state);
	SkillEffects_fflua_reg(state);
	ActorOnDamage_fflua_reg(state);
	FlashChainDamage_fflua_reg(state);
	CureChain_fflua_reg(state);
	ActorOnCure_fflua_reg(state);
	ActorDead_fflua_reg(state);
	ActorRelive_fflua_reg(state);
	ActorAddBuff_fflua_reg(state);
	SkillPositionLogic_fflua_reg(state);
	ActorTransform_fflua_reg(state);
	ActorTransformCancel_fflua_reg(state);
	TrapCreate_fflua_reg(state);
	TrapDestroy_fflua_reg(state);
	ActorDamage_fflua_reg(state);
	ActorStat_fflua_reg(state);
	Stat_fflua_reg(state);
	StatisticInfo_fflua_reg(state);
	return true;
}
}
